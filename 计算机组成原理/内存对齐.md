> [结构体进阶(深入理解：内存对齐，位段，枚举，联合)_联合类型存储空间-CSDN博客](https://blog.csdn.net/qq_49217297/article/details/121048259)


## 什么是内存对齐？
结构体的内存对齐是一种在内存中安排结构体成员的方式，其目的是为了提高内存访问效率和数据存储的一致性。

例如：
```c
struct Example1 {
    int a;//4字节
    char b;//1字节
    int c;//4字节
};
```

按照内存对齐的原则，在给这个结构体实例分配空间的时候，会为 char 类型的 b 变量分配和 int 类型的 a，c 变量一样大小的 4 字节内存

## 内存对齐的规则（C语言示例）
1. 结构体对齐规则首先要看有没有用`#pragma pack`宏声明，这个宏可以改变对齐规则，有宏定义的情况下结构体的自身宽度就是宏上规定的数值大小，所有内存都按照这个宽度去布局（这样说其实不太严谨，后面会提到），`#pragma pack` 参数只能是 '1', '2', '4', '8', or '16'。
2. 在没有`#pragma pack`这个宏的声明下，遵循下面三个原则：
	1. 第一个成员在与结构体变量偏移量为0的地址处。
	2. 其他成员变量**要对齐到某个数字（对齐数）的最小整数倍的地址处**。
	3. 结构体**总大小为最大对齐数（每个成员变量都有一个对齐数）的最小整数倍**。
	4. 如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍。

> **对齐数** = **编译器默认的一个对齐数与该成员大小的较小值**。

```c
struct S1
{
	char a1;
	int b1;
	double c1;
};
struct S2
{
	int a2;
	double b2;
	struct S1 s;
	char c2;
	int d2;
};
```
**S1的内存空间分析**
1. 变量a1是char类型，大小为1（字节），故自身的对齐数是1，第一个在起始偏移量为0的地指处，不用考虑起始偏移量/对齐数是否等于整数，因为0/任何数都能整除。
2. 变量b1是int类型，大小是4，故自身的对齐数是4。前面有变量，大小为1字节，起始偏移量为1，1 / 4 = 0余1，不是4的整数倍。要满足起始偏移量/对齐数 = 最小整数，所以b1的存储位置需要往后移三个字节，此时偏移量为4，4 / 4 = 1满足要求，b1就从该处存放。
3. 此时偏移量是8，变量c1是double类型，大小是8，对齐数也是8，8 / 8 = 1，满足要求，c1变量直接从此处存放。

成员变量存放完后，接下来就要估算结构体的大小。此时，结构的对齐数就是成员中的最大对齐数8，成员变量占据的空间大小为1 + 3 + 4 + 8 = 16，16 / 8 = 2（是最小整数倍）,满足要求，结构体的大小就计算完毕，就是16个字节。

**S2的内存空间分析**
1. 变量a2的对齐数是4，放在起始偏移量为0的地方。
2. 起始偏移量为4，变量b2的对齐数是8，4 / 8 = 0余4，不满足要求，再往后偏移四个字节，8 / 8 = 1，满足要求，存放。
3. 起始偏移量为4 + 4 + 8 = 16，结构体变量S的大小为16，对齐数为8，再计算是否满足起始偏移量/对齐数 = 最小整数，16 / 8 = 2（是最小整数），满足要求，存放。
4. 此时偏移量为32，变量c2的对齐数是1，32 / 1 = 32（是整数），满足要求，存放。
5. 此时偏移量为33，变量d2的对齐数是4，33 / 4 = 8余1，不满足要求，再往后移三个字节，36 / 4 = 9，满足要求，存放。
6. 此时总偏移量为40，变量b2的对齐数和内嵌结构体的对齐数都是8，结构体S2的对齐数就是所有成员变量的对齐数的最大者为8。40 / 8 = 5（是整数），满足要求。

故结构体S2的大小就是40。

## 结构体设计技巧
在设计结构体的时候，如果结构体成员的顺序设计得合理的话，是可以避免不必要的内存消耗的。  
两个结构体的成员变量相同，但是成员变量的顺序不同，可能就会出现结构体的大小不同的情况：
```c
struct S1
{
	char c1;
	int i;
	char c2;
};
struct S2
{
	char c1;
	char c2;
	int i;
};
```
在VS编译器下第一个结构体大小为12，第二个结构体大小为8。通过前面的解释就可以理解

所以，在设计结构体时可以按照升序放置变量
## 为什么要内存对齐？
### 硬件效率
现代计算机的内存系统是以字节为单位进行编址的，但 **CPU 在访问内存时，并不是每次都能按字节精确地读取数据，而是以字长为单位进行读取**。

例如，对于 32 位的 CPU，字长为 4 字节，每次读取内存时会读取 4 个连续的字节。

如果数据存储没有按照内存对齐规则进行，那么在读取一个非对齐的数据时，可能需要多次访问内存，然后进行一定的拼接和截断，才能获取完整的数据，这会降低内存访问效率。

### 物理内存的结构
常见物理内存，都是由多个内存块芯片组成的，共同组成一个较大的内存

处于读取内存效率的考虑，连续地址会依次分布在不同的内存块上，然后在读取时可以通过并行读取，加快数据读取速度

例如，4个1GB的内存芯片组成了内存，要取一个4字节的int类型数字，机器字长32位

那么地址0x00,0x01,0x02,0x03是被均匀放在每一块内存上的上的，在读取时可以一次性把这些全部读出来

### 数据一致性
内存对齐规则有助于保证数据在不同的内存访问模式下的一致性。

当数据按照对齐规则存储时，不同的编译器和硬件平台在处理数据时能够更容易地保持数据的一致性和正确性。否则，可能会出现数据在不同的平台上读取和解释不一致的情况，导致程序出现错误或异常行为。