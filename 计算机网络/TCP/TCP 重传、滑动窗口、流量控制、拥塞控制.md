小林NB
## TCP 重传
TCP 实现可靠传输的方式之一。

当发送端的数据到达接收主机时，接收端主机会返回一个确认应答消息，表示已收到消息；如果消息丢失导致接收方没有接收到消息，就会通过**重传机制**解决
### 超时重传机制
在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 `ACK` 确认应答报文，就会重发该数据，也就是我们常说的**超时重传**。

超时重传的时间称为**RTO，超时重传时间 RTO 的值应该略大于报文往返 RTT 的值**
- 当超时时间 **RTO 较大**时，重发就慢，性能差；
- 当超时时间 **RTO 较小**时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发

> **大于报文往返 RTT：**
> 
> `RTT` 指的是**数据发送时刻到接收到确认的时刻的差值**，也就是包的往返时间。
> 
> 它是一个**动态变化的值**，需要**根据实际网络状况得到的采样**，再通过一定的算法计算得到

如果超时重发的数据，再次超时的时候，又需要重传的时候，TCP 的策略是**超时间隔加倍。**

也就是**每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。**

### 快速重传
超时触发重传存在的问题是，超时周期可能相对较长。

TCP 还有另外一种**快速重传（Fast Retransmit）机制**，它**不以时间为驱动，而是以数据驱动重传**。

快速重传的工作方式是**每次ACK当前最后一个未接收到（或者是丢失了）的段号。当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。**

> 如果已经接收到了后面的序号，前面丢失了，如何知道该重传哪些呢？
> 
> 使用SACK（selective acknowledgement）方法可以解决， **选择性确认**
#### SACK 方法
这种方式需要在 TCP 头部「选项」字段里加一个 `SACK` 的东西，它**可以将已收到的数据的信息发送给「发送方」**，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以**只重传丢失的数据**。
#### Duplicate SACK 方法
Duplicate SACK 又称 `D-SACK`，主要**使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。**
1. **ACK 丢包**
	**描述：**
	
	如果多个连续的ACK包丢失，发送方会认为丢包了，如果超时就会触发了重传机制
	
	**措施：**
	
	如果重传后成功接收首个数据包，在SACK字段标记这段数据报号范围。
	
	这样就能告诉发送方，之前的包已经收到了，是ACK包丢失导致了重复发包，然后继续按照ACK后面发包
2. **网络延时**
	**描述：**
	
	某个数据包因为网络问题很久没到达，该包触发快速重传后，又发送了一次；最后有两个包到达了接收方
	
	**措施：**
	
	SACK字段标记这段重复数据报号范围，告知发送放该段重复发送
3. **小结**
	1. 可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;
	2. 可以知道是不是「发送方」的数据包被网络延迟了;
	3. 可以知道网络中是不是把「发送方」的数据包给复制了;

## 滑动窗口

## 流量控制
TCP 的流量控制是一种机制，用于确保在数据发送方和接收方之间的数据传输速率匹配，以避免接收方被过多的数据淹没而导致缓冲区溢出。以下是关于 TCP 流量控制的介绍：

1. **原理**：
   - TCP 流量控制基于滑动窗口机制，其中每个 TCP 连接都有一个接收窗口和一个发送窗口。
   - 接收方通过 TCP 报文中的窗口字段通知发送方自己的可接收字节数量，即接收窗口大小。
   - 发送方根据接收窗口大小调整自己的发送速率，确保不会发送超出接收方缓冲区容量的数据量。
   - 发送窗口 `swnd` 和接收窗口 `rwnd` 是约等于的关系

2. **过程**：
   - 发送方发送数据，并等待接收到对应的确认应答（ACK）。
   - 接收方根据接收缓冲区的空闲空间大小动态调整接收窗口的大小，并通过 ACK 报文通知发送方。
   - 发送方根据接收窗口大小调整发送窗口，确保发送的数据量不超过接收方的缓冲区容量。

3. **应用**：
   - TCP 流量控制广泛应用于各种网络应用中，如 Web 浏览器、文件传输、视频流媒体等，确保数据传输的稳定和高效。
## 拥塞控制
**在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大....**

于是，就有了**拥塞控制**，控制的目的就是**避免「发送方」的数据填满整个网络。**

为了在「发送方」调节所要发送数据的量，定义了一个叫做「**拥塞窗口**」的概念。

> 「**拥塞窗口**」是发送方维护的一个的状态变量，它会根据**网络的拥塞程度动态变化的**。
> 
> 前面提到的TCP发送窗口，它的大小是**MIN(拥塞窗口，接收窗口)**
> 
> 只要网络中没有出现拥塞，`cwnd` 就会增大；网络中出现了拥塞，`cwnd` 就减少；

只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是**发生了超时重传，就会认为网络出现了拥塞。**

### 慢启动
启动的意思就是一点一点的提高发送数据包的数量。

具体规则是：**当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。** 容易理解这样实现了指数增长

慢启动并不会无限增长，有一个叫慢启动门限 `ssthresh` （slow start threshold）状态变量。

- 当 `cwnd` < `ssthresh` 时，使用慢启动算法。
- 当 `cwnd` >= `ssthresh` 时，就会使用「拥塞避免算法」。
### 拥塞避免算法

具体规则是：**每当收到一个 ACK 时，cwnd 增加 1/cwnd。** 此时窗口增长速度为线性。

> 线性的大概原因是，每当发送串口内的所有数据都经过了一轮发送后，且收到了ACK，才会让cwnd增加一

就这么一直增长着后，网络就会慢慢进入了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失的数据包进行重传。

**当触发了重传机制，也就进入了「拥塞发生算法」**

### 拥塞发生
当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：

**超时重传**

这个时候，ssthresh 和 cwnd 的值会发生变化：

- `ssthresh` 设为 `cwnd/2`，
- `cwnd` 重置为 `1` （是恢复为 cwnd 初始化值，我这里假定 cwnd 初始化值 1）
- 重新进入慢启动状态

**快速重传**

TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，则 `ssthresh` 和 `cwnd` 变化如下：

- `cwnd = cwnd/2` ，也就是设置为原来的一半;
- `ssthresh = cwnd`;
- 进入快速恢复算法

### 快速恢复
快速恢复算法如下：

- 拥塞窗口 `cwnd = ssthresh + 3` （ 3 的意思是确认有 3 个数据包被收到了）；
- 重传丢失的数据包；
- 如果再收到重复的 ACK，那么 cwnd 增加 1；
- 如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；

**快速恢复是拥塞发生后慢启动的优化，其首要目的仍然是降低 cwnd 来减缓拥塞，所以必然会出现 cwnd 从大到小的改变。**

**过程2（cwnd逐渐加1）的存在是为了尽快将丢失的数据包发给目标，从而解决拥塞的根本问题（三次相同的 ACK 导致的快速重传），所以这一过程中 cwnd 反而是逐渐增大的。**

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/%E6%8B%A5%E5%A1%9E%E5%8F%91%E7%94%9F-%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0.drawio.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0)
> 学习自小林coding