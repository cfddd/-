来源[小端、大端、网络字节顺序、主机字节顺序 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/477207022)
一、为什么会有大端、小端问题

当CPU处理的数据的能力大于8位的时候，如16位、32位、64位的CPU处理器，由于寄存器宽度大于一个字节，那么必然存在一个如何将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式的出现。

![](https://pic3.zhimg.com/80/v2-dc03480e074d0bc77506216d9e2b2cb6_720w.webp)

小端、大端

上图是小端、大端的实际存储情况，具体分析如下。

1、小端存储模式

在小端存储模式中，**低地址**中存放的是**字数据**的**低字节**，**高地址**存放的是**字数据**的**高字节**。

图左侧中是小端的存储情况，其中0x12345678是数据，内存中低地址是0x0000，0x12345678字数据的低字节是78，所以78存在0x0000中，以此类推，最后得到图中小端的存储情况。

在计算机内部的处理都是小端字节序，因为计算都是从低位开始的，先处理低位字节效率较高。

注：0x12345678数据划分低字节和高字节的方法与正常整数划分百位、十位、个位是类似的。如，123中 百位是1，十位是2，个位是3，百位是高位，百位一定是比十位、个位大的。所以0x12345678中 12 是高字节，78是低字节。

  

2、大端存储模式

在大端存储模式中，**字数据**的**高字节**存储在**低地址**中，而**字数据**的**低字节**则存放在**高地址**中。

图右侧是大端情况，0x12345678是数据，高字节是12，内存中低地址是0x0000，所以0x0000中存的是高字节是12。以此类推，最后得到图中大端的存储情况。

在工作中，人类还是习惯读写大端字节序。所以，除了计算机的内部处理，其他的场合几乎都是大端字节序，比如网络传输和文件储存。

  

二、分析

上面介绍了大端、小端的概念和存储顺序，现在用代码实际的测试一下，具体如下。

```cpp
void bigOrSmall()
{
 int byte = 0x12345678;
 /*
 1位十六进制数可以用4位二进制数来表示
 16进制1位 = 2进制4位
 */
 char * ptr = (char *)&byte;
 printf("ptr  :%lu, byte  :%x \n",ptr,*ptr);
 printf("ptr+1:%lu, byte+1:%x, \n",(ptr+1),*(ptr+1));
}
```

这个函数主要是测试一下一个int类型数据在内存中存储的情况，首先大家要清楚，**栈的空间是向下增长的，栈的地址是由高向低增长的**。然后是把int * 类型转为 char * 类型，这样是才能一个字节一个字节的访问。要是不转为char * 类型，int * 类型指针 + 1 是偏移4个字节 （ 指针 + 1 偏移字节的多少是和 指针本身类型相关的 ）。最后是进行打印，第一个printf 中 ptr:%lu ，%lu是输出无符号的长整型。就是把byte第一个字节的地址转为无符号的长整型输出，byte:%x 是byte第一个字节地址中存的实际内容（ %x是以十六进制数形式输出整数 ）。第二个printf与此一致，只是打印的是byte第二个字节的信息。具体输出如下。

![](https://pic2.zhimg.com/80/v2-2d9b7758c437b5648549fc6382715789_720w.webp)

从图中可以知道，int byte的第一个字节地址 ptr 是低地址，第二个 ptr+1 是高地址，以此类推。然后要存储的数据是0x12345678，第一个地址存的是 78 ，第二地址存的是 56 ，78是低字节。因此可以确定是 低地址 存储的是 低字节，高地址 中存储的是 高字节 ，这就是小端。

在上面代码的基础上增加一句代码 “byte =htonl(byte);” （ htonl函数是把本地字节顺序转为网络字节顺序 ），关于htonl函数具体的会在下面介绍。代码运行结果如下图所示。

```cpp
void bigOrSmall()
{
 int byte = 0x12345678;
 byte = htonl(byte);
 /*
 1位十六进制数可以用4位二进制数来表示
 16进制1位 = 2进制4位
 */
 char * ptr = (char *)&byte;
 printf("ptr :%lu, byte :%x \n",ptr,*ptr);
 printf("ptr+1:%lu, byte+1:%x, \n",(ptr+1),*(ptr+1));
}
```
改完可以发现，int byte的第一个字节地址还是低地址，地址的高低顺序没有变化。但是第一个地址存储的数据是 12，第二个地址存储的是34，12在0x12345678中是属于高字节的。因此可以得知，低地址 存储的是 高字节，高地址 存储的 是低字节，这是大端。（因此可以推测出网络字节顺序是大端存储）

  

  

三、网络字节顺序、主机字节顺序

**网络字节顺序NBO（Network Byte Order）**：按从高到低的顺序存储（大端）。在网络上使用统一的网络字节顺序，可以避免兼容性问题。

**主机字节顺序（HBO，Host Byte Order）**：不同的机器HBO不相同，与CPU设计有关计算机数据存储有两种字节优先顺序：高位字节优先和低位字节优先。

一般地，在编译器里面设置的是小端顺序，这个可以根据自己的编译器看下设置，这里不深入说明。但是网络传输数据采用的是大端顺序。所以这才涉及到主机字节顺序和网络字节顺序，再说的详细一点，主机字节顺序可能是大端顺序或者小端顺序 ( 这个要看编译器的设置，还有自己是用的C还是Java还是其他的语言，其各自都是不尽相同 ) ，但是网络字节顺序一定是大端顺序。

C/C++中有如下四个常用的转换函数，针对其中的htonl函数进行分析，其他的都是一样的。htonl函数中h表示的是host，to就是to转换的意思，n是network，l是long，结合这些来看就是把long类型参数从host主机顺序转为network网络顺序的意思。还有htons函数这样带 s 的，s表示的是short类型，其他的字母与上面一致。知道以上信息后记忆这些函数的名字应该会很快，函数具体信息如下。

1）htonl

函数原型：uint32_t htonl (uint32_t hostlong)

函数返回值：是一个32位的网络字节顺序。

函数的作用：是将一个32位数从 **主机字节顺序** 转换成 **网络字节顺序**。

**注：无符号的长整型 在 32位的系统是 4字节**。

2）htons

函数原型：uint16_t htons (uint16_t hostlong)

函数返回值：是一个16位的网络字节顺序。

函数的作用：是将一个16位数从 **主机字节顺序** 转换成 **网络字节顺序**。

**注：无符号的短整型 在 32位的系统是 2字节。**

3）ntohs

函数原型是：uint16_t ntohs (uint16_t hostlong)

函数返回值：是一个16位的主机字节顺序。

函数的作用：是将一个16位数由 **网络字节顺序** 转换为 **主机字节顺序**。

4）ntohl

函数原型是：uint32_t ntohs (uint32_t hostlong)

函数返回值：是一个32位的主机字节顺序。

函数的作用：是将一个32位数由 **网络字节顺序** 转换为 **主机字节顺序**。