## UDP套接字的特点
- UDP 也是一种不可靠的数据传输方式。
- 因为 UDP 没有 TCP 那么复杂，所以编程难度比较小，性能也比 TCP 高。在更重视性能的情况下可以选 择 UDP 的传输方式。 
- TCP 与 UDP 的区别很大一部分来源于流控制。也就是说 TCP 的生命在于流控制。
## UDP工作原理
与TCP不同，UDP不会进行流控制。
![](addition/Pasted%20image%2020230803172049.png)
IP的作用就是让离开主机B的UDP数据包准确传递到主机A。但把UDP包最终交给主机A的某一UDP套接字的过程则是由UDP完成的。
UDP最重要的作用就是根据端口号将传到主机的数据包交付给最终的UDP套接字。
### UDP并非每次都快于TCP
TCP比UDP慢的原因通常有以下两点。
- 收发数据前后进行的连接设置及清除过程。
- 收发数据过程中为保证可靠性而添加的流控制
## UDP服务器端/客户端
### UDP中的服务器端和客户端没有连接
UDP服务器端/客户端不像TCP那样在连接状态下交换数据，因此与TCP不同，无需经过连接过程。也就是说，不必调用TCP连接过程中调用的listen函数和accept函数。UDP中只有创建套接字的过程和数据交换过程。
### UDP服务器端和客户端均只需1个套接字
TCP中，套接字之间应该是一对一的关系。若要向10个客户端提供服务，则除了守门的服务器套接字外，还需要10个服务器端套接字。
但在UDP中，不管是服务器端还是客户端都只需要1个套接字。
### 基于UDP的数据I/O函数
创建好 TCP 套接字以后，传输数据时无需加上地址信息。因为 TCP 套接字将保持与对方套接字的连 接。换言之，TCP 套接字知道目标地址信息。
但 UDP 套接字不会保持连接状态（UDP 套接字只有简单 的邮筒功能），因此每次传输数据时都需要添加目标的地址信息。这相当于寄信前在信件中填写地址。 

接下来是 UDP 的相关函数：
与TCP最大不同就是要传递目标地址的信息
![](addition/Pasted%20image%2020230803172940.png)
介绍接收UDP数据的函数：
UDP数据的发送端并不固定，因此该函数定义为可接收发送端信息的形式，也就是将同时返回UDP数据包中的发送端信息。

![](addition/Pasted%20image%2020230803173022.png)

## UDP回声客户端服务端
UDP不同于TCP，不存在请求连接和受理过程，因此在某种意义上**无法明确区分服务器端和客户端**。只是因其提供服务而称为服务器端。

![](uecho_client.c)

![](uecho_server.c)
UDP程序中，调用sendto函数传输数据前应完成对套接字的地址分配工作，因此调用bind函数。
bind函数不区分TCP和UDP，也就是说,在UDP程序中同样可以调用。另外，如果调用sendto函数时发现尚未分配地址信息，则在首次调用sendto函数时给相应套接字自动分配IP和端口。

综上所述，调用sendto函数时**自动分配IP和端口号给相对的客户端**。

## UDP数据的传输特性

UDP是具有数据边界的协议，传输中调用IO函数的次数非常重要。
因此，输入函数的调用次数应和输出函数的调用次数完全一致，这样才能保证接收全部已发送数据。例如，调用3次输出函数发送的数据必须通过调用3次输入函数才能接收完。

**必须在UDP通信过程中使I/O函数调用次数保持一致**。

## 已连接(connected) UDP套接字与未连接（unconnected)UDP套接字
TCP套接字中需注册待传输数据的目标IP和端口号，而UDP中则无需注册。因此,通过sendto函数传输数据的过程大致可分为以下3个阶段。

- 第1阶段:向UDP套接字注册目标IP和端口号。
- 第2阶段:传输数据。
- 第3阶段:删除UDP套接字中注册的目标地址信息。

每次都变更目标地址，因此可以**重复利用同一 UDP 套接字向 不同目标传递数据**。
未注册目标地址信息的套接字称为未连接套接字，注册了目标地址的套 接字称为连接 connected 套接字。
UDP 套接字默认属于未连接套接字。当一台主机向另一台主 机传输很多信息时，上述的三个阶段中，第一个阶段和第三个阶段占整个通信过程中近三分之一的时间，缩短这部分的时间将会大大提高整体性能。

## 改进未连接UDP套接字为已连接UDP套接字
```cpp
connect(sock,(struct sockaddr*)&serv_adr, sizeof(serv_adr));
```

```cpp
/*
sendto(sock,message, strlen(message), 0,
	( struct sockaddr*)&serv_adr,sizeof(serv_adr));

str_len=recvfrom( sock, message,BUF_SIZE,0,
	( struct sockaddr*)&from_adr,sizeof(from_adr));

*/
write(sock,message, strlen(message));
str_len=read(sock,message,sizeof(message)-1);

```