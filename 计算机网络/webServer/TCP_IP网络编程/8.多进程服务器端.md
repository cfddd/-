### 并发服务端的实现方法
下面列出的是具有代表性的并发服务端的实现模型和方法：
- 多进程服务器:通过创建多个进程提供服务。
- 多路复用服务器:通过捆绑并统一管理I/O对象提供服务。
- 多线程服务器:通过生成与客户端等量的线程提供服务。
## 进程
进程是运行状态的程序
进程ID为大于2 的整数。1 要分配给操作系统启动后的（用于协助 操作系统）首个进程，因此用户无法得到 ID 值为 1 。接下来观察在 Linux 中运行的进程。
### 通过调用 fork 函数创建进程
fork 函数将创建调用的进程副本。
是复制正在运行 的、调用 fork 函数的进程。
**fork 函数调用后分成了完全不同的进程，只是二者共享同一段代码而已，父子进程拥有完全独立的内存结构。**
```cpp
#include <unistd.h>
pid_t fork(void); 
// 成功时返回进程ID,失败时返回 -1
```
可以利用下面的特点区分父子进程
- 父进程：fork 函数返回子进程 ID 
- 子进程：fork 函数返回 0

## 僵尸进程
进程完成工作后(执行完main函数中的程序后)应被销毁，但有时这些进程将变成僵尸进程，占用系统中的重要资源。这种状态下的进程称作“僵尸进程”,这也是给系统带来负担的原因之一。
僵尸进程是当子进程比父进程先结束，而父进程又没有回收子进程，释放子进程占用的资源，此 时子进程将成为一个僵尸进程。如果父进程先退出 ，子进程被init接管，子进程退出后init会回收 其占用的相关资源

![[Pasted image 20230804172516.png]]
![[Pasted image 20230804172628.png]]
可以看出，PID为10977的进程状态为僵尸进程（Z+)。另外，经过30秒的等待时间后，PID为10976的父进程和之前的僵尸子进程同时销毁。
### 销毁僵尸进程 1：利用 wait 函数
```cpp
#include  <sys/wait.h>
pid_t wait(int *statloc); 
// 成功时返回终止的子进程 ID ,失败时返回 -1 
```
调用此函数时如果已有子进程终止，那么子进程终止时传递的返回值（exit 函数的参数返回值，main 函数的 return 返回值）将保存到该函数的参数所指的内存空间。但函数参数指向的单元中还包含其他 信息，因此需要用下列宏进行分离：
- WIFEXITED 子进程正常终止时返回true
- WEXITSTATUS 返回子进程时的返回值
这就是通过 wait 函数消灭僵尸进程的方法
```cpp
wait(&status); //终止一个子进程
if (WIFEXITED(status)) 
	printf("Child send one: %d \n", WEXITSTATUS(status));
```
**调用 wait 函数时，如果没有已经终止的子进程，那么程序将阻塞（Blocking）直到有子进程终止，因此要谨慎调用该函数。**
### 销毁僵尸进程 2：使用 waitpid 函数
wait 函数会引起程序阻塞，还可以考虑调用 waitpid 函数。这是防止僵尸进程的第二种方法，也是防止 阻塞的方法。
![[Pasted image 20230804194147.png]]
## 信号处理
### 向操作系统求助
子进程终止的识别主体是操作系统，因此，引入信号处理机制（Signal Handing）。
此处「信号」是在特定事件发生时由操 作系统向进程发送的消息。另外，为了响应该消息，执行与消息相关的自定义操作的过程被称为「处理」或「信号处理」。
### 信号与signal函数
```cpp
#include <signal.h>
void (*signal(int signo, void (*func)(int)))(int); 
/* 
为了在产生信号时调用，返回之前注册的函数指针 
函数名: signal 
参数：int signo,void(*func)(int) 
返回类型：参数类型为int型，返回 void 型函数指针 
*/
```
**函数的返回值类型为函数指针**,因此函数声明有些繁琐。
**分层观察，从内向外**
0. `void (*func)(int)`
	函数指针，名为func，返回值为void，返回值为int
1. `signal( int sig, void (*func)(int))`
	函数，参数是一个int和一个函数指针
2. `void   (*signal(xxx))   (int)`
	signal函数返回的是一个函数指针，无返回值，有一个int参数
调用上述函数时,第一个参数为特殊情况信息，第二个参数为特殊情况下将要调用的函数的地址值（指针)。发生第一个参数代表的情况时，调用第二个参数所指的函数。

下面给出可以在signal函数中注册的部分特殊情况和对应的常数。
- SIGALRM:已到通过调用alarm函数注册的时间。
- SIGINT:输入CTRL+C。
- SIGCHLD:子进程终止

接下来编写 signal 函数的调用语句，分别完成如下两个请求
1. 已到通过 alarm 函数注册时间，请调用 timeout 函数 
2. 输入 ctrl+c 时调用 keycontrol 函数 
代表这 2 种情况的常数分别为 SIGALRM 和 SIGINT ，因此按如下方式调用 signal 函数。 
```cpp
signal(SIGALRM , timeout); 
signal(SIGINT , keycontrol);
```
以上就是信号注册过程。注册好信号之后，发生注册信号（注册的情况发生时），操作系统将调用该信号对应的函数。先介绍 alarm 函数。
![[Pasted image 20230806213612.png]]
- 如果调用该函数的同时向它传递一个正整型参数，相应时间后（以秒为单位）将产生 SIGALRM 信号。
- 若向该函数传递为 0 ，则之前对 SIGALRM 信号的预约将取消。
如果通过该函数预约信号后未指定该信号对应的处理函数，则（通过调用 signal 函数）**终止进程**，不做任何处理。

