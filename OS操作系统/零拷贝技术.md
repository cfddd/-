> 来源 [9.1 什么是零拷贝？ | 小林coding](https://xiaolincoding.com/os/8_network_system/zero_copy.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89-dma-%E6%8A%80%E6%9C%AF)
## DMA技术
DMA 技术，也就是**直接内存访问（_Direct Memory Access_）** 技术。

在进行 I/O 设备和内存的数据传输的时候，数据搬运的工作全部交给 **DMA 控制器**，而 CPU 不再参与任何与数据搬运相关的事情，这样 CPU 就可以去处理别的事务。

早期的计算机没有DMA，CPU在发起数据请求后，需要等待磁盘将数据准备就绪，然后发出中断，将数据从磁盘读取到寄存器，再写入内存。CPU在这个期间是没有办法执行其他任务的，所以需要一种技术把CPU解放出来，于是就有了DMA。

### 工作流程
CPU 不再参与 **将数据从磁盘控制器缓冲区搬运到内核空间** 的工作，这部分工作全程由 DMA 完成。

但是 CPU 在这个过程中也是必不可少的，因为传输什么数据，从哪里传输到哪里，都需要 CPU 来告诉 DMA 控制器。
- 【进程（CPU）】调用IO read方法后，进入阻塞状态
- 【CPU】将IO请求发送给【DMA】，然后继续执行其他任务
- 【DMA】将IO请求发送给【磁盘】
- 【磁盘】把数据读取到磁盘控制器的缓冲区中，当磁盘控制器的缓冲区被读满后，向 【DMA】 发起中断信号，告知自己缓冲区已满
- 【DMA】 收到磁盘的信号，将磁盘控制器缓冲区中的数据拷贝到内核缓冲区中，此时不占用 【CPU】，可以执行其他任务；
- 【DMA】读取到一定量时，会发送中断【CPU】
- 【CPU】将数据从内核空间拷贝到用户空间，系统调用返回
## 传统的文件传输
传统 I/O 的工作方式是，数据读取和写入是从用户空间到内核空间来回复制，而内核空间的数据是通过操作系统层面的 I/O 接口从磁盘读取或写入。 

代码通常如下，一般会需要两个系统调用：  
```c
read(file, tmp_buf, len); 
write(socket, tmp_buf, len);
```
![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/%E4%BC%A0%E7%BB%9F%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93.png)
从前面的DMA的数据流程可以发现：
- **在读取磁盘的数据时，CPU进行了两次的IO操作，两次的操作系统用户态和内核态的转变**
- 同理，在向**socket（文件描述符）写入发送数据时，有两次IO操作，两次的操作系统用户态和内核态的转变**

**上下文切换**的成本并不小，一次切换需要耗时几十纳秒到几微秒，虽然时间看上去很短，但是在高并发的场景下，这类时间容易被累积和放大，从而影响系统的性能。

从整体看，搬运一份数据，结果却有 4 次IO操作，过多的数据拷贝无疑会消耗 CPU 资源，大大降低了系统性能。

**要想提高文件传输的性能，就需要减少「用户态与内核态的上下文切换」和「内存拷贝」的次数**。

## 优化性能的方向
> 如何减少「用户态与内核态的上下文切换」的次数呢？

读取磁盘数据的时候，之所以要发生上下文切换，这是因为用户空间没有权限操作磁盘或网卡，内核的权限最高，这些操作设备的过程都需要交由操作系统内核来完成，所以一般要通过内核去完成某些任务的时候，就需要使用操作系统提供的系统调用函数。

所以，**要想减少上下文切换次数，就要减少系统调用的次数**。

> 如何减少「数据拷贝」的次数？

因为文件传输的应用场景中，在用户空间我们并不会对数据「再加工」，所以数据实际上可以不用搬运到用户空间，因此**用户的缓冲区是没有必要存在的**，或者说可以不用拷贝到用户空间

## 零拷贝
零拷贝技术就是为了减少 **上下文切换次数 和 数据拷贝次数** 的

零拷贝技术实现的方式通常有 2 种：

- mmap + write
- sendfile
### mmap + write
在前面我们知道，read() 系统调用的过程中会把内核缓冲区的数据拷贝到用户的缓冲区里，于是为了减少这一步开销，我们可以用 mmap() 替换 read() 系统调用函数。 
```c
buf = mmap(file, len);
write(sockfd, buf, len);
```
 mmap() 系统调用函数会直接把内核缓冲区里的数据「**映射**」到用户空间，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。
 ![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/mmap%20%2B%20write%20%E9%9B%B6%E6%8B%B7%E8%B4%9D.png)
**具体过程**：
- 应用进程调用了 mmap() 后，DMA 会把磁盘的数据拷贝到内核的缓冲区里。
- 接着，应用进程跟操作系统内核「共享」这个缓冲区； 
- 应用进程再调用 write()，操作系统直接将内核缓冲区的数据拷贝到 socket 缓冲区中，这一切都发生在内核态，由 CPU 来搬运数据； 
- 最后，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程是由 DMA 搬运的。

**通过使用 `mmap()` 来代替 `read()`， 可以减少一次数据拷贝的过程**，但是仍然有**两次系统调用，四次上下文切换**

### sendfile
```c
#include <sys/socket.h> 
ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);
```
它的前两个参数分别是目的端和源端的文件描述符，后面两个参数是源端的偏移量和复制数据的长度，返回值是实际复制数据的长度。

它可以替代前面的 read() 和 write() 这两个系统调用，这样就可以减少一次系统调用，也就减少了 2 次上下文切换的开销。

该系统调用，可以**直接把内核缓冲区里的数据拷贝到 socket 缓冲区里，不再拷贝到用户态**，这样就**只有 2 次上下文切换，和 3 次数据拷贝**。如下图：

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/senfile-3%E6%AC%A1%E6%8B%B7%E8%B4%9D.png)
### Linux 内核 `2.4` 版本 SG-DMA 技术
SG-DMA（The Scatter-Gather Direct Memory Access）技术（和普通的 DMA 有所不同），我们可以进一步减少通过 CPU 把内核缓冲区里的数据拷贝到 socket 缓冲区的过程。
- 第一步，通过 DMA 将磁盘上的数据拷贝到内核缓冲区里； 
- 第二步，缓冲区描述符和数据长度传到 socket 缓冲区，这样网卡的 SG-DMA 控制器就可以直接将内核缓存中的数据拷贝到网卡的缓冲区里，此过程不需要将数据从操作系统内核缓冲区拷贝到 socket 缓冲区中，这样就减少了一次数据拷贝；

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/senfile-%E9%9B%B6%E6%8B%B7%E8%B4%9D.png)
这个过程之中，只进行了 **2 次数据拷贝，2 次上下文切换**

**零拷贝（Zero-copy）技术，因为我们没有在内存层面去拷贝数据，也就是说全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的。**

零拷贝技术的文件传输方式相比传统文件传输的方式，减少了 2 次上下文切换和数据拷贝次数，只需要 2 次上下文切换和数据拷贝次数，就可以完成文件的传输，而且 2 次的数据拷贝过程，都不需要通过 CPU，2 次都是由 DMA 来搬运。 

**所以，总体来看，零拷贝技术可以把文件传输的性能提高至少一倍以上**

## PageCache 
前面的文件传输过程，第一步都是先需要先把**磁盘文件数据拷贝「内核缓冲区」** 里，这个「内核缓冲区」实际上是**磁盘高速缓存（PageCache）**。由于零拷贝使用了 PageCache 技术，可以使得零拷贝进一步提升了性能

PageCache 的优点主要是两个：

- **缓存最近被访问的数据**；
	- 程序运行具有**局部性**，通常刚被访问的数据在短时间内再次被访问的概率很高，于是可以**用 PageCache 来缓存最近被访问的数据，当空间不足时淘汰最久未被访问的缓存**。 
	- 所以，读磁盘数据的时候，优先在 PageCache 找，如果数据存在则可以直接返回；如果没有，则从磁盘中读取，然后缓存 PageCache 中。
- **预读功能**；
	- 读取磁盘数据的时候，需要找到数据所在的位置，但是对于机械磁盘来说，就是通过磁头旋转到数据所在的扇区，再开始「顺序」读取数据，但是旋转磁头这个物理动作是非常耗时的
	- 假设 read 方法每次只会读 32 KB 的字节，虽然 read 刚开始只会读 0 ～ 32 KB 的字节，但内核会把其后面的 32～64 KB 也读取到 PageCache，这样后面读取 32～64 KB 的成本就很低，如果在 32～64 KB 淘汰出 PageCache 前，进程读取到它了，收益就非常大




