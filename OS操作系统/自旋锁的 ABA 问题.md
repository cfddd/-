## 产生 ABA 问题的 CAS 机制
CAS（Compare and Swap）是一种乐观锁机制。CAS有3个操作数，预期值A，内存值V，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。

整个 CAS 操作是原子的，即在执行过程中不会被中断，确保多个线程并发执行时不会出现竞态条件。

ABA性质是指在使用自旋锁时，存在一种特定的情况，即一个线程在检查共享资源的值时，发现它的值为A，然后另一个线程将共享资源的值修改为B，接着再修改回A，最后第一个线程再次检查共享资源的值时，仍然发现它的值为A。

> 比如线程 x 和 线程 y 对同一个 int64 并发操作， x 要给 int64 + 1 ，前提是 int64 没有改变过；y 给 int64 +1 后又 -1
>
>如果 x 发现操作对象 int64 没有变过，显然不能判断是否 y 有没有操作。
>还会带来一些问题：
>
>1. 对线程 x 是否有影响，或者有那些潜在的影响
>2. 什么情况下需要考虑这个 ABA 问题
>3. 有哪些解决方案

## ABA问题的解决
解决ABA问题的常见方法是**使用版本号或者标记来标识共享资源的状态变化，以确保在检查共享资源的值时能够准确地判断其是否发生了变化**。

例如，可以在每次修改共享资源时都增加一个版本号，这样即使共享资源的值由A变为B再变回A，但是版本号会随着每次修改而增加，从而确保每次修改都能够被正确地识别出来。

## 拓展：乐观锁与悲观锁的比较
乐观锁和悲观锁是并发控制的两种主要策略，用于在多个并发操作中确保数据的一致性和完整性。

1. **悲观锁**：
   - 悲观锁的核心思想是在数据被并发访问时悲观地认为会发生冲突，因此在访问数据前先进行加锁，以防止其他事务的干扰。
   - 使用悲观锁时，数据一般会被锁定，直到当前事务完成对数据的操作，其他事务无法对其进行修改。
   - 典型的悲观锁实现包括数据库的行级锁和表级锁，以及程序中的互斥锁和读写锁。

2. **乐观锁**：
   - 乐观锁的核心思想是假设并发操作不会产生冲突，因此不对数据进行加锁，而是在更新数据时检查是否存在冲突。
   - 使用乐观锁时，每个事务在读取数据后会记录数据的版本号或时间戳，然后在更新数据时检查该版本号或时间戳是否发生变化，以确定是否发生了冲突。
   - 如果数据没有被其他事务修改，则当前事务可以顺利更新数据；如果数据已经被其他事务修改，则当前事务的更新操作会失败，需要进行重试或进行相应的处理。

比较：
- 性能：悲观锁在并发高的情况下可能会导致大量的锁竞争，降低性能，而乐观锁在没有冲突发生时无需加锁，性能相对较好。
- 并发控制粒度：悲观锁一般以锁的方式控制数据的访问，控制粒度较大；乐观锁在数据更新时进行冲突检测，控制粒度较小。
- 冲突处理：悲观锁在冲突发生时立即进行处理，但可能会导致频繁的锁等待和阻塞；乐观锁在冲突发生时延迟处理，需要通过重试或其他方式解决冲突。
- 适用场景：悲观锁适用于数据冲突频繁的场景，如高并发读写操作；乐观锁适用于数据冲突较少的场景，如读操作频繁、写操作较少的场景。

### 小结
选择悲观锁还是乐观锁取决于具体的应用场景和需求，需要综合考虑性能、并发控制粒度以及冲突处理等因素。


- 非忙等——互斥锁——重量级（悲观）锁
- 忙等——自旋锁——轻量级（乐观）锁

