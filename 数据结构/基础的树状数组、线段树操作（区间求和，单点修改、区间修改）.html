<span data-cke-copybin-start="1"><span data-cke-copybin-start="1">​</span></span>
<p id="main-toc"><strong>目录</strong></p>
<p id="%E5%8A%A8%E6%80%81%E6%B1%82%E8%BF%9E%E7%BB%AD%E5%8C%BA%E9%97%B4%E5%92%8C-toc"><a href="#%E5%8A%A8%E6%80%81%E6%B1%82%E8%BF%9E%E7%BB%AD%E5%8C%BA%E9%97%B4%E5%92%8C">动态求连续区间和</a></p>
<p id="%E6%89%80%E4%BB%A5%E7%94%A8%E5%88%B0%E5%8F%A6%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-toc"><a href="#%E6%89%80%E4%BB%A5%E7%94%A8%E5%88%B0%E5%8F%A6%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84">所以用到另一种方法&mdash;&mdash;树状数组</a></p>
<p id="%E5%8F%A6%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94%E7%BA%BF%E6%AE%B5%E6%A0%91-toc"><a href="#%E5%8F%A6%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94%E7%BA%BF%E6%AE%B5%E6%A0%91">另一种方法&mdash;&mdash;线段树</a></p>
<p id="%E5%AE%8C%E6%95%B4%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%BB%A3%E7%A0%81-toc"><a href="#%E5%AE%8C%E6%95%B4%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%BB%A3%E7%A0%81">完整线段树代码</a></p>
<p id="-toc">&nbsp;</p>
<p id="%E6%95%B0%E5%88%97%E5%8C%BA%E9%97%B4%E6%9C%80%E5%A4%A7%E5%80%BC-toc"><a href="#%E6%95%B0%E5%88%97%E5%8C%BA%E9%97%B4%E6%9C%80%E5%A4%A7%E5%80%BC">数列区间最大值</a></p>
<p id="%E5%88%86%E6%9E%90%EF%BC%9A%C2%A0-toc"><a href="#%E5%88%86%E6%9E%90%EF%BC%9A%C2%A0">分析：&nbsp;</a></p>
<p id="%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%EF%BC%9A-toc"><a href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%EF%BC%9A">具体实现：</a></p>
<p id="%E6%95%B0%E6%98%9F%E6%98%9F-toc"><a href="#%E6%95%B0%E6%98%9F%E6%98%9F">数星星</a></p>
<p id="%E5%B0%8F%E6%9C%8B%E5%8F%8B%E6%8E%92%E9%98%9F-toc"><a href="#%E5%B0%8F%E6%9C%8B%E5%8F%8B%E6%8E%92%E9%98%9F">小朋友排队</a></p>
<p id="%C2%A0%E5%88%86%E6%9E%90%EF%BC%9A-toc"><a href="#%C2%A0%E5%88%86%E6%9E%90%EF%BC%9A">&nbsp;分析：</a></p>
<p id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%88%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%EF%BC%89%EF%BC%9A%C2%A0-toc"><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%88%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%EF%BC%89%EF%BC%9A%C2%A0">代码实现（树状数组）：&nbsp;</a></p>
<p id="%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B4%E6%95%B0%E9%97%AE%E9%A2%982-toc"><a href="#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B4%E6%95%B0%E9%97%AE%E9%A2%982">一个简单的整数问题2</a></p>
<p id="%C2%A0%E4%BD%86%E6%98%AF%E8%BF%99%E6%A0%B7%E7%9A%84%E6%93%8D%E4%BD%9C%E6%98%BE%E7%84%B6%E6%95%88%E7%8E%87%E8%BF%87%E4%BD%8E%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E4%BA%86%E5%A4%A7%E9%87%8F%E7%9A%84%E9%87%8D%E5%A4%8D%E5%B7%AE%E5%88%86%C2%A0%E6%89%80%E4%BB%A5%E9%9C%80%E8%A6%81%E6%94%B9%E8%BF%9B-toc"><a href="#%C2%A0%E4%BD%86%E6%98%AF%E8%BF%99%E6%A0%B7%E7%9A%84%E6%93%8D%E4%BD%9C%E6%98%BE%E7%84%B6%E6%95%88%E7%8E%87%E8%BF%87%E4%BD%8E%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E4%BA%86%E5%A4%A7%E9%87%8F%E7%9A%84%E9%87%8D%E5%A4%8D%E5%B7%AE%E5%88%86%C2%A0%E6%89%80%E4%BB%A5%E9%9C%80%E8%A6%81%E6%94%B9%E8%BF%9B">&nbsp;改进</a></p>
<p id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc"><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">代码实现</a></p>
<hr id="hr-toc" />
<p>&nbsp;</p>
<blockquote>
<h2 id="%E5%8A%A8%E6%80%81%E6%B1%82%E8%BF%9E%E7%BB%AD%E5%8C%BA%E9%97%B4%E5%92%8C">动态求连续区间和</h2>
<p>给定&nbsp;n&nbsp;个数组成的一个数列，规定有两种操作，一是修改某个元素，二是求子数列&nbsp;[a,b][a,b]&nbsp;的连续和。</p>
<p><strong>输入格式</strong></p>
<p>第一行包含两个整数&nbsp;n 和&nbsp;m，分别表示数的个数和操作次数。</p>
<p>第二行包含&nbsp;n&nbsp;个整数，表示完整数列。</p>
<p>接下来&nbsp;m&nbsp;行，每行包含三个整数&nbsp;k,a,b （k=0，表示求子数列[a,b]的和；k=1，表示第&nbsp;a&nbsp;个数加&nbsp;b）。</p>
<p>数列从&nbsp;1&nbsp;开始计数。</p>
<p><strong>输出格式</strong></p>
<p>输出若干行数字，表示&nbsp;k=0 时，对应的子数列 [a,b]&nbsp;的连续和。</p>
<p><strong>数据范围</strong></p>
<p>1&le;n&le;100000,<br />
1&le;m&le;100000，<br />
1&le;a&le;b&le;n,<br />
数据保证在任何时候，数列中所有元素之和均在 int 范围内。</p>
<p><strong>输入样例：</strong></p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-display-name="代码段" data-cke-filter="off" data-cke-widget-id="38" data-cke-widget-wrapper="1">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22code%22%3A%2210%205%5Cn1%202%203%204%205%206%207%208%209%2010%5Cn1%201%205%5Cn0%201%203%5Cn0%204%208%5Cn1%207%205%5Cn0%204%208%5Cn%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="codeSnippet"><code class="hljs">10 5
1 2 3 4 5 6 7 8 9 10
1 1 5
0 1 3
0 4 8
1 7 5
0 4 8
</code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="https://img2023.cnblogs.com/blog/2740326/202301/2740326-20230123101534044-530598597.gif" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /></span></div>
<p><strong>输出样例：</strong></p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-display-name="代码段" data-cke-filter="off" data-cke-widget-id="37" data-cke-widget-wrapper="1">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22code%22%3A%2211%5Cn30%5Cn35%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="codeSnippet"><code class="hljs">11
30
35</code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="https://img2023.cnblogs.com/blog/2740326/202301/2740326-20230123101534044-530598597.gif" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /></span></div>
</blockquote>
<p>&nbsp;<span class="cke_widget_wrapper cke_widget_inline cke_widget_csdnlink cke_widget_selected" data-cke-display-name="a" data-cke-filter="off" data-cke-widget-id="36" data-cke-widget-wrapper="1"><a class="cke_widget_editable cke_widget_element" title="1264. 动态求连续区间和 - AcWing题库" href="https://www.acwing.com/problem/content/1266/" data-cke-enter-mode="2" data-cke-saved-href="https://www.acwing.com/problem/content/1266/" data-cke-widget-data="%7B%22url%22%3A%22https%3A%2F%2Fwww.acwing.com%2Fproblem%2Fcontent%2F1266%2F%22%2C%22text%22%3A%221264.%20%E5%8A%A8%E6%80%81%E6%B1%82%E8%BF%9E%E7%BB%AD%E5%8C%BA%E9%97%B4%E5%92%8C%20-%20AcWing%E9%A2%98%E5%BA%93%22%2C%22desc%22%3A%22%22%2C%22icon%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.0.8%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DM276%22%2C%22isCard%22%3Afalse%2C%22hasResquest%22%3Atrue%2C%22iconDefault%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.2.1%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DMBR7%22%2C%22id%22%3A%22kN4oh8-1674439874399%22%2C%22classes%22%3Anull%7D" data-cke-widget-editable="text" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.0.8/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=M276" data-link-title="1264. 动态求连续区间和 - AcWing题库" data-widget="csdnlink">1264. 动态求连续区间和 - AcWing题库</a></span></p>
<p>对于求区间问题，最先想到的应该是<strong>前缀和</strong></p>
<ul>
<li>建立一个前缀和数组</li>
<li>区间查询：O（1）</li>
<li>元素修改：O（n）</li>
</ul>
<p>&nbsp;显然元素修改可能存在过于复杂的情况</p>
<hr />
<h2 id="%E6%89%80%E4%BB%A5%E7%94%A8%E5%88%B0%E5%8F%A6%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84">所以用到另一种方法&mdash;&mdash;<strong>树状数组</strong></h2>
<ul>
<li>区间查询：O（log n）</li>
<li>元素修改：O（log n）</li>
</ul>
<p>在讲具体算法前，要先介绍一个具体的操作</p>
<ul>
<li><strong>lowbit运算&mdash;&mdash;找出一个数二进制的最低位1</strong>（例如9：1001&nbsp; &nbsp;-&gt;&nbsp; 1&nbsp; &nbsp; 12：1100&nbsp; &nbsp;-&gt;&nbsp; &nbsp;100）</li>
</ul>
<ol>
<li>设数为x，x按位取反，设为~x</li>
<li>x 按位与 ~x为0，当x按位与（~x+1）时，得到结果</li>
<li>计算机内的数字按照补码规则，负数的<strong>补码</strong>与对应<strong>正数的反码加一</strong>相等，所以简化为<strong>x &amp; -x</strong></li>
</ol>
<ul>
<li><strong>以lowbit运算为基础，构建一个树状数组</strong></li>
<li><span class="cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected" data-cke-display-name="图像" data-cke-filter="off" data-cke-widget-id="35" data-cke-widget-wrapper="1"><img src="https://img-blog.csdnimg.cn/8bf854a2e40e43dfaacd2a084f477a28.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5L-E572X5pav5Yi65rKZ6JOs,size_20,color_FFFFFF,t_70,g_se,x_16" alt="" class="cke_widget_element" data-cke-saved-src="https://img-blog.csdnimg.cn/8bf854a2e40e43dfaacd2a084f477a28.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5L-E572X5pav5Yi65rKZ6JOs,size_20,color_FFFFFF,t_70,g_se,x_16" data-cke-widget-data="%7B%22hasCaption%22%3Afalse%2C%22src%22%3A%22https%3A%2F%2Fimg-blog.csdnimg.cn%2F8bf854a2e40e43dfaacd2a084f477a28.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_d3F5LXplbmhlaQ%2Cshadow_50%2Ctext_Q1NETiBA5L-E572X5pav5Yi65rKZ6JOs%2Csize_20%2Ccolor_FFFFFF%2Ct_70%2Cg_se%2Cx_16%22%2C%22alt%22%3A%22%22%2C%22width%22%3A%22%22%2C%22height%22%3A%22%22%2C%22lock%22%3Atrue%2C%22align%22%3A%22none%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="image" /><span class="cke_reset cke_widget_drag_handler_container"><img src="https://img2023.cnblogs.com/blog/2740326/202301/2740326-20230123101534044-530598597.gif" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /><span class="cke_image_resizer" title="点击并拖拽以改变尺寸">​<span class="cke_widget_edit_container" title="编辑图片">编辑</span></span></span></span></li>
</ul>
<ol>
<li>
<p><strong>元素修改</strong></p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-display-name="代码段" data-cke-filter="off" data-cke-widget-id="34" data-cke-widget-wrapper="1">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22code%22%3A%22void%20add(int%20x%2Cint%20w)%7B%5Cn%20%20%20%20for(int%20i%20%3D%20x%3Bi%20%3C%3D%20n%3Bi%20%2B%3D%20lowbit(i))%7B%5Cn%20%20%20%20%20%20%20%20t%5Bi%5D%20%2B%3D%20w%3B%5Cn%20%20%20%20%7D%5Cn%7D%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="codeSnippet"><code class="hljs">void add(int x,int w){
    for(int i = x;i &lt;= n;i += lowbit(i)){
        t[i] += w;
    }
}</code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="https://img2023.cnblogs.com/blog/2740326/202301/2740326-20230123101534044-530598597.gif" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /></span></div>
</li>
<li>
<p><strong>区间查询</strong></p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-display-name="代码段" data-cke-filter="off" data-cke-widget-id="33" data-cke-widget-wrapper="1">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22code%22%3A%22int%20query(int%20u)%7B%5Cn%20%20%20%20int%20res%20%3D%200%3B%5Cn%20%20%20%20for(int%20i%20%3D%20u%3Bi%20%3E%200%3Bi%20-%3D%20lowbit(i))%7B%5Cn%20%20%20%20%20%20%20%20res%20%2B%3D%20t%5Bi%5D%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20return%20res%3B%5Cn%7D%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="codeSnippet"><code class="hljs">int query(int u){
    int res = 0;
    for(int i = u;i &gt; 0;i -= lowbit(i)){
        res += t[i];
    }
    return res;
}</code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="https://img2023.cnblogs.com/blog/2740326/202301/2740326-20230123101534044-530598597.gif" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /></span></div>
<p>&nbsp;</p>
</li>
</ol>
<p>&nbsp;实现这两个功能之后，就可以写出代码了</p>
<p>&nbsp;</p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-display-name="代码段" data-cke-filter="off" data-cke-widget-id="32" data-cke-widget-wrapper="1">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22lang%22%3A%22cpp%22%2C%22code%22%3A%22%23include%20%3Ciostream%3E%5Cn%23include%20%3Ccstring%3E%5Cn%23include%20%3Calgorithm%3E%5Cnusing%20namespace%20std%3B%5Cnconst%20int%20N%20%3D%201e5%2B10%3B%5Cnint%20t%5BN%5D%3B%5Cnint%20n%2Cm%3B%5Cn%5Cnint%20lowbit(int%20x)%20%20%2F%2F%20%E8%BF%94%E5%9B%9E%E6%9C%AB%E5%B0%BE%E7%9A%841%5Cn%7B%5Cn%20%20%20%20return%20x%20%26%20-x%3B%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%E6%AD%A3%E6%95%B0%E7%9A%84%E5%8F%8D%E7%A0%81%E5%8A%A0%E4%B8%80%E7%AD%89%E4%BA%8E%E8%A1%A5%E7%A0%81%EF%BC%8C%E5%8D%B3%E5%AF%B9%E5%BA%94%E8%B4%9F%E6%95%B0%5Cn%7D%5Cn%5Cnvoid%20add(int%20x%2Cint%20w)%7B%5Cn%20%20%20%20for(int%20i%20%3D%20x%3Bi%20%3C%3D%20n%3Bi%20%2B%3D%20lowbit(i))%7B%20%20%20%20%20%20%20%20%2F%2F%E4%BF%AE%E6%94%B9x~n%E4%B9%8B%E5%86%85x%E7%9A%84%E7%88%B6%E8%8A%82%E7%82%B9%E7%9A%84%E5%80%BC%5Cn%20%20%20%20%20%20%20%20t%5Bi%5D%20%2B%3D%20w%3B%5Cn%20%20%20%20%7D%5Cn%7D%5Cn%5Cnint%20query(int%20u)%7B%5Cn%20%20%20%20int%20res%20%3D%200%3B%5Cn%20%20%20%20for(int%20i%20%3D%20u%3Bi%20%3E%200%3Bi%20-%3D%20lowbit(i))%7B%20%20%20%20%20%20%20%20%20%2F%2F%E6%89%BE%E5%88%B0u%E4%B9%8B%E5%89%8D%E6%89%80%E6%9C%89%E7%9A%84%E5%AD%90%E8%8A%82%E7%82%B9%EF%BC%8C%E8%BE%93%E5%87%BA%E7%B4%AF%E5%8A%A0%E5%92%8C%5Cn%20%20%20%20%20%20%20%20res%20%2B%3D%20t%5Bi%5D%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20return%20res%3B%5Cn%7D%5Cn%5Cnint%20main()%5Cn%7B%5Cn%20%20%20%20cin%20%3E%3E%20n%20%3E%3E%20m%3B%5Cn%20%20%20%20for%20(int%20i%20%3D%201%3B%20i%20%3C%3D%20n%3B%20i%20%2B%2B%20)%7B%5Cn%20%20%20%20%20%20%20%20int%20t%3Bcin%20%3E%3E%20t%3B%5Cn%20%20%20%20%20%20%20%20add(i%2Ct)%3B%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E7%BB%84%5Cn%20%20%20%20%7D%5Cn%20%20%20%20for(int%20i%20%3D%201%3Bi%20%3C%3D%20m%3Bi%20%2B%2B)%7B%5Cn%20%20%20%20%20%20%20%20int%20k%2Ca%2Cb%3Bcin%20%3E%3E%20k%20%3E%3E%20a%20%3E%3E%20b%3B%5Cn%20%20%20%20%20%20%20%20if(k%20%3D%3D%201)%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20add(a%2Cb)%3B%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%E5%85%83%E7%B4%A0%E4%BF%AE%E6%94%B9%5Cn%20%20%20%20%20%20%20%20%7Delse%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20cout%20%3C%3C%20query(b)%20-%20query(a-1)%20%3C%3C%20endl%3B%2F%2F%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2%EF%BC%88%E4%BB%A5%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%BA%E5%9F%BA%E7%A1%80%EF%BC%89%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%7D%5Cn%20%20%20%20return%200%3B%5Cn%7D%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="codeSnippet"><code class="language-cpp hljs"><span class="hljs-meta">#<span class="hljs-keyword">include <span class="hljs-string">&lt;iostream&gt;
<span class="hljs-meta">#<span class="hljs-keyword">include <span class="hljs-string">&lt;cstring&gt;
<span class="hljs-meta">#<span class="hljs-keyword">include <span class="hljs-string">&lt;algorithm&gt;
<span class="hljs-keyword">using <span class="hljs-keyword">namespace std;
<span class="hljs-type">const <span class="hljs-type">int N = <span class="hljs-number">1e5+<span class="hljs-number">10;
<span class="hljs-type">int t[N];
<span class="hljs-type">int n,m;

<span class="hljs-function"><span class="hljs-type">int <span class="hljs-title">lowbit<span class="hljs-params">(<span class="hljs-type">int x)  <span class="hljs-comment">// 返回末尾的1
{
    <span class="hljs-keyword">return x &amp; -x;                               <span class="hljs-comment">//正数的反码加一等于补码，即对应负数
}

<span class="hljs-function"><span class="hljs-type">void <span class="hljs-title">add<span class="hljs-params">(<span class="hljs-type">int x,<span class="hljs-type">int w){
    <span class="hljs-keyword">for(<span class="hljs-type">int i = x;i &lt;= n;i += <span class="hljs-built_in">lowbit(i)){        <span class="hljs-comment">//修改x~n之内x的父节点的值
        t[i] += w;
    }
}

<span class="hljs-function"><span class="hljs-type">int <span class="hljs-title">query<span class="hljs-params">(<span class="hljs-type">int u){
    <span class="hljs-type">int res = <span class="hljs-number">0;
    <span class="hljs-keyword">for(<span class="hljs-type">int i = u;i &gt; <span class="hljs-number">0;i -= <span class="hljs-built_in">lowbit(i)){         <span class="hljs-comment">//找到u之前所有的子节点，输出累加和
        res += t[i];
    }
    <span class="hljs-keyword">return res;
}

<span class="hljs-function"><span class="hljs-type">int <span class="hljs-title">main<span class="hljs-params">()
{
    cin &gt;&gt; n &gt;&gt; m;
    <span class="hljs-keyword">for (<span class="hljs-type">int i = <span class="hljs-number">1; i &lt;= n; i ++ ){
        <span class="hljs-type">int t;cin &gt;&gt; t;
        <span class="hljs-built_in">add(i,t);                                 <span class="hljs-comment">//初始化数组
    }
    <span class="hljs-keyword">for(<span class="hljs-type">int i = <span class="hljs-number">1;i &lt;= m;i ++){
        <span class="hljs-type">int k,a,b;cin &gt;&gt; k &gt;&gt; a &gt;&gt; b;
        <span class="hljs-keyword">if(k == <span class="hljs-number">1){
            <span class="hljs-built_in">add(a,b);                             <span class="hljs-comment">//元素修改
        }<span class="hljs-keyword">else{
            cout &lt;&lt; <span class="hljs-built_in">query(b) - <span class="hljs-built_in">query(a<span class="hljs-number">-1) &lt;&lt; endl;<span class="hljs-comment">//区间查询（以前缀和为基础）
        }
    }
    <span class="hljs-keyword">return <span class="hljs-number">0;
}</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="https://img2023.cnblogs.com/blog/2740326/202301/2740326-20230123101534044-530598597.gif" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /></span></div>
<h2 id="%E5%8F%A6%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94%E7%BA%BF%E6%AE%B5%E6%A0%91">另一种方法&mdash;&mdash;线段树</h2>
<p><span class="cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected" data-cke-display-name="图像" data-cke-filter="off" data-cke-widget-id="31" data-cke-widget-wrapper="1"><img src="https://img-blog.csdnimg.cn/367c8b95035f48fe992533337001fde3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5L-E572X5pav5Yi65rKZ6JOs,size_20,color_FFFFFF,t_70,g_se,x_16" alt="" class="cke_widget_element" data-cke-saved-src="https://img-blog.csdnimg.cn/367c8b95035f48fe992533337001fde3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5L-E572X5pav5Yi65rKZ6JOs,size_20,color_FFFFFF,t_70,g_se,x_16" data-cke-widget-data="%7B%22hasCaption%22%3Afalse%2C%22src%22%3A%22https%3A%2F%2Fimg-blog.csdnimg.cn%2F367c8b95035f48fe992533337001fde3.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_d3F5LXplbmhlaQ%2Cshadow_50%2Ctext_Q1NETiBA5L-E572X5pav5Yi65rKZ6JOs%2Csize_20%2Ccolor_FFFFFF%2Ct_70%2Cg_se%2Cx_16%22%2C%22alt%22%3A%22%22%2C%22width%22%3A%22%22%2C%22height%22%3A%22%22%2C%22lock%22%3Atrue%2C%22align%22%3A%22none%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="image" /><span class="cke_reset cke_widget_drag_handler_container"><img src="https://img2023.cnblogs.com/blog/2740326/202301/2740326-20230123101534044-530598597.gif" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /><span class="cke_image_resizer" title="点击并拖拽以改变尺寸">​<span class="cke_widget_edit_container" title="编辑图片">编辑</span></span></span></span></p>
<ul>
<li>&nbsp;线段树的本质是一个二叉树，节点上存储的是两个端点和一些属性，所以像线段一样
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-display-name="代码段" data-cke-filter="off" data-cke-widget-id="30" data-cke-widget-wrapper="1">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22lang%22%3A%22cpp%22%2C%22code%22%3A%22struct%20node%7B%5Cn%20%20%20%20int%20l%2Cr%2Csum%3B%2F%2F%E8%BF%99%E9%87%8C%E5%AD%98%E6%94%BE%E7%BA%BF%E6%AE%B5%E4%B8%8A%E7%9A%84%E5%85%83%E7%B4%A0%E5%92%8C%5Cn%7Dnodes%5BN*4%5D%3B%5Cn%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="codeSnippet"><code class="language-cpp hljs"><span class="hljs-keyword">struct <span class="hljs-title class_">node{
    <span class="hljs-type">int l,r,sum;<span class="hljs-comment">//这里存放线段上的元素和
}nodes[N*<span class="hljs-number">4];
</span></span></span></span></span></code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="https://img2023.cnblogs.com/blog/2740326/202301/2740326-20230123101534044-530598597.gif" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /></span></div>
<p>像普通二叉树一样，对于<strong>节点x</strong>有</p>
</li>
</ul>
<ol>
<li>
<p><strong>左子节点</strong>&nbsp;&nbsp;<strong>x*2&nbsp; &nbsp;&nbsp; x &lt;&lt; 1</strong></p>
</li>
<li>
<p><strong>右子节点&nbsp; x*2+1&nbsp; &nbsp; &nbsp;x &lt;&lt; 1 | 1</strong></p>
</li>
</ol>
<ul>
<li>所以可以通过<strong>递归的方式，利用给定的一个数组，建立一个二叉树&nbsp; &nbsp; &nbsp;build(1,1,n)&nbsp;</strong>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-display-name="代码段" data-cke-filter="off" data-cke-widget-id="29" data-cke-widget-wrapper="1">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22lang%22%3A%22cpp%22%2C%22code%22%3A%22void%20pushup(int%20u)%7B%5Cn%20%20%20%20nodes%5Bu%5D.sum%20%3D%20nodes%5Bu%20%3C%3C%201%5D.sum%20%2B%20nodes%5Bu%20%3C%3C%201%20%7C%201%5D.sum%3B%5Cn%7D%5Cn%5Cnvoid%20build(int%20u%2Cint%20l%2Cint%20r)%7B%5Cn%20%20%20%20if(l%20%3D%3D%20r)nodes%5Bu%5D%20%3D%20%7Bl%2Cr%2Ca%5Br%5D%7D%3B%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%E7%BB%93%E6%9D%9F%EF%BC%9A%E9%95%BF%E5%BA%A6%E4%B8%BA1%E7%9A%84%E7%BA%BF%E6%AE%B5%E4%BD%9C%E4%B8%BA%E7%BB%88%E7%82%B9%5Cn%20%20%20%20else%7B%5Cn%20%20%20%20%20%20%20%20nodes%5Bu%5D%20%3D%20%7Bl%2Cr%7D%3B%5Cn%20%20%20%20%20%20%20%20int%20mid%20%3D%20l%20%2B%20r%20%3E%3E%201%3B%5Cn%20%20%20%20%20%20%20%20build(u%20%3C%3C%201%2Cl%2Cmid)%3B%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%E5%B7%A6%E8%8A%82%E7%82%B9%E9%80%92%E5%BD%92%5Cn%20%20%20%20%20%20%20%20build(u%20%3C%3C%201%20%7C%201%2Cmid%20%2B%201%2Cr)%3B%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%E5%8F%B3%E8%8A%82%E7%82%B9%E9%80%92%E5%BD%92%5Cn%20%20%20%20%20%20%20%20pushup(u)%3B%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%E4%BC%A0%E9%80%92%E5%80%BC%5Cn%20%20%20%20%7D%5Cn%7D%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="codeSnippet"><code class="language-cpp hljs"><span class="hljs-function"><span class="hljs-type">void <span class="hljs-title">pushup<span class="hljs-params">(<span class="hljs-type">int u){
    nodes[u].sum = nodes[u &lt;&lt; <span class="hljs-number">1].sum + nodes[u &lt;&lt; <span class="hljs-number">1 | <span class="hljs-number">1].sum;
}

<span class="hljs-function"><span class="hljs-type">void <span class="hljs-title">build<span class="hljs-params">(<span class="hljs-type">int u,<span class="hljs-type">int l,<span class="hljs-type">int r){
    <span class="hljs-keyword">if(l == r)nodes[u] = {l,r,a[r]};                          <span class="hljs-comment">//结束：长度为1的线段作为终点
    <span class="hljs-keyword">else{
        nodes[u] = {l,r};
        <span class="hljs-type">int mid = l + r &gt;&gt; <span class="hljs-number">1;
        <span class="hljs-built_in">build(u &lt;&lt; <span class="hljs-number">1,l,mid);                                  <span class="hljs-comment">//左节点递归
        <span class="hljs-built_in">build(u &lt;&lt; <span class="hljs-number">1 | <span class="hljs-number">1,mid + <span class="hljs-number">1,r);                          <span class="hljs-comment">//右节点递归
        <span class="hljs-built_in">pushup(u);                                            <span class="hljs-comment">//传递值
    }
}</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="https://img2023.cnblogs.com/blog/2740326/202301/2740326-20230123101534044-530598597.gif" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /></span></div>
</li>
<li>
<p><strong>元素修改&mdash;&mdash;递归查找到目标长度为1的节点，修改该节点的sum值，再回溯修改其母节点</strong></p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-display-name="代码段" data-cke-filter="off" data-cke-widget-id="28" data-cke-widget-wrapper="1">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22lang%22%3A%22cpp%22%2C%22code%22%3A%22void%20change(int%20u%2Cint%20x%2Cint%20w)%7B%5Cn%20%20%20%20if(nodes%5Bu%5D.l%20%3D%3D%20nodes%5Bu%5D.r)nodes%5Bu%5D.sum%20%2B%3D%20w%3B%2F%2F%E6%89%BE%E5%88%B0%E7%9B%AE%E6%A0%87%E8%8A%82%E7%82%B9%5Cn%20%20%20%20else%7B%5Cn%20%20%20%20%20%20%20%20int%20mid%20%3D%20nodes%5Bu%5D.l%20%2B%20nodes%5Bu%5D.r%20%3E%3E%201%3B%20%20%20%5Cn%20%20%20%20%20%20%20%20if(mid%20%3E%3D%20x)add(u%20%3C%3C%201%2Cx%2Cw)%3B%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%E7%B1%BB%E4%BC%BC%E4%BA%8E%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%5Cn%20%20%20%20%20%20%20%20else%20add(u%20%3C%3C%201%20%7C%201%2Cx%2Cw)%3B%20%5Cn%20%20%20%20%20%20%20%20pushup(u)%3B%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF%E4%BF%AE%E6%94%B9%E6%AF%8D%E8%8A%82%E7%82%B9%5Cn%20%20%20%20%7D%5Cn%7D%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="codeSnippet"><code class="language-cpp hljs"><span class="hljs-function"><span class="hljs-type">void <span class="hljs-title">change<span class="hljs-params">(<span class="hljs-type">int u,<span class="hljs-type">int x,<span class="hljs-type">int w){
    <span class="hljs-keyword">if(nodes[u].l == nodes[u].r)nodes[u].sum += w;<span class="hljs-comment">//找到目标节点
    <span class="hljs-keyword">else{
        <span class="hljs-type">int mid = nodes[u].l + nodes[u].r &gt;&gt; <span class="hljs-number">1;   
        <span class="hljs-keyword">if(mid &gt;= x)<span class="hljs-built_in">add(u &lt;&lt; <span class="hljs-number">1,x,w);              <span class="hljs-comment">//类似于二分查找
        <span class="hljs-keyword">else <span class="hljs-built_in">add(u &lt;&lt; <span class="hljs-number">1 | <span class="hljs-number">1,x,w); 
        <span class="hljs-built_in">pushup(u);                                <span class="hljs-comment">//递归回溯修改母节点
    }
}</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="https://img2023.cnblogs.com/blog/2740326/202301/2740326-20230123101534044-530598597.gif" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /></span></div>
&nbsp;
<p>&nbsp;</p>
</li>
<li>&nbsp;<strong>区间查询</strong></li>
</ul>
<ol>
<li><strong>设带查找区间为[ L , R ]，如果当前节点的两端点包含于[ L , R ]，返回当前节点的sum值</strong></li>
<li><strong>如果当前节点有在[ L , R ]之外的部分，需要判断<br />
	mid = （L + R）/ 2</strong><br />
	<strong>如果当前节点的区间有在mid左边的部分，就需要递归查询左节点；如果当前节点的区间有在mid右边的部分，就需要递归查询右节点</strong>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-display-name="代码段" data-cke-filter="off" data-cke-widget-id="27" data-cke-widget-wrapper="1">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22lang%22%3A%22cpp%22%2C%22code%22%3A%22int%20query(int%20u%2Cint%20l%2Cint%20r)%7B%5Cn%20%20%20%20if(l%20%3C%3D%20nodes%5Bu%5D.l%20%26%26%20nodes%5Bu%5D.r%20%3C%3D%20r)return%20nodes%5Bu%5D.sum%3B%2F%2F%E5%8C%85%E5%90%AB%E4%BA%8E%E7%9B%AE%E6%A0%87%E5%8C%BA%E9%97%B4%E4%B9%8B%E5%86%85%EF%BC%8C%E8%BF%94%E5%9B%9E%5Cn%20%20%20%20int%20mid%20%3D%20nodes%5Bu%5D.l%20%2B%20nodes%5Bu%5D.r%20%3E%3E%201%3B%5Cn%20%20%20%20int%20sum%20%3D%200%3B%5Cn%20%20%20%20if(mid%20%3E%3D%20l)sum%20%2B%3D%20query(u%20%3C%3C%201%2Cl%2Cr)%3B%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%E9%80%92%E5%BD%92%E5%B7%A6%E5%AD%90%E8%8A%82%E7%82%B9%5Cn%20%20%20%20if(mid%20%3C%20r)sum%20%2B%3D%20query(u%20%3C%3C%201%20%7C%201%2Cl%2Cr)%3B%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%E9%80%92%E5%BD%92%E5%8F%B3%E5%AD%90%E8%8A%82%E7%82%B9%5Cn%20%20%20%20return%20sum%3B%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cn%7D%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="codeSnippet"><code class="language-cpp hljs"><span class="hljs-function"><span class="hljs-type">int <span class="hljs-title">query<span class="hljs-params">(<span class="hljs-type">int u,<span class="hljs-type">int l,<span class="hljs-type">int r){
    <span class="hljs-keyword">if(l &lt;= nodes[u].l &amp;&amp; nodes[u].r &lt;= r)<span class="hljs-keyword">return nodes[u].sum;<span class="hljs-comment">//包含于目标区间之内，返回
    <span class="hljs-type">int mid = nodes[u].l + nodes[u].r &gt;&gt; <span class="hljs-number">1;
    <span class="hljs-type">int sum = <span class="hljs-number">0;
    <span class="hljs-keyword">if(mid &gt;= l)sum += <span class="hljs-built_in">query(u &lt;&lt; <span class="hljs-number">1,l,r);                     <span class="hljs-comment">//递归左子节点
    <span class="hljs-keyword">if(mid &lt; r)sum += <span class="hljs-built_in">query(u &lt;&lt; <span class="hljs-number">1 | <span class="hljs-number">1,l,r);                  <span class="hljs-comment">//递归右子节点
    <span class="hljs-keyword">return sum;                                               
}</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="https://img2023.cnblogs.com/blog/2740326/202301/2740326-20230123101534044-530598597.gif" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /></span></div>
<p>&nbsp;</p>
</li>
</ol>
<h2 id="%E5%AE%8C%E6%95%B4%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%BB%A3%E7%A0%81">完整线段树代码</h2>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-display-name="代码段" data-cke-filter="off" data-cke-widget-id="26" data-cke-widget-wrapper="1">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22lang%22%3A%22cpp%22%2C%22code%22%3A%22%23include%20%3Ciostream%3E%5Cn%23include%20%3Ccstring%3E%5Cn%23include%20%3Calgorithm%3E%5Cnusing%20namespace%20std%3B%5Cn%5Cnconst%20int%20N%20%3D%201e5%2B10%3B%5Cnint%20a%5BN%5D%3B%5Cnint%20n%2Cm%3B%5Cnstruct%20node%7B%5Cn%20%20%20%20int%20l%2Cr%2Csum%3B%5Cn%7Dnodes%5BN*4%5D%3B%5Cn%5Cnvoid%20pushup(int%20u)%7B%5Cn%20%20%20%20nodes%5Bu%5D.sum%20%3D%20nodes%5Bu%20%3C%3C%201%5D.sum%20%2B%20nodes%5Bu%20%3C%3C%201%20%7C%201%5D.sum%3B%5Cn%7D%5Cn%5Cnvoid%20build(int%20u%2Cint%20l%2Cint%20r)%7B%5Cn%20%20%20%20if(l%20%3D%3D%20r)nodes%5Bu%5D%20%3D%20%7Bl%2Cr%2Ca%5Br%5D%7D%3B%5Cn%20%20%20%20else%7B%5Cn%20%20%20%20%20%20%20%20nodes%5Bu%5D%20%3D%20%7Bl%2Cr%7D%3B%5Cn%20%20%20%20%20%20%20%20int%20mid%20%3D%20l%20%2B%20r%20%3E%3E%201%3B%5Cn%20%20%20%20%20%20%20%20build(u%20%3C%3C%201%2Cl%2Cmid)%3B%5Cn%20%20%20%20%20%20%20%20build(u%20%3C%3C%201%20%7C%201%2Cmid%20%2B%201%2Cr)%3B%5Cn%20%20%20%20%20%20%20%20pushup(u)%3B%5Cn%20%20%20%20%7D%5Cn%7D%5Cn%5Cnint%20query(int%20u%2Cint%20l%2Cint%20r)%7B%5Cn%20%20%20%20if(l%20%3C%3D%20nodes%5Bu%5D.l%20%26%26%20nodes%5Bu%5D.r%20%3C%3D%20r)return%20nodes%5Bu%5D.sum%3B%5Cn%20%20%20%20int%20mid%20%3D%20nodes%5Bu%5D.l%20%2B%20nodes%5Bu%5D.r%20%3E%3E%201%3B%5Cn%20%20%20%20int%20sum%20%3D%200%3B%5Cn%20%20%20%20if(mid%20%3E%3D%20l)sum%20%2B%3D%20query(u%20%3C%3C%201%2Cl%2Cr)%3B%5Cn%20%20%20%20if(mid%20%3C%20r)sum%20%2B%3D%20query(u%20%3C%3C%201%20%7C%201%2Cl%2Cr)%3B%5Cn%20%20%20%20return%20sum%3B%5Cn%7D%5Cn%5Cnvoid%20add(int%20u%2Cint%20x%2Cint%20w)%7B%5Cn%20%20%20%20if(nodes%5Bu%5D.l%20%3D%3D%20nodes%5Bu%5D.r)nodes%5Bu%5D.sum%20%2B%3D%20w%3B%5Cn%20%20%20%20else%7B%5Cn%20%20%20%20%20%20%20%20int%20mid%20%3D%20nodes%5Bu%5D.l%20%2B%20nodes%5Bu%5D.r%20%3E%3E%201%3B%5Cn%20%20%20%20%20%20%20%20if(mid%20%3E%3D%20x)add(u%20%3C%3C%201%2Cx%2Cw)%3B%5Cn%20%20%20%20%20%20%20%20else%20add(u%20%3C%3C%201%20%7C%201%2Cx%2Cw)%3B%5Cn%20%20%20%20%20%20%20%20pushup(u)%3B%5Cn%20%20%20%20%7D%5Cn%7D%5Cn%5Cnint%20main()%5Cn%7B%5Cn%20%20%20%20cin%20%3E%3E%20n%20%3E%3E%20m%3B%5Cn%20%20%20%20for%20(int%20i%20%3D%201%3B%20i%20%3C%3D%20n%3B%20i%20%2B%2B%20)cin%20%3E%3E%20a%5Bi%5D%3B%5Cn%20%20%20%20%5Cn%20%20%20%20build(1%2C1%2Cn)%3B%5Cn%20%20%20%20%5Cn%20%20%20%20int%20k%2Ca%2Cb%3B%5Cn%20%20%20%20for(int%20i%20%3D%200%3Bi%20%3C%20m%3B%20i%2B%2B)%7B%5Cn%20%20%20%20%20%20%20%20cin%20%3E%3E%20k%20%3E%3E%20a%20%3E%3E%20b%3B%5Cn%20%20%20%20%20%20%20%20if(k)%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20add(1%2Ca%2Cb)%3B%5Cn%20%20%20%20%20%20%20%20%7Delse%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20printf(%5C%22%25d%5C%5Cn%5C%22%2Cquery(1%2Ca%2Cb))%3B%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%7D%5Cn%7D%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="codeSnippet"><code class="language-cpp hljs"><span class="hljs-meta">#<span class="hljs-keyword">include <span class="hljs-string">&lt;iostream&gt;
<span class="hljs-meta">#<span class="hljs-keyword">include <span class="hljs-string">&lt;cstring&gt;
<span class="hljs-meta">#<span class="hljs-keyword">include <span class="hljs-string">&lt;algorithm&gt;
<span class="hljs-keyword">using <span class="hljs-keyword">namespace std;

<span class="hljs-type">const <span class="hljs-type">int N = <span class="hljs-number">1e5+<span class="hljs-number">10;
<span class="hljs-type">int a[N];
<span class="hljs-type">int n,m;
<span class="hljs-keyword">struct <span class="hljs-title class_">node{
    <span class="hljs-type">int l,r,sum;
}nodes[N*<span class="hljs-number">4];

<span class="hljs-function"><span class="hljs-type">void <span class="hljs-title">pushup<span class="hljs-params">(<span class="hljs-type">int u){
    nodes[u].sum = nodes[u &lt;&lt; <span class="hljs-number">1].sum + nodes[u &lt;&lt; <span class="hljs-number">1 | <span class="hljs-number">1].sum;
}

<span class="hljs-function"><span class="hljs-type">void <span class="hljs-title">build<span class="hljs-params">(<span class="hljs-type">int u,<span class="hljs-type">int l,<span class="hljs-type">int r){
    <span class="hljs-keyword">if(l == r)nodes[u] = {l,r,a[r]};
    <span class="hljs-keyword">else{
        nodes[u] = {l,r};
        <span class="hljs-type">int mid = l + r &gt;&gt; <span class="hljs-number">1;
        <span class="hljs-built_in">build(u &lt;&lt; <span class="hljs-number">1,l,mid);
        <span class="hljs-built_in">build(u &lt;&lt; <span class="hljs-number">1 | <span class="hljs-number">1,mid + <span class="hljs-number">1,r);
        <span class="hljs-built_in">pushup(u);
    }
}

<span class="hljs-function"><span class="hljs-type">int <span class="hljs-title">query<span class="hljs-params">(<span class="hljs-type">int u,<span class="hljs-type">int l,<span class="hljs-type">int r){
    <span class="hljs-keyword">if(l &lt;= nodes[u].l &amp;&amp; nodes[u].r &lt;= r)<span class="hljs-keyword">return nodes[u].sum;
    <span class="hljs-type">int mid = nodes[u].l + nodes[u].r &gt;&gt; <span class="hljs-number">1;
    <span class="hljs-type">int sum = <span class="hljs-number">0;
    <span class="hljs-keyword">if(mid &gt;= l)sum += <span class="hljs-built_in">query(u &lt;&lt; <span class="hljs-number">1,l,r);
    <span class="hljs-keyword">if(mid &lt; r)sum += <span class="hljs-built_in">query(u &lt;&lt; <span class="hljs-number">1 | <span class="hljs-number">1,l,r);
    <span class="hljs-keyword">return sum;
}

<span class="hljs-function"><span class="hljs-type">void <span class="hljs-title">add<span class="hljs-params">(<span class="hljs-type">int u,<span class="hljs-type">int x,<span class="hljs-type">int w){
    <span class="hljs-keyword">if(nodes[u].l == nodes[u].r)nodes[u].sum += w;
    <span class="hljs-keyword">else{
        <span class="hljs-type">int mid = nodes[u].l + nodes[u].r &gt;&gt; <span class="hljs-number">1;
        <span class="hljs-keyword">if(mid &gt;= x)<span class="hljs-built_in">add(u &lt;&lt; <span class="hljs-number">1,x,w);
        <span class="hljs-keyword">else <span class="hljs-built_in">add(u &lt;&lt; <span class="hljs-number">1 | <span class="hljs-number">1,x,w);
        <span class="hljs-built_in">pushup(u);
    }
}

<span class="hljs-function"><span class="hljs-type">int <span class="hljs-title">main<span class="hljs-params">()
{
    cin &gt;&gt; n &gt;&gt; m;
    <span class="hljs-keyword">for (<span class="hljs-type">int i = <span class="hljs-number">1; i &lt;= n; i ++ )cin &gt;&gt; a[i];
    
    <span class="hljs-built_in">build(<span class="hljs-number">1,<span class="hljs-number">1,n);
    
    <span class="hljs-type">int k,a,b;
    <span class="hljs-keyword">for(<span class="hljs-type">int i = <span class="hljs-number">0;i &lt; m; i++){
        cin &gt;&gt; k &gt;&gt; a &gt;&gt; b;
        <span class="hljs-keyword">if(k){
            <span class="hljs-built_in">add(<span class="hljs-number">1,a,b);
        }<span class="hljs-keyword">else{
            <span class="hljs-built_in">printf(<span class="hljs-string">"%d\n",<span class="hljs-built_in">query(<span class="hljs-number">1,a,b));
        }
    }
}</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="https://img2023.cnblogs.com/blog/2740326/202301/2740326-20230123101534044-530598597.gif" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /></span></div>
<h2>&nbsp;</h2>
<p>另一道与线段树相关的题目：<span class="cke_widget_wrapper cke_widget_inline cke_widget_csdnlink cke_widget_selected" data-cke-display-name="a" data-cke-filter="off" data-cke-widget-id="25" data-cke-widget-wrapper="1"><a class="cke_widget_editable cke_widget_element" title="1270. 数列区间最大值 - AcWing题库" href="https://www.acwing.com/problem/content/1272/" data-cke-enter-mode="2" data-cke-saved-href="https://www.acwing.com/problem/content/1272/" data-cke-widget-data="%7B%22url%22%3A%22https%3A%2F%2Fwww.acwing.com%2Fproblem%2Fcontent%2F1272%2F%22%2C%22text%22%3A%221270.%20%E6%95%B0%E5%88%97%E5%8C%BA%E9%97%B4%E6%9C%80%E5%A4%A7%E5%80%BC%20-%20AcWing%E9%A2%98%E5%BA%93%22%2C%22desc%22%3A%22%22%2C%22icon%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.0.8%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DM276%22%2C%22isCard%22%3Afalse%2C%22hasResquest%22%3Atrue%2C%22iconDefault%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.2.1%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DMBR7%22%2C%22id%22%3A%22uE89nk-1674439874385%22%2C%22classes%22%3Anull%7D" data-cke-widget-editable="text" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.0.8/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=M276" data-link-title="1270. 数列区间最大值 - AcWing题库" data-widget="csdnlink">1270. 数列区间最大值 - AcWing题库</a></span></p>
<blockquote>
<h2 id="%E6%95%B0%E5%88%97%E5%8C%BA%E9%97%B4%E6%9C%80%E5%A4%A7%E5%80%BC">数列区间最大值</h2>
<p>输入一串数字，给你&nbsp;M&nbsp;个询问，每次询问就给你两个数字&nbsp;X,Y要求你说出&nbsp;X&nbsp;到&nbsp;Y&nbsp;这段区间内的最大数。</p>
<p><strong>输入格式</strong></p>
<p>第一行两个整数&nbsp;N,M 表示数字的个数和要询问的次数；</p>
<p>接下来一行为&nbsp;N&nbsp;个数；</p>
<p>接下来&nbsp;M&nbsp;行，每行都有两个整数&nbsp;X,Y。</p>
<p><strong>输出格式</strong></p>
<p>输出共&nbsp;M&nbsp;行，每行输出一个数。</p>
<p><strong>数据范围</strong></p>
<p>1&le;N&le;100000，<br />
1&le;M&le;1000000，<br />
1&le;X&le;Y&le;N，<br />
数列中的数字均不超过2^31-1</p>
<p><strong>输入样例：</strong></p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-display-name="代码段" data-cke-filter="off" data-cke-widget-id="24" data-cke-widget-wrapper="1">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22code%22%3A%2210%202%5Cn3%202%204%205%206%208%201%202%209%207%5Cn1%204%5Cn3%208%5Cn%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="codeSnippet"><code class="hljs">10 2
3 2 4 5 6 8 1 2 9 7
1 4
3 8
</code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="https://img2023.cnblogs.com/blog/2740326/202301/2740326-20230123101534044-530598597.gif" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /></span></div>
<p><strong>输出样例：</strong></p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-display-name="代码段" data-cke-filter="off" data-cke-widget-id="23" data-cke-widget-wrapper="1">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22code%22%3A%225%5Cn8%5Cn%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="codeSnippet"><code class="hljs">5
8
</code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="https://img2023.cnblogs.com/blog/2740326/202301/2740326-20230123101534044-530598597.gif" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /></span></div>
</blockquote>
<h2 id="%E5%88%86%E6%9E%90%EF%BC%9A%C2%A0">分析：&nbsp;</h2>
<p>这个题目和&nbsp; 线段树区间查询、元素修改&nbsp; 基本方法差不多，都是线段树<br />
只需要把节点的 <strong>区间和</strong> 属性改成 <strong>区间最大值</strong> 即可</p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-display-name="代码段" data-cke-filter="off" data-cke-widget-id="22" data-cke-widget-wrapper="1">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22lang%22%3A%22cpp%22%2C%22code%22%3A%22struct%20node%7B%5Cn%20%20%20%20int%20l%2Cr%2Cmaxx%3B%2F%2F%E5%8C%BA%E9%97%B4%E6%9C%80%E5%A4%A7%E5%80%BC%5Cn%7Dnodes%5BN*4%5D%3B%5Cn%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="codeSnippet"><code class="language-cpp hljs"><span class="hljs-keyword">struct <span class="hljs-title class_">node{
    <span class="hljs-type">int l,r,maxx;<span class="hljs-comment">//区间最大值
}nodes[N*<span class="hljs-number">4];
</span></span></span></span></span></code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="https://img2023.cnblogs.com/blog/2740326/202301/2740326-20230123101534044-530598597.gif" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /></span></div>
<h2 id="%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%EF%BC%9A">具体实现：</h2>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-display-name="代码段" data-cke-filter="off" data-cke-widget-id="21" data-cke-widget-wrapper="1">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22lang%22%3A%22cpp%22%2C%22code%22%3A%22%23include%20%3Ccstdio%3E%5Cn%23include%20%3Ccstring%3E%5Cn%23include%20%3Ciostream%3E%5Cn%23include%20%3Calgorithm%3E%5Cn%23include%20%3Cclimits%3E%20%20%2F%2F%E4%BD%BF%E7%94%A8INT_MIN%E9%9C%80%E8%A6%81%E6%B7%BB%E5%8A%A0%E8%BF%99%E4%B8%AA%E5%BA%93%E5%87%BD%E6%95%B0%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%E8%BF%99%E9%87%8C%E6%89%BE%E5%87%BA%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E5%8F%AF%E8%83%BD%E6%9C%89%E8%B4%9F%E6%95%B0%5Cnusing%20namespace%20std%3B%5Cn%5Cnconst%20int%20N%20%3D%201e5%2B10%3B%5Cnint%20a%5BN%5D%3B%5Cnint%20n%2Cm%3B%5Cnstruct%20node%7B%5Cn%20%20%20%20int%20l%2Cr%2Cmaxx%3B%5Cn%7Dnodes%5BN*4%5D%3B%5Cn%5Cnvoid%20pushup(int%20u)%7B%5Cn%20%20%20%20nodes%5Bu%5D.maxx%20%3D%20max(nodes%5Bu%20%3C%3C%201%5D.maxx%20%2C%20nodes%5Bu%20%3C%3C%201%20%7C%201%5D.maxx)%3B%2F%2F%E4%BF%AE%E6%94%B9%E4%BA%86%E2%80%9C%E5%B1%9E%E6%80%A7%E2%80%9D%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95%5Cn%7D%5Cn%5Cnvoid%20build(int%20u%2Cint%20l%2Cint%20r)%7B%2F%2F%E5%88%9D%E5%A7%8B%E5%8C%96%5Cn%20%20%20%20if(l%20%3D%3D%20r)nodes%5Bu%5D%20%3D%20%7Bl%2Cr%2Ca%5Br%5D%7D%3B%5Cn%20%20%20%20else%7B%5Cn%20%20%20%20%20%20%20%20nodes%5Bu%5D%20%3D%20%7Bl%2Cr%7D%3B%5Cn%20%20%20%20%20%20%20%20int%20mid%20%3D%20l%20%2B%20r%20%3E%3E%201%3B%5Cn%20%20%20%20%20%20%20%20build(u%20%3C%3C%201%2Cl%2Cmid)%3B%5Cn%20%20%20%20%20%20%20%20build(u%20%3C%3C%201%20%7C%201%2Cmid%20%2B%201%2Cr)%3B%5Cn%20%20%20%20%20%20%20%20pushup(u)%3B%5Cn%20%20%20%20%7D%5Cn%7D%5Cn%5Cnint%20query(int%20u%2Cint%20l%2Cint%20r)%7B%2F%2F%E6%9F%A5%E8%AF%A2%E6%96%B9%E6%B3%95%5Cn%20%20%20%20if(l%20%3C%3D%20nodes%5Bu%5D.l%20%26%26%20nodes%5Bu%5D.r%20%3C%3D%20r)return%20nodes%5Bu%5D.maxx%3B%5Cn%20%20%20%20int%20mid%20%3D%20nodes%5Bu%5D.l%20%2B%20nodes%5Bu%5D.r%20%3E%3E%201%3B%5Cn%20%20%20%20int%20maxx%20%3D%20INT_MIN%3B%5Cn%20%20%20%20if(mid%20%3E%3D%20l)maxx%20%3D%20max(maxx%2Cquery(u%20%3C%3C%201%2Cl%2Cr))%3B%5Cn%20%20%20%20if(mid%20%3C%20r)maxx%20%3D%20max(maxx%2Cquery(u%20%3C%3C%201%20%7C%201%2Cl%2Cr))%3B%5Cn%20%20%20%20return%20maxx%3B%5Cn%7D%5Cn%5Cnint%20main()%5Cn%7B%5Cn%20%20%20%20cin%20%3E%3E%20n%20%3E%3E%20m%3B%5Cn%20%20%20%20for%20(int%20i%20%3D%201%3B%20i%20%3C%3D%20n%3B%20i%20%2B%2B%20)scanf(%5C%22%25d%5C%22%2Ca%2Bi)%3B%5Cn%20%20%20%20%5Cn%20%20%20%20build(1%2C1%2Cn)%3B%5Cn%20%20%20%20%5Cn%20%20%20%20int%20x%2Cy%3B%5Cn%20%20%20%20for(int%20i%20%3D%200%3Bi%20%3C%20m%3B%20i%2B%2B)%7B%5Cn%20%20%20%20%20%20%20%20scanf(%5C%22%25d%25d%5C%22%2C%20%26x%2C%20%26y)%3B%5Cn%20%20%20%20%20%20%20%20printf(%5C%22%25d%5C%5Cn%5C%22%2Cquery(1%2Cx%2Cy))%3B%5Cn%20%20%20%20%7D%5Cn%7D%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="codeSnippet"><code class="language-cpp hljs"><span class="hljs-meta">#<span class="hljs-keyword">include <span class="hljs-string">&lt;cstdio&gt;
<span class="hljs-meta">#<span class="hljs-keyword">include <span class="hljs-string">&lt;cstring&gt;
<span class="hljs-meta">#<span class="hljs-keyword">include <span class="hljs-string">&lt;iostream&gt;
<span class="hljs-meta">#<span class="hljs-keyword">include <span class="hljs-string">&lt;algorithm&gt;
<span class="hljs-meta">#<span class="hljs-keyword">include <span class="hljs-string">&lt;climits&gt;  <span class="hljs-comment">//使用INT_MIN需要添加这个库函数
                    <span class="hljs-comment">//这里找出的最大值可能有负数
<span class="hljs-keyword">using <span class="hljs-keyword">namespace std;

<span class="hljs-type">const <span class="hljs-type">int N = <span class="hljs-number">1e5+<span class="hljs-number">10;
<span class="hljs-type">int a[N];
<span class="hljs-type">int n,m;
<span class="hljs-keyword">struct <span class="hljs-title class_">node{
    <span class="hljs-type">int l,r,maxx;
}nodes[N*<span class="hljs-number">4];

<span class="hljs-function"><span class="hljs-type">void <span class="hljs-title">pushup<span class="hljs-params">(<span class="hljs-type">int u){
    nodes[u].maxx = <span class="hljs-built_in">max(nodes[u &lt;&lt; <span class="hljs-number">1].maxx , nodes[u &lt;&lt; <span class="hljs-number">1 | <span class="hljs-number">1].maxx);<span class="hljs-comment">//修改了&ldquo;属性&rdquo;计算方法
}

<span class="hljs-function"><span class="hljs-type">void <span class="hljs-title">build<span class="hljs-params">(<span class="hljs-type">int u,<span class="hljs-type">int l,<span class="hljs-type">int r){<span class="hljs-comment">//初始化
    <span class="hljs-keyword">if(l == r)nodes[u] = {l,r,a[r]};
    <span class="hljs-keyword">else{
        nodes[u] = {l,r};
        <span class="hljs-type">int mid = l + r &gt;&gt; <span class="hljs-number">1;
        <span class="hljs-built_in">build(u &lt;&lt; <span class="hljs-number">1,l,mid);
        <span class="hljs-built_in">build(u &lt;&lt; <span class="hljs-number">1 | <span class="hljs-number">1,mid + <span class="hljs-number">1,r);
        <span class="hljs-built_in">pushup(u);
    }
}

<span class="hljs-function"><span class="hljs-type">int <span class="hljs-title">query<span class="hljs-params">(<span class="hljs-type">int u,<span class="hljs-type">int l,<span class="hljs-type">int r){<span class="hljs-comment">//查询方法
    <span class="hljs-keyword">if(l &lt;= nodes[u].l &amp;&amp; nodes[u].r &lt;= r)<span class="hljs-keyword">return nodes[u].maxx;
    <span class="hljs-type">int mid = nodes[u].l + nodes[u].r &gt;&gt; <span class="hljs-number">1;
    <span class="hljs-type">int maxx = INT_MIN;
    <span class="hljs-keyword">if(mid &gt;= l)maxx = <span class="hljs-built_in">max(maxx,<span class="hljs-built_in">query(u &lt;&lt; <span class="hljs-number">1,l,r));
    <span class="hljs-keyword">if(mid &lt; r)maxx = <span class="hljs-built_in">max(maxx,<span class="hljs-built_in">query(u &lt;&lt; <span class="hljs-number">1 | <span class="hljs-number">1,l,r));
    <span class="hljs-keyword">return maxx;
}

<span class="hljs-function"><span class="hljs-type">int <span class="hljs-title">main<span class="hljs-params">()
{
    cin &gt;&gt; n &gt;&gt; m;
    <span class="hljs-keyword">for (<span class="hljs-type">int i = <span class="hljs-number">1; i &lt;= n; i ++ )<span class="hljs-built_in">scanf(<span class="hljs-string">"%d",a+i);
    
    <span class="hljs-built_in">build(<span class="hljs-number">1,<span class="hljs-number">1,n);
    
    <span class="hljs-type">int x,y;
    <span class="hljs-keyword">for(<span class="hljs-type">int i = <span class="hljs-number">0;i &lt; m; i++){
        <span class="hljs-built_in">scanf(<span class="hljs-string">"%d%d", &amp;x, &amp;y);
        <span class="hljs-built_in">printf(<span class="hljs-string">"%d\n",<span class="hljs-built_in">query(<span class="hljs-number">1,x,y));
    }
}</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="https://img2023.cnblogs.com/blog/2740326/202301/2740326-20230123101534044-530598597.gif" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /></span></div>
<p>稍微难理解的一道题：<span class="cke_widget_wrapper cke_widget_inline cke_widget_csdnlink cke_widget_selected" data-cke-display-name="a" data-cke-filter="off" data-cke-widget-id="20" data-cke-widget-wrapper="1"><a class="cke_widget_editable cke_widget_element" title="1265. 数星星 - AcWing题库" href="https://www.acwing.com/problem/content/1267/" data-cke-enter-mode="2" data-cke-saved-href="https://www.acwing.com/problem/content/1267/" data-cke-widget-data="%7B%22url%22%3A%22https%3A%2F%2Fwww.acwing.com%2Fproblem%2Fcontent%2F1267%2F%22%2C%22text%22%3A%221265.%20%E6%95%B0%E6%98%9F%E6%98%9F%20-%20AcWing%E9%A2%98%E5%BA%93%22%2C%22desc%22%3A%22%22%2C%22icon%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.0.8%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DM276%22%2C%22isCard%22%3Afalse%2C%22hasResquest%22%3Atrue%2C%22iconDefault%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.2.1%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DMBR7%22%2C%22id%22%3A%22NrE5Lg-1674439874380%22%2C%22classes%22%3Anull%7D" data-cke-widget-editable="text" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.0.8/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=M276" data-link-title="1265. 数星星 - AcWing题库" data-widget="csdnlink">1265. 数星星 - AcWing题库</a></span></p>
<blockquote>
<h2 id="%E6%95%B0%E6%98%9F%E6%98%9F">数星星</h2>
<p>天空中有一些星星，这些星星都在不同的位置，每个星星有个坐标。</p>
<p>如果一个星星的左下方（包含正左和正下）有&nbsp;k&nbsp;颗星星，就说这颗星星是&nbsp;k&nbsp;级的。</p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_image cke_image_nocaption cke_widget_selected" data-cke-display-name="图像" data-cke-filter="off" data-cke-widget-id="19" data-cke-widget-wrapper="1">
<p class="img-center cke_widget_element" data-cke-widget-data="%7B%22hasCaption%22%3Afalse%2C%22src%22%3A%22https%3A%2F%2Fimg-blog.csdnimg.cn%2Fimg_convert%2F9268652f9a8e0b3bb586e189e817b3f8.png%22%2C%22alt%22%3A%22%22%2C%22width%22%3A%22%22%2C%22height%22%3A%22%22%2C%22lock%22%3Atrue%2C%22align%22%3A%22center%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="image"><span class="cke_image_resizer_wrapper"><img src="https://img-blog.csdnimg.cn/img_convert/9268652f9a8e0b3bb586e189e817b3f8.png" alt="" data-cke-saved-src="https://img-blog.csdnimg.cn/img_convert/9268652f9a8e0b3bb586e189e817b3f8.png" /><span class="cke_image_resizer" title="点击并拖拽以改变尺寸">​</span></span></p>
<span class="cke_reset cke_widget_drag_handler_container"><img src="https://img2023.cnblogs.com/blog/2740326/202301/2740326-20230123101534044-530598597.gif" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /><span class="cke_widget_edit_container" title="编辑图片">编辑</span></span></div>
<p>例如，上图中星星&nbsp;5&nbsp;是&nbsp;3&nbsp;级的（1,2,4 在它左下），星星&nbsp;2,4是&nbsp;1&nbsp;级的。</p>
<p>例图中有&nbsp;1&nbsp;个&nbsp;0&nbsp;级，2 个&nbsp;1&nbsp;级，1&nbsp;个&nbsp;2&nbsp;级，1&nbsp;个&nbsp;3&nbsp;级的星星。</p>
<p>给定星星的位置，输出各级星星的数目。</p>
<p>换句话说，给定&nbsp;N&nbsp;个点，定义每个点的等级是在该点左下方（含正左、正下）的点的数目，试统计每个等级有多少个点。</p>
<p>输入格式</p>
<p>第一行一个整数&nbsp;N，表示星星的数目；</p>
<p>接下来&nbsp;N&nbsp;行给出每颗星星的坐标，坐标用两个整数 x,y&nbsp;表示；</p>
<p>不会有星星重叠。<strong>星星按&nbsp;y&nbsp;坐标增序给出，y&nbsp;坐标相同的按&nbsp;x&nbsp;坐标增序给出。</strong></p>
<p>输出格式</p>
<p>N&nbsp;行，每行一个整数，分别是&nbsp;0&nbsp;级，1&nbsp;级，2&nbsp;级，&hellip;&hellip;，N&minus;1&nbsp;级的星星的数目。</p>
<p>数据范围</p>
<p>1&le;N&le;15000,<br />
0&le;x,y&le;32000</p>
<p>输入样例：</p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-display-name="代码段" data-cke-filter="off" data-cke-widget-id="18" data-cke-widget-wrapper="1">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22code%22%3A%225%5Cn1%201%5Cn5%201%5Cn7%201%5Cn3%203%5Cn5%205%5Cn%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="codeSnippet"><code class="hljs">5
1 1
5 1
7 1
3 3
5 5
</code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="https://img2023.cnblogs.com/blog/2740326/202301/2740326-20230123101534044-530598597.gif" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /></span></div>
<p>输出样例：</p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-display-name="代码段" data-cke-filter="off" data-cke-widget-id="17" data-cke-widget-wrapper="1">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22code%22%3A%221%5Cn2%5Cn1%5Cn1%5Cn0%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="codeSnippet"><code class="hljs">1
2
1
1
0</code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="https://img2023.cnblogs.com/blog/2740326/202301/2740326-20230123101534044-530598597.gif" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /></span></div>
</blockquote>
<p><strong>&nbsp;分析</strong>：</p>
<ol>
<li>从题目里可得，<strong>星星按&nbsp;y&nbsp;坐标增序给出，y&nbsp;坐标相同的按&nbsp;x&nbsp;坐标增序给出，</strong>那么每个星星左下角有多少个星星就与后续输入坐标无关了</li>
<li>星星坐标从 0 开始，可以调整一下，自加 1 ，然后建立一个<strong>树状数组</strong></li>
<li>设输入星星横坐标 x ，他的左下角星星数量在树状数组里只等于1~x内有多少个星星，等价于<strong>区间查询</strong>操作</li>
<li>对星星的 x 位置<strong>元素修改</strong>，+1</li>
</ol>
<p><span class="cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected" data-cke-display-name="图像" data-cke-filter="off" data-cke-widget-id="16" data-cke-widget-wrapper="1"><img src="https://img-blog.csdnimg.cn/2667f7db670c47e58c98f5b72963b578.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5L-E572X5pav5Yi65rKZ6JOs,size_20,color_FFFFFF,t_70,g_se,x_16" alt="" class="cke_widget_element" data-cke-saved-src="https://img-blog.csdnimg.cn/2667f7db670c47e58c98f5b72963b578.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5L-E572X5pav5Yi65rKZ6JOs,size_20,color_FFFFFF,t_70,g_se,x_16" data-cke-widget-data="%7B%22hasCaption%22%3Afalse%2C%22src%22%3A%22https%3A%2F%2Fimg-blog.csdnimg.cn%2F2667f7db670c47e58c98f5b72963b578.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_d3F5LXplbmhlaQ%2Cshadow_50%2Ctext_Q1NETiBA5L-E572X5pav5Yi65rKZ6JOs%2Csize_20%2Ccolor_FFFFFF%2Ct_70%2Cg_se%2Cx_16%22%2C%22alt%22%3A%22%22%2C%22width%22%3A%22%22%2C%22height%22%3A%22%22%2C%22lock%22%3Atrue%2C%22align%22%3A%22none%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="image" /><span class="cke_reset cke_widget_drag_handler_container"><img src="https://img2023.cnblogs.com/blog/2740326/202301/2740326-20230123101534044-530598597.gif" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /><span class="cke_image_resizer" title="点击并拖拽以改变尺寸">​<span class="cke_widget_edit_container" title="编辑图片">编辑</span></span></span></span></p>
<p>&nbsp;</p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-display-name="代码段" data-cke-filter="off" data-cke-widget-id="15" data-cke-widget-wrapper="1">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22lang%22%3A%22cpp%22%2C%22code%22%3A%22%5Cn%23include%20%3Ciostream%3E%5Cn%23include%20%3Ccstring%3E%5Cn%23include%20%3Calgorithm%3E%5Cnusing%20namespace%20std%3B%5Cnconst%20int%20N%20%3D%201e5%2B10%3B%5Cnint%20a%5BN%5D%2Ccnt%5BN%5D%3B%5Cnint%20n%2Cm%3B%5Cn%5Cnint%20lowbit(int%20x)%5Cn%7B%5Cn%20%20%20%20return%20x%20%26%20(-x)%3B%5Cn%7D%5Cn%5Cnvoid%20add(int%20x%2Cint%20w)%7B%5Cn%20%20%20%20for(int%20i%20%3D%20x%3Bi%20%3C%20N%3Bi%20%2B%3D%20lowbit(i))%7B%2F%2F%E8%BF%99%E9%87%8C%E8%AF%BB%E9%A2%98%E8%A6%81%E6%B3%A8%E6%84%8F%EF%BC%9A%E5%9D%90%E6%A0%87%E5%B9%B6%E6%B2%A1%E6%9C%89%E5%9C%A8n%E4%BB%A5%E5%86%85%EF%BC%8C%E8%80%8C%E6%98%AF%E5%9C%A8%E6%95%B4%E4%B8%AA%E7%9A%84%E6%9C%80%E5%A4%A7%E8%8C%83%E5%9B%B4%E5%86%85%5Cn%20%20%20%20%20%20%20%20a%5Bi%5D%20%2B%3D%20w%3B%5Cn%20%20%20%20%7D%5Cn%7D%5Cn%5Cnint%20query(int%20u)%7B%5Cn%20%20%20%20int%20res%20%3D%200%3B%5Cn%20%20%20%20for(int%20i%20%3D%20u%3Bi%20%3E%200%3Bi%20-%3D%20lowbit(i))%7B%5Cn%20%20%20%20%20%20%20%20res%20%2B%3D%20a%5Bi%5D%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20return%20res%3B%5Cn%7D%5Cn%5Cnint%20main()%5Cn%7B%5Cn%20%20%20%20cin%20%3E%3E%20n%3B%5Cn%20%20%20%20for(int%20i%20%3D%201%3Bi%20%3C%3D%20n%3Bi%20%2B%2B)%7B%20%20%20%20%20%20%20%20%20%2F%2F%E8%A6%81%E5%AE%9E%E6%97%B6%E8%AE%A1%E7%AE%97%E6%98%9F%E6%98%9F%E7%9A%84%E7%AD%89%E7%BA%A7%EF%BC%8C%E5%9B%A0%E4%B8%BA%E4%B8%80%E6%97%A6y%E6%98%AF%E9%80%92%E5%A2%9E%E6%8E%92%E5%BA%8F%E7%9A%84%EF%BC%8C%E6%89%80%E4%BB%A5%E5%90%8E%E6%9D%A5%E7%9A%84x%E4%B8%8D%E4%BC%9A%E5%AF%B9%E4%B9%8B%E5%89%8D%E4%BA%A7%E7%94%9F%E5%BD%B1%E5%93%8D%5Cn%20%20%20%20%20%20%20%20int%20a%2Cb%3Bcin%20%3E%3E%20a%20%3E%3E%20b%3B%5Cn%20%20%20%20%20%20%20%20add(a%2B1%2C1)%3B%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%E8%B7%B3%E8%BF%870%EF%BC%8C%E5%9B%A0%E4%B8%BA%E8%BF%99%E4%B8%AA%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E4%BB%A50%E4%B8%BA%E7%BB%93%E6%9D%9F%E7%BB%88%E7%82%B9%5Cn%20%20%20%20%20%20%20%20cnt%5Bquery(a%2B1)%5D%2B%2B%3B%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%E5%89%8D%E9%9D%A2%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%AA%E6%98%9F%E6%98%9F%EF%BC%8C%E5%B0%B1%E6%98%AF%E5%A4%9A%E5%B0%91%E7%BA%A7%5Cn%20%20%20%20%7D%5Cn%20%20%20%20%5Cn%20%20%20%20for%20(int%20i%20%3D%201%3B%20i%20%3C%3D%20n%3B%20i%20%2B%2B%20)%7B%20%20%20%20%20%2F%2F%E6%B2%A1%E6%9C%890%5Cn%20%20%20%20%20%20%20%20cout%20%3C%3C%20cnt%5Bi%5D%20%3C%3C%20endl%3B%20%20%20%20%20%20%20%20%20%2F%2F%E8%BE%93%E5%87%BA%E5%90%84%E5%90%84%E7%AD%89%E7%BA%A7%E7%9A%84%E6%95%B0%E9%87%8F%5Cn%20%20%20%20%7D%5Cn%20%20%20%20return%200%3B%5Cn%7D%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="codeSnippet"><code class="language-cpp hljs">
<span class="hljs-meta">#<span class="hljs-keyword">include <span class="hljs-string">&lt;iostream&gt;
<span class="hljs-meta">#<span class="hljs-keyword">include <span class="hljs-string">&lt;cstring&gt;
<span class="hljs-meta">#<span class="hljs-keyword">include <span class="hljs-string">&lt;algorithm&gt;
<span class="hljs-keyword">using <span class="hljs-keyword">namespace std;
<span class="hljs-type">const <span class="hljs-type">int N = <span class="hljs-number">1e5+<span class="hljs-number">10;
<span class="hljs-type">int a[N],cnt[N];
<span class="hljs-type">int n,m;

<span class="hljs-function"><span class="hljs-type">int <span class="hljs-title">lowbit<span class="hljs-params">(<span class="hljs-type">int x)
{
    <span class="hljs-keyword">return x &amp; (-x);
}

<span class="hljs-function"><span class="hljs-type">void <span class="hljs-title">add<span class="hljs-params">(<span class="hljs-type">int x,<span class="hljs-type">int w){
    <span class="hljs-keyword">for(<span class="hljs-type">int i = x;i &lt; N;i += <span class="hljs-built_in">lowbit(i)){<span class="hljs-comment">//这里读题要注意：坐标并没有在n以内，而是在整个的最大范围内
        a[i] += w;
    }
}

<span class="hljs-function"><span class="hljs-type">int <span class="hljs-title">query<span class="hljs-params">(<span class="hljs-type">int u){
    <span class="hljs-type">int res = <span class="hljs-number">0;
    <span class="hljs-keyword">for(<span class="hljs-type">int i = u;i &gt; <span class="hljs-number">0;i -= <span class="hljs-built_in">lowbit(i)){
        res += a[i];
    }
    <span class="hljs-keyword">return res;
}

<span class="hljs-function"><span class="hljs-type">int <span class="hljs-title">main<span class="hljs-params">()
{
    cin &gt;&gt; n;
    <span class="hljs-keyword">for(<span class="hljs-type">int i = <span class="hljs-number">1;i &lt;= n;i ++){         <span class="hljs-comment">//要实时计算星星的等级，因为一旦y是递增排序的，所以后来的x不会对之前产生影响
        <span class="hljs-type">int a,b;cin &gt;&gt; a &gt;&gt; b;
        <span class="hljs-built_in">add(a+<span class="hljs-number">1,<span class="hljs-number">1);                     <span class="hljs-comment">//跳过0，因为这个树状数组以0为结束终点
        cnt[<span class="hljs-built_in">query(a+<span class="hljs-number">1)]++;              <span class="hljs-comment">//前面有多少个星星，就是多少级
    }
    
    <span class="hljs-keyword">for (<span class="hljs-type">int i = <span class="hljs-number">1; i &lt;= n; i ++ ){     <span class="hljs-comment">//没有0
        cout &lt;&lt; cnt[i] &lt;&lt; endl;         <span class="hljs-comment">//输出各各等级的数量
    }
    <span class="hljs-keyword">return <span class="hljs-number">0;
}</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="https://img2023.cnblogs.com/blog/2740326/202301/2740326-20230123101534044-530598597.gif" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /></span></div>
<p>&nbsp;</p>
<p>第五届蓝桥杯省赛C++B/C组&nbsp;<span class="cke_widget_wrapper cke_widget_inline cke_widget_csdnlink cke_widget_selected" data-cke-display-name="a" data-cke-filter="off" data-cke-widget-id="14" data-cke-widget-wrapper="1"><a class="cke_widget_editable cke_widget_element" title="1215. 小朋友排队 - AcWing题库" href="https://www.acwing.com/problem/content/description/1217/" data-cke-enter-mode="2" data-cke-saved-href="https://www.acwing.com/problem/content/description/1217/" data-cke-widget-data="%7B%22url%22%3A%22https%3A%2F%2Fwww.acwing.com%2Fproblem%2Fcontent%2Fdescription%2F1217%2F%22%2C%22text%22%3A%221215.%20%E5%B0%8F%E6%9C%8B%E5%8F%8B%E6%8E%92%E9%98%9F%20-%20AcWing%E9%A2%98%E5%BA%93%22%2C%22desc%22%3A%22%22%2C%22icon%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.0.8%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DM276%22%2C%22isCard%22%3Afalse%2C%22hasResquest%22%3Atrue%2C%22iconDefault%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.2.1%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DMBR7%22%2C%22id%22%3A%22DQCfNF-1674439874376%22%2C%22classes%22%3Anull%7D" data-cke-widget-editable="text" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.0.8/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=M276" data-link-title="1215. 小朋友排队 - AcWing题库" data-widget="csdnlink">1215. 小朋友排队 - AcWing题库</a></span></p>
<blockquote>
<h2 id="%E5%B0%8F%E6%9C%8B%E5%8F%8B%E6%8E%92%E9%98%9F">小朋友排队</h2>
<p>n&nbsp;个小朋友站成一排。</p>
<p>现在要把他们按身高从低到高的顺序排列，但是每次只能交换位置相邻的两个小朋友。</p>
<p>每个小朋友都有一个不高兴的程度。</p>
<p>开始的时候，所有小朋友的不高兴程度都是&nbsp;0。</p>
<p>如果某个小朋友第一次被要求交换，则他的不高兴程度增加&nbsp;1，如果第二次要求他交换，则他的不高兴程度增加&nbsp;2（即不高兴程度为&nbsp;3），依次类推。当要求某个小朋友第&nbsp;kk&nbsp;次交换时，他的不高兴程度增加&nbsp;k。</p>
<p>请问，要让所有小朋友按从低到高排队，他们的不高兴程度之和最小是多少。</p>
<p>如果有两个小朋友身高一样，则他们谁站在谁前面是没有关系的。</p>
<p><strong>输入格式</strong></p>
<p>输入的第一行包含一个整数&nbsp;n，表示小朋友的个数。</p>
<p>第二行包含&nbsp;n&nbsp;个整数&nbsp;H1,H2,&hellip;,Hn，分别表示每个小朋友的身高。</p>
<p><strong>输出格式</strong></p>
<p>输出一行，包含一个整数，表示小朋友的不高兴程度和的最小值。</p>
<p><strong>数据范围</strong></p>
<p>1&le;n&le;100000,<br />
0&le;Hi&le;1000000</p>
<p><strong>输入样例：</strong></p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-display-name="代码段" data-cke-filter="off" data-cke-widget-id="13" data-cke-widget-wrapper="1">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22code%22%3A%223%5Cn3%202%201%5Cn%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="codeSnippet"><code class="hljs">3
3 2 1
</code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="https://img2023.cnblogs.com/blog/2740326/202301/2740326-20230123101534044-530598597.gif" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /></span></div>
<p><strong>输出样例：</strong></p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-display-name="代码段" data-cke-filter="off" data-cke-widget-id="12" data-cke-widget-wrapper="1">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22code%22%3A%229%5Cn%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="codeSnippet"><code class="hljs">9
</code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="https://img2023.cnblogs.com/blog/2740326/202301/2740326-20230123101534044-530598597.gif" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /></span></div>
<p><strong>样例解释</strong></p>
<p>首先交换身高为3和2的小朋友，再交换身高为3和1的小朋友，再交换身高为2和1的小朋友，每个小朋友的不高兴程度都是3，总和为9。</p>
</blockquote>
<h2 id="%C2%A0%E5%88%86%E6%9E%90%EF%BC%9A">&nbsp;分析：</h2>
<ol>
<li>问题简化：一个有 n 个元素的数组H，以冒泡排序的方式排成升序，每个元素交换（大小相同不交换）的次数cnt[ i ]，最后累加<strong>cnt[ i ] * cnt [ i ] / 2</strong></li>
<li>每个元素要交换的的次数，就是在数组中关于当前元素的<strong>逆序对数量</strong><br />
	<strong>交换次数cnt[ i ] = H[ 0 , i - 1 ]中大于H[ i ]的数量 + H[ i+1 , n ]中小于H[ i ]的数量</strong><br />
	&nbsp;</li>
<li>为什么是逆序对呢？可以从反面来想。（递推）<br />
	假设 H数组&nbsp;已经升序，那么任意移动一个元素，计算出来的逆序对数量是符合上述定义的；<br />
	如果再移动另一个，也可以推理得出逆序对数量是符合的<br />
	如此反复的操作可以得出，逆序对数量的计算是正确的<br />
	&nbsp;</li>
<li>经过上述的分析，我们可以得到暴力做法（显然会超时）
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-display-name="代码段" data-cke-filter="off" data-cke-widget-id="11" data-cke-widget-wrapper="1">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22lang%22%3A%22cpp%22%2C%22code%22%3A%22for(int%20i%3D1%3Bi%3C%3Dn%3Bi%2B%2B)%7B%5Cn%20%20%20%20long%20long%20res%3D0%3B%5Cn%20%20%20%20for(int%20j%3D1%3Bj%3Ci%3Bj%2B%2B)%5Cn%20%20%20%20%20%20%20%20if(a%5Bj%5D%3Ea%5Bi%5D)%20res%2B%2B%3B%2F%2F%20i%20%E5%89%8D%E9%9D%A2%E6%AF%94%20a%5Bi%5D%E9%AB%98%E7%9A%84%E6%95%B0%E9%87%8F%5Cn%5Cn%20%20%20%20for(int%20j%3Di%2B1%3Bj%3C%3Dn%3Bj%2B%2B)%5Cn%20%20%20%20%20%20%20%20if(a%5Bj%5D%3Ca%5Bi%5D)%20res%2B%2B%3B%2F%2F%20i%20%E5%90%8E%E9%9D%A2%E6%AF%94%20a%5Bi%5D%E4%BD%8E%E7%9A%84%E6%95%B0%E9%87%8F%5Cn%5Cn%20%20%20%20res%3Dres*res%2F2%3B%20%20%20%20%20%20%20%20%20%20%2F%2F%E4%B8%8D%E9%AB%98%E5%85%B4%E5%80%BC%5Cn%20%20%20%20num%5Bi%5D%3Dres%3B%5Cn%7D%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%E8%AE%A1%E7%AE%97%E6%80%BB%E5%92%8C%5Cnfor(int%20i%3D1%3Bi%3C%3Dn%3Bi%2B%2B)%20ans%2B%3Dnum%5Bi%5D%3B%5Cn%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="codeSnippet"><code class="language-cpp hljs"><span class="hljs-keyword">for(<span class="hljs-type">int i=<span class="hljs-number">1;i&lt;=n;i++){
    <span class="hljs-type">long <span class="hljs-type">long res=<span class="hljs-number">0;
    <span class="hljs-keyword">for(<span class="hljs-type">int j=<span class="hljs-number">1;j&lt;i;j++)
        <span class="hljs-keyword">if(a[j]&gt;a[i]) res++;<span class="hljs-comment">// i 前面比 a[i]高的数量

    <span class="hljs-keyword">for(<span class="hljs-type">int j=i+<span class="hljs-number">1;j&lt;=n;j++)
        <span class="hljs-keyword">if(a[j]&lt;a[i]) res++;<span class="hljs-comment">// i 后面比 a[i]低的数量

    res=res*res/<span class="hljs-number">2;          <span class="hljs-comment">//不高兴值
    num[i]=res;
}                           <span class="hljs-comment">//计算总和
<span class="hljs-keyword">for(<span class="hljs-type">int i=<span class="hljs-number">1;i&lt;=n;i++) ans+=num[i];
</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="https://img2023.cnblogs.com/blog/2740326/202301/2740326-20230123101534044-530598597.gif" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以��动" data-cke-widget-drag-handler="1" /></span></div>
</li>
</ol>
<h2 id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%88%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%EF%BC%89%EF%BC%9A%C2%A0">代码实现（树状数组）：&nbsp;</h2>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-display-name="代码段" data-cke-filter="off" data-cke-widget-id="10" data-cke-widget-wrapper="1">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22lang%22%3A%22cpp%22%2C%22code%22%3A%22%2F%2F%E6%AF%8F%E4%B8%AA%E5%B0%8F%E5%AD%A9%E7%9A%84%E7%A7%BB%E5%8A%A8%E6%AC%A1%E6%95%B0%3D%E5%89%8D%E9%9D%A2%E6%AF%94%E5%AE%83%E9%AB%98%E7%9A%84%E4%BA%BA%E6%95%B0%2B%E5%90%8E%E9%9D%A2%E6%AF%94%E4%BB%96%E4%BD%8E%E7%9A%84%E4%BA%BA%E6%95%B0%5Cn%2F%2F%E4%B8%8D%E9%AB%98%E5%85%B4%E5%80%BC%E5%B0%B1%E6%98%AF%E7%B4%AF%E5%8A%A01%E5%88%B0%E7%A7%BB%E5%8A%A8%E6%AC%A1%E6%95%B0%3D%EF%BC%88%E7%A7%BB%E5%8A%A8%E6%AC%A1%E6%95%B0%EF%BC%89*%EF%BC%88%E7%A7%BB%E5%8A%A8%E6%AC%A1%E6%95%B0%2B1%EF%BC%89%2F2%5Cn%5Cn%23include%20%3Ciostream%3E%5Cn%23include%20%3Ccstring%3E%5Cn%23include%20%3Calgorithm%3E%5Cn%5Cnusing%20namespace%20std%3B%5Cn%5Cnconst%20int%20N%20%3D%201e5%20%2B%2010%2CM%20%3D%201e6%20%2B%2010%3B%5Cn%5Cntypedef%20long%20long%20LL%3B%5Cn%5Cnint%20n%3B%5Cnint%20a%5BN%5D%2Ch%5BN%5D%3B%5Cnint%20cnt%5BM%5D%3B%5Cn%5Cnint%20lowbit(int%20x)%20%20%2F%2F%20%E8%BF%94%E5%9B%9E%E6%9C%AB%E5%B0%BE%E7%9A%841%5Cn%7B%5Cn%20%20%20%20return%20x%20%26%20-x%3B%5Cn%7D%5Cn%5Cnvoid%20add(int%20u)%7B%5Cn%20%20%20%20for(int%20i%20%3D%20u%20%3Bi%20%3C%20M%3Bi%20%2B%3D%20lowbit(i))%7B%5Cn%20%20%20%20%20%20%20%20cnt%5Bi%5D%20%2B%3D%201%3B%5Cn%20%20%20%20%7D%5Cn%7D%5Cn%5Cnint%20query(int%20u)%7B%5Cn%20%20%20%20int%20ans%20%3D%200%3B%5Cn%20%20%20%20for(int%20i%20%3D%20u%3B%20i%20%3E%200%3Bi%20-%3D%20lowbit(i))%7B%5Cn%20%20%20%20%20%20%20%20ans%20%2B%3D%20cnt%5Bi%5D%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20return%20ans%3B%5Cn%7D%5Cn%5Cnint%20main()%20%7B%5Cn%20%20%20%20scanf(%5C%22%25d%5C%22%2C%20%26n)%3B%5Cn%20%20%20%20for%20(int%20i%20%3D%201%3B%20i%20%3C%3D%20n%3B%20i%20%2B%2B%20)scanf(%5C%22%25d%5C%22%2Ca%2Bi)%2Ca%5Bi%5D%2B%2B%3B%5Cn%20%20%20%20%5Cn%20%20%20%20for(int%20i%20%3D%201%3Bi%20%3C%3D%20n%3Bi%20%2B%2B)%7B%20%20%20%20%20%20%20%20%20%20%2F%2F%E6%B3%A8%E6%84%8F%E9%A1%BA%E5%BA%8F%5Cn%20%20%20%20%20%20%20%20h%5Bi%5D%20%2B%3D%20query(M-1)%20-%20query(a%5Bi%5D)%3B%2F%2F%E6%89%BE%E5%89%8D%E9%9D%A2%E6%94%BE%E8%BF%9B%E6%9D%A5%E7%9A%84%EF%BC%8C%E6%AF%94%E4%BB%96%E9%AB%98%E7%9A%84%E4%BA%BA%E6%95%B0%5Cn%20%20%20%20%20%20%20%20%2F%2Fcout%20%3C%3C%20h%5Bi%5D%20%3C%3C%20endl%3B%5Cn%20%20%20%20%20%20%20%20add(a%5Bi%5D)%3B%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%E6%94%BE%E5%85%A5%5Cn%20%20%20%20%7D%5Cn%20%20%20%20memset(cnt%2C0%2Csizeof%20cnt)%3B%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%E6%B8%85%E7%A9%BA%5Cn%20%20%20%20for(int%20i%20%3D%20n%3Bi%20%3E%3D%201%3Bi%20--)%7B%5Cn%20%20%20%20%20%20%20%20h%5Bi%5D%20%2B%3D%20query(a%5Bi%5D-1)%3B%20%20%20%20%20%20%20%20%20%20%20%2F%2F%E6%89%BE%E5%90%8E%E9%9D%A2%E6%94%BE%E8%BF%9B%E6%9D%A5%E7%9A%84%EF%BC%8C%E6%AF%94%E4%BB%96%E7%9F%AE%E7%9A%84%E4%BA%BA%E6%95%B0%5Cn%20%20%20%20%20%20%20%20%5Cn%20%20%20%20%20%20%20%20add(a%5Bi%5D)%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20%5Cn%20%20%20%20LL%20ans%20%3D%200%3B%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%E8%8C%83%E5%9B%B4%E6%9C%80%E5%A4%A7n*n%5Cn%20%20%20%20for%20(int%20i%20%3D%201%3B%20i%20%3C%3D%20n%3B%20i%20%2B%2B%20)ans%20%2B%3D%20(LL)(h%5Bi%5D%20%2B%201)%20*%20h%5Bi%5D%2F2%3B%5Cn%20%20%20%20cout%20%3C%3C%20ans%20%3C%3C%20endl%3B%5Cn%20%20%20%20return%200%3B%5Cn%7D%5Cn%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="codeSnippet"><code class="language-cpp hljs"><span class="hljs-comment">//每个小孩的移动次数=前面比它高的人数+后面比他低的人数
<span class="hljs-comment">//不高兴值就是累加1到移动次数=（移动次数）*（移动次数+1）/2

<span class="hljs-meta">#<span class="hljs-keyword">include <span class="hljs-string">&lt;iostream&gt;
<span class="hljs-meta">#<span class="hljs-keyword">include <span class="hljs-string">&lt;cstring&gt;
<span class="hljs-meta">#<span class="hljs-keyword">include <span class="hljs-string">&lt;algorithm&gt;

<span class="hljs-keyword">using <span class="hljs-keyword">namespace std;

<span class="hljs-type">const <span class="hljs-type">int N = <span class="hljs-number">1e5 + <span class="hljs-number">10,M = <span class="hljs-number">1e6 + <span class="hljs-number">10;

<span class="hljs-keyword">typedef <span class="hljs-type">long <span class="hljs-type">long LL;

<span class="hljs-type">int n;
<span class="hljs-type">int a[N],h[N];
<span class="hljs-type">int cnt[M];

<span class="hljs-function"><span class="hljs-type">int <span class="hljs-title">lowbit<span class="hljs-params">(<span class="hljs-type">int x)  <span class="hljs-comment">// 返回末尾的1
{
    <span class="hljs-keyword">return x &amp; -x;
}

<span class="hljs-function"><span class="hljs-type">void <span class="hljs-title">add<span class="hljs-params">(<span class="hljs-type">int u){
    <span class="hljs-keyword">for(<span class="hljs-type">int i = u ;i &lt; M;i += <span class="hljs-built_in">lowbit(i)){
        cnt[i] += <span class="hljs-number">1;
    }
}

<span class="hljs-function"><span class="hljs-type">int <span class="hljs-title">query<span class="hljs-params">(<span class="hljs-type">int u){
    <span class="hljs-type">int ans = <span class="hljs-number">0;
    <span class="hljs-keyword">for(<span class="hljs-type">int i = u; i &gt; <span class="hljs-number">0;i -= <span class="hljs-built_in">lowbit(i)){
        ans += cnt[i];
    }
    <span class="hljs-keyword">return ans;
}

<span class="hljs-function"><span class="hljs-type">int <span class="hljs-title">main<span class="hljs-params">() {
    <span class="hljs-built_in">scanf(<span class="hljs-string">"%d", &amp;n);
    <span class="hljs-keyword">for (<span class="hljs-type">int i = <span class="hljs-number">1; i &lt;= n; i ++ )<span class="hljs-built_in">scanf(<span class="hljs-string">"%d",a+i),a[i]++;
    
    <span class="hljs-keyword">for(<span class="hljs-type">int i = <span class="hljs-number">1;i &lt;= n;i ++){          <span class="hljs-comment">//注意顺序
        h[i] += <span class="hljs-built_in">query(M<span class="hljs-number">-1) - <span class="hljs-built_in">query(a[i]);<span class="hljs-comment">//找前面放进来的，比他高的人数
        <span class="hljs-comment">//cout &lt;&lt; h[i] &lt;&lt; endl;
        <span class="hljs-built_in">add(a[i]);                       <span class="hljs-comment">//放入
    }
    <span class="hljs-built_in">memset(cnt,<span class="hljs-number">0,<span class="hljs-keyword">sizeof cnt);            <span class="hljs-comment">//清空
    <span class="hljs-keyword">for(<span class="hljs-type">int i = n;i &gt;= <span class="hljs-number">1;i --){
        h[i] += <span class="hljs-built_in">query(a[i]<span class="hljs-number">-1);           <span class="hljs-comment">//找后面放进来的，比他矮的人数
        
        <span class="hljs-built_in">add(a[i]);
    }
    
    LL ans = <span class="hljs-number">0;                          <span class="hljs-comment">//范围最大n*n
    <span class="hljs-keyword">for (<span class="hljs-type">int i = <span class="hljs-number">1; i &lt;= n; i ++ )ans += (LL)(h[i] + <span class="hljs-number">1) * h[i]/<span class="hljs-number">2;
    cout &lt;&lt; ans &lt;&lt; endl;
    <span class="hljs-keyword">return <span class="hljs-number">0;
}
</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="https://img2023.cnblogs.com/blog/2740326/202301/2740326-20230123101534044-530598597.gif" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /></span></div>
<p>前面的问题都是围绕着<strong>区间查询</strong>和<strong>元素修改</strong>进行的，用<strong>树状数组</strong>和<strong>线段树</strong>两种方法来解决</p>
<p><strong>元素查询</strong>可以通过查询区间长度为1的情况完成</p>
<p>那么对于<strong>区间修改</strong>该怎么做呢？</p>
<p>&nbsp;</p>
<p><span class="cke_widget_wrapper cke_widget_inline cke_widget_csdnlink cke_widget_selected" data-cke-display-name="a" data-cke-filter="off" data-cke-widget-id="9" data-cke-widget-wrapper="1"><a class="cke_widget_editable cke_widget_element" title="243. 一个简单的整数问题2 - AcWing题库" href="https://www.acwing.com/problem/content/244/" data-cke-enter-mode="2" data-cke-saved-href="https://www.acwing.com/problem/content/244/" data-cke-widget-data="%7B%22url%22%3A%22https%3A%2F%2Fwww.acwing.com%2Fproblem%2Fcontent%2F244%2F%22%2C%22text%22%3A%22243.%20%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B4%E6%95%B0%E9%97%AE%E9%A2%982%20-%20AcWing%E9%A2%98%E5%BA%93%22%2C%22desc%22%3A%22%22%2C%22icon%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.0.8%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DM276%22%2C%22isCard%22%3Afalse%2C%22hasResquest%22%3Atrue%2C%22iconDefault%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.2.1%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DMBR7%22%2C%22id%22%3A%221L3DCi-1674439874370%22%2C%22classes%22%3Anull%7D" data-cke-widget-editable="text" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.0.8/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=M276" data-link-title="243. 一个简单的整数问题2 - AcWing题库" data-widget="csdnlink">243. 一个简单的整数问题2 - AcWing题库</a>下面个问题就是关于区间修改的</span></p>
<blockquote>
<h2 id="%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B4%E6%95%B0%E9%97%AE%E9%A2%982"><strong>一个简单的整数问题2</strong></h2>
<p>给定一个长度为&nbsp;N&nbsp;的数列&nbsp;A，以及&nbsp;M&nbsp;条指令，每条指令可能是以下两种之一：</p>
<ol>
<li><code>C l r d</code>，表示把&nbsp;A[l],A[l+1],&hellip;,A[r] 都加上&nbsp;dd。</li>
<li><code>Q l r</code>，表示询问数列中第&nbsp;l&sim;r 个数的和。</li>
</ol>
<p>对于每个询问，输出一个整数表示答案。</p>
<p><strong>输入格式</strong></p>
<p>第一行两个整数&nbsp;N,M。</p>
<p>第二行&nbsp;N&nbsp;个整数&nbsp;A[i]。</p>
<p>接下来&nbsp;M&nbsp;行表示&nbsp;M&nbsp;条指令，每条指令的格式如题目描述所示。</p>
<p><strong>输出格式</strong></p>
<p>对于每个询问，输出一个整数表示答案。</p>
<p>每个答案占一行。</p>
<p><strong>数据范围</strong></p>
<p>1&le;N,M&le;100000<br />
|d|&le;10000,<br />
|A[i]|&le;1e9</p>
<p><strong>输入样例：</strong></p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-display-name="代码段" data-cke-filter="off" data-cke-widget-id="8" data-cke-widget-wrapper="1">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22code%22%3A%2210%205%5Cn1%202%203%204%205%206%207%208%209%2010%5CnQ%204%204%5CnQ%201%2010%5CnQ%202%204%5CnC%203%206%203%5CnQ%202%204%5Cn%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="codeSnippet"><code class="hljs">10 5
1 2 3 4 5 6 7 8 9 10
Q 4 4
Q 1 10
Q 2 4
C 3 6 3
Q 2 4
</code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="https://img2023.cnblogs.com/blog/2740326/202301/2740326-20230123101534044-530598597.gif" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /></span></div>
<p><strong>输出样例：</strong></p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-display-name="代码段" data-cke-filter="off" data-cke-widget-id="7" data-cke-widget-wrapper="1">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22code%22%3A%224%5Cn55%5Cn9%5Cn15%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="codeSnippet"><code class="hljs">4
55
9
15</code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="https://img2023.cnblogs.com/blog/2740326/202301/2740326-20230123101534044-530598597.gif" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /></span></div>
</blockquote>
<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; 分析：</strong></p>
<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; </strong>有了前面的经验后，从方便的角度可以想到，运用&nbsp;<strong>差分&nbsp;</strong>来实现数组的区间修改效率最高</p>
<p>建立一个<strong>差分数组 a[ i ] = b[ i ] - b[ i - 1 ]</strong></p>
<ol>
<li>先是初始化
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-display-name="代码段" data-cke-filter="off" data-cke-widget-id="6" data-cke-widget-wrapper="1">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22lang%22%3A%22cpp%22%2C%22code%22%3A%22for%20(LL%20i%20%3D%201%3B%20i%20%3C%3D%20n%3B%20i%20%2B%2B%20)%7B%5Cn%20%20%20%20cin%20%3E%3E%20b%5Bi%5D%3B%5Cn%20%20%20%20a%5Bi%5D%20%3D%20b%5Bi%5D-b%5Bi-1%5D%3B%5Cn%20%20%20%20add(i%2Ca%5Bi%5D)%3B%5Cn%7D%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="codeSnippet"><code class="language-cpp hljs">for (LL i = 1; i &lt;= n; i ++ ){
    cin &gt;&gt; b[i];
    a[i] = b[i]-b[i-1];
    add(i,a[i]);
}</code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="https://img2023.cnblogs.com/blog/2740326/202301/2740326-20230123101534044-530598597.gif" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /></span></div>
</li>
<li>
<p>关于<strong>区间修改</strong>的部分，按照差分的思想<br />
	<strong>&nbsp; &nbsp; &nbsp; &nbsp;区间查询</strong>照常</p>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-display-name="代码段" data-cke-filter="off" data-cke-widget-id="5" data-cke-widget-wrapper="1">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22lang%22%3A%22cpp%22%2C%22code%22%3A%22for(LL%20i%20%3D%201%3Bi%20%3C%3D%20m%3Bi%20%2B%2B)%7B%5Cn%20%20%20%20char%20x%3Bcin%20%3E%3E%20x%3B%5Cn%20%20%20%20if(x%20%3D%3D%20'Q')%7B%5Cn%20%20%20%20%20%20%20%20LL%20a%2Cb%3Bcin%20%3E%3E%20a%20%3E%3E%20b%3B%5Cn%20%20%20%20%20%20%20%20cout%20%3C%3C%20query(b)%20-%20query(a-1)%20%3C%3C%20endl%3B%5Cn%20%20%20%20%7Delse%7B%5Cn%20%20%20%20%20%20%20%20LL%20a%2Cb%2Cc%3Bcin%20%3E%3E%20a%20%3E%3E%20b%20%3E%3E%20c%3B%5Cn%20%20%20%20%20%20%20%20add(a%2C%20c)%3B%5Cn%20%20%20%20%20%20%20%20add(b%2B1%2C%20-c)%3B%5Cn%20%20%20%20%7D%5Cn%7D%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="codeSnippet"><code class="language-cpp hljs"><span class="hljs-keyword">for(LL i = <span class="hljs-number">1;i &lt;= m;i ++){
    <span class="hljs-type">char x;cin &gt;&gt; x;
    <span class="hljs-keyword">if(x == <span class="hljs-string">'Q'){
        LL a,b;cin &gt;&gt; a &gt;&gt; b;
        cout &lt;&lt; <span class="hljs-built_in">query(b) - <span class="hljs-built_in">query(a<span class="hljs-number">-1) &lt;&lt; endl;
    }<span class="hljs-keyword">else{
        LL a,b,c;cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        <span class="hljs-built_in">add(a, c);
        <span class="hljs-built_in">add(b+<span class="hljs-number">1, -c);
    }
}</span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="https://img2023.cnblogs.com/blog/2740326/202301/2740326-20230123101534044-530598597.gif" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /></span></div>
</li>
<li>所以对应着query的实现也要发生改变，此时a数组对应的是差分的树状数组<br />
	所以操作为：<strong>累加各个元素的差分和</strong>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-display-name="代码段" data-cke-filter="off" data-cke-widget-id="4" data-cke-widget-wrapper="1">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22lang%22%3A%22cpp%22%2C%22code%22%3A%22LL%20query(LL%20u)%7B%5Cn%20%20%20%20LL%20res%20%3D%200%3B%5Cn%20%20%20%20for(LL%20i%20%3D%20u%3Bi%20%3E%200%3B%2F*i%20-%3D%20lowbit(i)*%2Fi--)%7B%20%20%20%2F%2F%E7%B4%AF%E5%8A%A0%E5%90%84%E4%B8%AA%E5%85%83%E7%B4%A0%E7%9A%84%E5%B7%AE%E5%88%86%E5%92%8C%5Cn%20%20%20%20%20%20%20%20for(LL%20j%20%3D%20i%3Bj%20%3E%200%3Bj%20-%3D%20lowbit(j))%7B%20%20%20%20%20%20%5Cn%20%20%20%20%20%20%20%20%20%20%20%20res%20%2B%3D%20a%5Bj%5D%3B%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%7D%5Cn%20%20%20%20return%20res%3B%5Cn%7D%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="codeSnippet"><code class="language-cpp hljs"><span class="hljs-function">LL <span class="hljs-title">query<span class="hljs-params">(LL u){
    LL res = <span class="hljs-number">0;
    <span class="hljs-keyword">for(LL i = u;i &gt; <span class="hljs-number">0;<span class="hljs-comment">/*i -= lowbit(i)*/i--){   <span class="hljs-comment">//累加各个元素的差分和
        <span class="hljs-keyword">for(LL j = i;j &gt; <span class="hljs-number">0;j -= <span class="hljs-built_in">lowbit(j)){      
            res += a[j];
        }
    }
    <span class="hljs-keyword">return res;
}</span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="https://img2023.cnblogs.com/blog/2740326/202301/2740326-20230123101534044-530598597.gif" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /></span></div>
<p>&nbsp;</p>
</li>
</ol>
<h2 id="%C2%A0%E4%BD%86%E6%98%AF%E8%BF%99%E6%A0%B7%E7%9A%84%E6%93%8D%E4%BD%9C%E6%98%BE%E7%84%B6%E6%95%88%E7%8E%87%E8%BF%87%E4%BD%8E%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E4%BA%86%E5%A4%A7%E9%87%8F%E7%9A%84%E9%87%8D%E5%A4%8D%E5%B7%AE%E5%88%86%C2%A0%E6%89%80%E4%BB%A5%E9%9C%80%E8%A6%81%E6%94%B9%E8%BF%9B"><strong>&nbsp;但是这样的操作显然效率过低&mdash;&mdash;计算了大量的重复差分<br />
&nbsp;所以需要改进</strong></h2>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-display-name="代码段" data-cke-filter="off" data-cke-widget-id="3" data-cke-widget-wrapper="1">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22lang%22%3A%22cpp%22%2C%22code%22%3A%22a%5B1%5D%5Cna%5B1%5D%2Ba%5B2%5D%5Cn...%5Cn...%5Cna%5B1%5D%2Ba%5B2%5D%2B..%2Ba%5Bn-1%5D%5Cna%5B1%5D%2Ba%5B2%5D%2B......%20%2B%20a%5Bn%5D%2F%2F%E8%BD%AC%E5%8C%96%E6%88%90%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%96%B9%E4%BD%93%5Cn%5Cn%5Cna%5B1%5D%2Ba%5B2%5D%2B......%20%2B%20a%5Bn%5D%5Cna%5B1%5D%2Ba%5B2%5D%2B......%20%2B%20a%5Bn%5D%5Cn...%5Cn...%EF%BC%88%E6%80%BB%E5%85%B1n%2B1%E8%A1%8C%EF%BC%8C%E5%9C%A8%E6%9C%80%E4%B8%8A%E9%9D%A2%E6%B7%BB%E5%8A%A0%E4%B8%80%E8%A1%8C%EF%BC%89%5Cna%5B1%5D%2Ba%5B2%5D%2B......%20%2B%20a%5Bn%5D%5Cna%5B1%5D%2Ba%5B2%5D%2B......%20%2B%20a%5Bn%5D%5Cn%5Cn%5Cn%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F%3D%3E%5Cn(n%2B1)(a%5B1%5D%2Ba%5B2%5D%2B......%2Ba%5Bn%5D)%20-%20(1*a%5B1%5D%2B2*a%5B2%5D%2B......%2Bn*a%5Bn%5D)%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="codeSnippet"><code class="language-cpp hljs">a[<span class="hljs-number">1]
a[<span class="hljs-number">1]+a[<span class="hljs-number">2]
...
...
a[<span class="hljs-number">1]+a[<span class="hljs-number">2]+..+a[n<span class="hljs-number">-1]
a[<span class="hljs-number">1]+a[<span class="hljs-number">2]+...... + a[n]<span class="hljs-comment">//转化成一个正方体


a[<span class="hljs-number">1]+a[<span class="hljs-number">2]+...... + a[n]
a[<span class="hljs-number">1]+a[<span class="hljs-number">2]+...... + a[n]
...
...（总共n+<span class="hljs-number">1行，在最上面添加一行）
a[<span class="hljs-number">1]+a[<span class="hljs-number">2]+...... + a[n]
a[<span class="hljs-number">1]+a[<span class="hljs-number">2]+...... + a[n]


计算公式=&gt;
(n+<span class="hljs-number">1)(a[<span class="hljs-number">1]+a[<span class="hljs-number">2]+......+a[n]) - (<span class="hljs-number">1*a[<span class="hljs-number">1]+<span class="hljs-number">2*a[<span class="hljs-number">2]+......+n*a[n])</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="https://img2023.cnblogs.com/blog/2740326/202301/2740326-20230123101534044-530598597.gif" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /></span></div>
<p>所以我们可以维护<strong>两个树状数组</strong></p>
<p><strong>a[ i ]</strong></p>
<p><strong>b[ i ] = i * a[ i ]</strong></p>
<h2 id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">代码实现</h2>
<div class="cke_widget_wrapper cke_widget_block cke_widget_codeSnippet cke_widget_selected" data-cke-display-name="代码段" data-cke-filter="off" data-cke-widget-id="2" data-cke-widget-wrapper="1">
<pre class="cke_widget_element" data-cke-widget-data="%7B%22lang%22%3A%22cpp%22%2C%22code%22%3A%22%23include%20%3Ciostream%3E%5Cn%23include%20%3Ccstring%3E%5Cn%23include%20%3Calgorithm%3E%5Cnusing%20namespace%20std%3B%5Cntypedef%20long%20long%20LL%3B%5Cn%5Cnconst%20LL%20N%20%3D%201e5%2B10%3B%5CnLL%20a%5BN%5D%2Cb%5BN%5D%3B%5CnLL%20n%2Cm%3B%5Cn%5CnLL%20lowbit(LL%20x)%20%20%2F%2F%20%E8%BF%94%E5%9B%9E%E6%9C%AB%E5%B0%BE%E7%9A%841%5Cn%7B%5Cn%20%20%20%20return%20x%20%26%20-x%3B%5Cn%7D%5Cn%5Cnvoid%20add(LL%20x%2CLL%20w)%7B%5Cn%20%20%20%20for(LL%20i%20%3D%20x%3Bi%20%3C%3D%20n%3Bi%20%2B%3D%20lowbit(i))%7B%20%2F%2F%E5%90%8C%E6%97%B6%E7%BB%B4%E6%8A%A4%E4%B8%A4%E4%B8%AA%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%5Cn%20%20%20%20%20%20%20%20a%5Bi%5D%20%2B%3D%20w%3B%5Cn%20%20%20%20%20%20%20%20b%5Bi%5D%20%2B%3D%20x*w%3B%5Cn%20%20%20%20%7D%5Cn%7D%5Cn%5CnLL%20query(LL%20u)%7B%5Cn%20%20%20%20LL%20res%20%3D%200%3B%5Cn%20%20%20%20for(LL%20i%20%3D%20u%3Bi%20%3E%200%3Bi%20-%3D%20lowbit(i))%7B%20%2F%2F%E4%BC%98%E5%8C%96%E7%9A%84%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2%E6%96%B9%E6%A1%88%5Cn%20%20%20%20%20%20%20%20res%20%2B%3D%20(u%2B1)%20*%20a%5Bi%5D%20-%20b%5Bi%5D%3B%20%20%20%20%20%2F%2F%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F%5Cn%20%20%20%20%7D%5Cn%20%20%20%20return%20res%3B%5Cn%7D%5Cn%2F%2F-----------------------------------------------%2F%2F%E6%9C%B4%E7%B4%A0%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%AF%B9%E4%BA%8E%E6%AD%A4%E9%A2%98%E8%B6%85%E6%97%B6%5Cn%2F*%5Cnvoid%20add(LL%20x%2CLL%20w)%7B%5Cn%20%20%20%20for(LL%20i%20%3D%20x%3Bi%20%3C%3D%20n%3Bi%20%2B%3D%20lowbit(i))%7B%5Cn%20%20%20%20%20%20%20%20a%5Bi%5D%20%2B%3D%20w%3B%5Cn%20%20%20%20%7D%5Cn%7D%5Cn%5CnLL%20query(LL%20u)%7B%5Cn%20%20%20%20LL%20res%20%3D%200%3B%5Cn%20%20%20%20for(LL%20i%20%3D%20u%3Bi%20%3E%200%3Bi--)%7B%5Cn%20%20%20%20%20%20%20%20for(LL%20j%20%3D%20i%3Bj%20%3E%200%3Bj%20-%3D%20lowbit(j))%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20res%20%2B%3D%20a%5Bj%5D%3B%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%7D%5Cn%20%20%20%20return%20res%3B%5Cn%7D%5Cn*%2F%2F%2F------------------------------------------------%5Cnint%20main()%5Cn%7B%5Cn%20%20%20%20cin%20%3E%3E%20n%20%3E%3E%20m%3B%5Cn%20%20%20%20LL%20t1%3D0%2Ct2%3D0%3B%5Cn%20%20%20%20for%20(LL%20i%20%3D%201%3B%20i%20%3C%3D%20n%3B%20i%20%2B%2B%20)%7B%5Cn%20%20%20%20%20%20%20%20cin%20%3E%3E%20t2%3B%5Cn%20%20%20%20%20%20%20%20add(i%2Ct2-t1)%3B%5Cn%20%20%20%20%20%20%20%20t1%3Dt2%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20for(LL%20i%20%3D%201%3Bi%20%3C%3D%20m%3Bi%20%2B%2B)%7B%5Cn%20%20%20%20%20%20%20%20char%20x%3Bcin%20%3E%3E%20x%3B%5Cn%20%20%20%20%20%20%20%20if(x%20%3D%3D%20'Q')%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20LL%20a%2Cb%3Bcin%20%3E%3E%20a%20%3E%3E%20b%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20cout%20%3C%3C%20query(b)%20-%20query(a-1)%20%3C%3C%20endl%3B%5Cn%20%20%20%20%20%20%20%20%7Delse%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20LL%20a%2Cb%2Cc%3Bcin%20%3E%3E%20a%20%3E%3E%20b%20%3E%3E%20c%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20add(a%2C%20c)%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20add(b%2B1%2C%20-c)%3B%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%7D%5Cn%20%20%20%20return%200%3B%5Cn%7D%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="codeSnippet"><code class="language-cpp hljs"><span class="hljs-meta">#<span class="hljs-keyword">include <span class="hljs-string">&lt;iostream&gt;
<span class="hljs-meta">#<span class="hljs-keyword">include <span class="hljs-string">&lt;cstring&gt;
<span class="hljs-meta">#<span class="hljs-keyword">include <span class="hljs-string">&lt;algorithm&gt;
<span class="hljs-keyword">using <span class="hljs-keyword">namespace std;
<span class="hljs-keyword">typedef <span class="hljs-type">long <span class="hljs-type">long LL;

<span class="hljs-type">const LL N = <span class="hljs-number">1e5+<span class="hljs-number">10;
LL a[N],b[N];
LL n,m;

<span class="hljs-function">LL <span class="hljs-title">lowbit<span class="hljs-params">(LL x)  <span class="hljs-comment">// 返回末尾的1
{
    <span class="hljs-keyword">return x &amp; -x;
}

<span class="hljs-function"><span class="hljs-type">void <span class="hljs-title">add<span class="hljs-params">(LL x,LL w){
    <span class="hljs-keyword">for(LL i = x;i &lt;= n;i += <span class="hljs-built_in">lowbit(i)){ <span class="hljs-comment">//同时维护两个树状数组
        a[i] += w;
        b[i] += x*w;
    }
}

<span class="hljs-function">LL <span class="hljs-title">query<span class="hljs-params">(LL u){
    LL res = <span class="hljs-number">0;
    <span class="hljs-keyword">for(LL i = u;i &gt; <span class="hljs-number">0;i -= <span class="hljs-built_in">lowbit(i)){ <span class="hljs-comment">//优化的区间查询方案
        res += (u+<span class="hljs-number">1) * a[i] - b[i];     <span class="hljs-comment">//计算公式
    }
    <span class="hljs-keyword">return res;
}
<span class="hljs-comment">//-----------------------------------------------//朴素代码，对于此题超时
<span class="hljs-comment">/*
void add(LL x,LL w){
    for(LL i = x;i &lt;= n;i += lowbit(i)){
        a[i] += w;
    }
}

LL query(LL u){
    LL res = 0;
    for(LL i = u;i &gt; 0;i--){
        for(LL j = i;j &gt; 0;j -= lowbit(j)){
            res += a[j];
        }
    }
    return res;
}
*/<span class="hljs-comment">//------------------------------------------------
<span class="hljs-function"><span class="hljs-type">int <span class="hljs-title">main<span class="hljs-params">()
{
    cin &gt;&gt; n &gt;&gt; m;
    LL t1=<span class="hljs-number">0,t2=<span class="hljs-number">0;
    <span class="hljs-keyword">for (LL i = <span class="hljs-number">1; i &lt;= n; i ++ ){
        cin &gt;&gt; t2;
        <span class="hljs-built_in">add(i,t2-t1);
        t1=t2;
    }
    <span class="hljs-keyword">for(LL i = <span class="hljs-number">1;i &lt;= m;i ++){
        <span class="hljs-type">char x;cin &gt;&gt; x;
        <span class="hljs-keyword">if(x == <span class="hljs-string">'Q'){
            LL a,b;cin &gt;&gt; a &gt;&gt; b;
            cout &lt;&lt; <span class="hljs-built_in">query(b) - <span class="hljs-built_in">query(a<span class="hljs-number">-1) &lt;&lt; endl;
        }<span class="hljs-keyword">else{
            LL a,b,c;cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
            <span class="hljs-built_in">add(a, c);
            <span class="hljs-built_in">add(b+<span class="hljs-number">1, -c);
        }
    }
    <span class="hljs-keyword">return <span class="hljs-number">0;
}</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<span class="cke_reset cke_widget_drag_handler_container"><img src="https://img2023.cnblogs.com/blog/2740326/202301/2740326-20230123101534044-530598597.gif" width="15" height="15" class="cke_reset cke_widget_drag_handler" title="点击并拖拽以移动" data-cke-widget-drag-handler="1" /></span></div>
<blockquote>
<p><span class="cke_widget_wrapper cke_widget_inline cke_widget_csdnlink cke_widget_selected" data-cke-display-name="a" data-cke-filter="off" data-cke-widget-id="1" data-cke-widget-wrapper="1"><a class="cke_widget_editable cke_widget_element" title="​​​​​​〔manim | 算法 | 数据结构〕 完全理解并深入应用树状数组 | 支持多种动态维护区间操作_哔哩哔哩_bilibili" href="https://www.bilibili.com/video/BV1pE41197Qj?spm_id_from=333.1007.top_right_bar_window_history.content.click" data-cke-enter-mode="2" data-cke-saved-href="https://www.bilibili.com/video/BV1pE41197Qj?spm_id_from=333.1007.top_right_bar_window_history.content.click" data-cke-widget-data="%7B%22url%22%3A%22https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1pE41197Qj%3Fspm_id_from%3D333.1007.top_right_bar_window_history.content.click%22%2C%22text%22%3A%22%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E3%80%94manim%20%7C%20%E7%AE%97%E6%B3%95%20%7C%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%95%20%E5%AE%8C%E5%85%A8%E7%90%86%E8%A7%A3%E5%B9%B6%E6%B7%B1%E5%85%A5%E5%BA%94%E7%94%A8%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%20%7C%20%E6%94%AF%E6%8C%81%E5%A4%9A%E7%A7%8D%E5%8A%A8%E6%80%81%E7%BB%B4%E6%8A%A4%E5%8C%BA%E9%97%B4%E6%93%8D%E4%BD%9C_%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9_bilibili%22%2C%22desc%22%3A%22%22%2C%22icon%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.0.8%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DM276%22%2C%22isCard%22%3Afalse%2C%22hasResquest%22%3Atrue%2C%22iconDefault%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.2.1%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DMBR7%22%2C%22id%22%3A%22toQrea-1674439874352%22%2C%22classes%22%3Anull%7D" data-cke-widget-editable="text" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.0.8/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=M276" data-link-title="​​​​​​〔manim | 算法 | 数据结构〕 完全理解并深入应用树状数组 | 支持多种动态维护区间操作_哔哩哔哩_bilibili" data-widget="csdnlink">​​​​​​〔manim | 算法 | 数据结构〕 完全理解并深入应用树状数组 | 支持多种动态维护区间操作_哔哩哔哩_bilibili</a><br />
<span class="cke_widget_wrapper cke_widget_inline cke_widget_csdnlink cke_widget_selected" data-cke-display-name="a" data-cke-filter="off" data-cke-widget-id="0" data-cke-widget-wrapper="1"><a class="cke_widget_editable cke_widget_element" title="树状数组 数据结构详解与模板(可能是最详细的了)_bestsort的博客-CSDN博客_树状数组" href="https://blog.csdn.net/bestsort/article/details/80796531" data-cke-enter-mode="2" data-cke-saved-href="https://blog.csdn.net/bestsort/article/details/80796531" data-cke-widget-data="%7B%22url%22%3A%22https%3A%2F%2Fblog.csdn.net%2Fbestsort%2Farticle%2Fdetails%2F80796531%22%2C%22text%22%3A%22%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3%E4%B8%8E%E6%A8%A1%E6%9D%BF(%E5%8F%AF%E8%83%BD%E6%98%AF%E6%9C%80%E8%AF%A6%E7%BB%86%E7%9A%84%E4%BA%86)_bestsort%E7%9A%84%E5%8D%9A%E5%AE%A2-CSDN%E5%8D%9A%E5%AE%A2_%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%22%2C%22desc%22%3A%22%22%2C%22icon%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.0.8%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DM276%22%2C%22isCard%22%3Afalse%2C%22hasResquest%22%3Atrue%2C%22iconDefault%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.2.1%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DMBR7%22%2C%22id%22%3A%22nUaJrP-1674439874352%22%2C%22classes%22%3Anull%7D" data-cke-widget-editable="text" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-link-icon="https://csdnimg.cn/release/blog_editor_html/release2.0.8/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=M276" data-link-title="树状数组 数据结构详解与模板(可能是最详细的了)_bestsort的博客-CSDN博客_树状数组" data-widget="csdnlink">树状数组 数据结构详解与模板(可能是最详细的了)_bestsort的博客-CSDN博客_树状数组</a></span></span></p>



</blockquote>
<hr />
<p><strong>最后贴一下</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">Code（分块）O(m&radic;n)
#include </span>&lt;iostream&gt;<span style="color: #000000;">
#include </span>&lt;cstring&gt;<span style="color: #000000;">
#include </span>&lt;algorithm&gt;<span style="color: #000000;">
#include </span>&lt;cmath&gt;

<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;

typedef </span><span style="color: #0000ff;">long</span> <span style="color: #0000ff;">long</span><span style="color: #000000;"> LL;

</span><span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> N = 1e5 + <span style="color: #800080;">10</span>, M = <span style="color: #800080;">350</span><span style="color: #000000;">;

</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n, m, len;
LL sum[M], flag[M]; </span><span style="color: #008000;">//</span><span style="color: #008000;">sum：块的总和；flag：块的懒标记</span>
<span style="color: #0000ff;">int</span><span style="color: #000000;"> w[N];

</span><span style="color: #0000ff;">int</span> <span style="color: #0000ff;">get</span>(<span style="color: #0000ff;">int</span><span style="color: #000000;"> i)
{
    </span><span style="color: #0000ff;">return</span> i /<span style="color: #000000;"> len;
}
</span><span style="color: #0000ff;">void</span> modify(<span style="color: #0000ff;">int</span> l, <span style="color: #0000ff;">int</span> r, <span style="color: #0000ff;">int</span><span style="color: #000000;"> d)
{
    </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">get</span>(l) == <span style="color: #0000ff;">get</span>(r))   <span style="color: #008000;">//</span><span style="color: #008000;">段内直接暴力</span>
<span style="color: #000000;">    {
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = l; i &lt;= r; i ++<span style="color: #000000;"> )
            w[i] </span>+= d, sum[<span style="color: #0000ff;">get</span>(i)] +=<span style="color: #000000;"> d;
    }
    </span><span style="color: #0000ff;">else</span><span style="color: #000000;">
    {
        </span><span style="color: #0000ff;">int</span> i = l, j =<span style="color: #000000;"> r;
        </span><span style="color: #0000ff;">while</span> (<span style="color: #0000ff;">get</span>(i) == <span style="color: #0000ff;">get</span>(l)) w[i] += d, sum[<span style="color: #0000ff;">get</span>(i)] += d, i ++<span style="color: #000000;"> ;
        </span><span style="color: #0000ff;">while</span> (<span style="color: #0000ff;">get</span>(j) == <span style="color: #0000ff;">get</span>(r)) w[j] += d, sum[<span style="color: #0000ff;">get</span>(j)] += d, j --<span style="color: #000000;"> ;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> k = <span style="color: #0000ff;">get</span>(i); k &lt;= <span style="color: #0000ff;">get</span>(j); k ++ ) sum[k] += len * d, flag[k] +=<span style="color: #000000;"> d;
    }
}
LL query(</span><span style="color: #0000ff;">int</span> l, <span style="color: #0000ff;">int</span><span style="color: #000000;"> r)
{
    LL res </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">get</span>(l) == <span style="color: #0000ff;">get</span>(r))   <span style="color: #008000;">//</span><span style="color: #008000;">段内直接暴力</span>
<span style="color: #000000;">    {
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = l; i &lt;= r; i ++<span style="color: #000000;"> )
            res </span>+= w[i] + flag[<span style="color: #0000ff;">get</span><span style="color: #000000;">(i)];
    }
    </span><span style="color: #0000ff;">else</span><span style="color: #000000;">
    {
        </span><span style="color: #0000ff;">int</span> i = l, j =<span style="color: #000000;"> r;
        </span><span style="color: #0000ff;">while</span> (<span style="color: #0000ff;">get</span>(i) == <span style="color: #0000ff;">get</span>(l)) res += w[i] + flag[<span style="color: #0000ff;">get</span>(i)], i ++<span style="color: #000000;"> ;
        </span><span style="color: #0000ff;">while</span> (<span style="color: #0000ff;">get</span>(j) == <span style="color: #0000ff;">get</span>(r)) res += w[j] + flag[<span style="color: #0000ff;">get</span>(j)], j --<span style="color: #000000;"> ;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> k = <span style="color: #0000ff;">get</span>(i); k &lt;= <span style="color: #0000ff;">get</span>(j); k ++ ) res +=<span style="color: #000000;"> sum[k];
    }
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
}
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
{
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d%d</span><span style="color: #800000;">"</span>, &amp;n, &amp;<span style="color: #000000;">m);
    len </span>=<span style="color: #000000;"> sqrt(n);
    </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt;= n; i ++<span style="color: #000000;"> )
    {
        scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d</span><span style="color: #800000;">"</span>, &amp;<span style="color: #000000;">w[i]);
        sum[</span><span style="color: #0000ff;">get</span>(i)] +=<span style="color: #000000;"> w[i];
    }

    </span><span style="color: #0000ff;">char</span> op[<span style="color: #800080;">2</span><span style="color: #000000;">];
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> l, r, d;

    </span><span style="color: #0000ff;">while</span> (m --<span style="color: #000000;"> )
    {
        scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%s%d%d</span><span style="color: #800000;">"</span>, op, &amp;l, &amp;<span style="color: #000000;">r);
        </span><span style="color: #0000ff;">if</span> (*op == <span style="color: #800000;">'</span><span style="color: #800000;">C</span><span style="color: #800000;">'</span><span style="color: #000000;">)
        {
            scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d</span><span style="color: #800000;">"</span>, &amp;<span style="color: #000000;">d);
            modify(l, r, d);
        }
        </span><span style="color: #0000ff;">else</span> printf(<span style="color: #800000;">"</span><span style="color: #800000;">%lld\n</span><span style="color: #800000;">"</span><span style="color: #000000;">, query(l, r));
    }
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}

线段树 O(mlogn)

#include </span>&lt;iostream&gt;<span style="color: #000000;">
#include </span>&lt;cstdio&gt;<span style="color: #000000;">
#include </span>&lt;cstring&gt;<span style="color: #000000;">
#include </span>&lt;algorithm&gt;<span style="color: #000000;">

typedef </span><span style="color: #0000ff;">long</span> <span style="color: #0000ff;">long</span><span style="color: #000000;"> LL;

</span><span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span> N = 1e5 + <span style="color: #800080;">10</span><span style="color: #000000;">;
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n, m;
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> w[N];
</span><span style="color: #0000ff;">struct</span><span style="color: #000000;"> Node
{
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> l, r;
    LL sum, add;
}tr[N </span>* <span style="color: #800080;">4</span><span style="color: #000000;">];

</span><span style="color: #0000ff;">void</span> pushup(<span style="color: #0000ff;">int</span><span style="color: #000000;"> u)
{
    tr[u].sum </span>= tr[u &lt;&lt; <span style="color: #800080;">1</span>].sum + tr[u &lt;&lt; <span style="color: #800080;">1</span> | <span style="color: #800080;">1</span><span style="color: #000000;">].sum;
}
</span><span style="color: #0000ff;">void</span> pushdown(<span style="color: #0000ff;">int</span><span style="color: #000000;"> u)
{
    auto </span>&amp;root = tr[u], &amp;left = tr[u &lt;&lt; <span style="color: #800080;">1</span>], &amp;right = tr[u &lt;&lt; <span style="color: #800080;">1</span> | <span style="color: #800080;">1</span><span style="color: #000000;">];
    </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (root.add)
    {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">传递懒标记，更新子树</span>
        left.add += root.add, left.sum += (LL) (left.r - left.l + <span style="color: #800080;">1</span>) *<span style="color: #000000;"> root.add;
        right.add </span>+= root.add, right.sum += (LL) (right.r - right.l + <span style="color: #800080;">1</span>) *<span style="color: #000000;"> root.add;
        </span><span style="color: #008000;">//</span><span style="color: #008000;">删除父结点懒标记</span>
        root.add = <span style="color: #800080;">0</span><span style="color: #000000;">;
    }
}
</span><span style="color: #0000ff;">void</span> build(<span style="color: #0000ff;">int</span> u, <span style="color: #0000ff;">int</span> l, <span style="color: #0000ff;">int</span><span style="color: #000000;"> r)
{
    </span><span style="color: #0000ff;">if</span> (l == r) tr[u] = {l, r, w[l], <span style="color: #800080;">0</span><span style="color: #000000;">};
    </span><span style="color: #0000ff;">else</span><span style="color: #000000;">
    {
        tr[u] </span>=<span style="color: #000000;"> {l, r};
        </span><span style="color: #0000ff;">int</span> mid = l + r &gt;&gt; <span style="color: #800080;">1</span><span style="color: #000000;">;
        build(u </span>&lt;&lt; <span style="color: #800080;">1</span>, l, mid), build(u &lt;&lt; <span style="color: #800080;">1</span> | <span style="color: #800080;">1</span>, mid + <span style="color: #800080;">1</span><span style="color: #000000;">, r);
        pushup(u);
    }
}
</span><span style="color: #0000ff;">void</span> modify(<span style="color: #0000ff;">int</span> u, <span style="color: #0000ff;">int</span> l, <span style="color: #0000ff;">int</span> r, <span style="color: #0000ff;">int</span><span style="color: #000000;"> v)
{
    </span><span style="color: #0000ff;">if</span> (l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;=<span style="color: #000000;"> r)
    {
        tr[u].sum </span>+= (tr[u].r - tr[u].l + <span style="color: #800080;">1</span>) *<span style="color: #000000;"> v;
        tr[u].add </span>+=<span style="color: #000000;"> v;
    }
    </span><span style="color: #0000ff;">else</span><span style="color: #000000;">
    {
        pushdown(u);
        </span><span style="color: #0000ff;">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (l &lt;= mid) modify(u &lt;&lt; <span style="color: #800080;">1</span><span style="color: #000000;">, l, r, v);
        </span><span style="color: #0000ff;">if</span> (r &gt; mid) modify(u &lt;&lt; <span style="color: #800080;">1</span> | <span style="color: #800080;">1</span><span style="color: #000000;">, l, r, v);
        pushup(u);
    }
}
LL query(</span><span style="color: #0000ff;">int</span> u, <span style="color: #0000ff;">int</span> l, <span style="color: #0000ff;">int</span><span style="color: #000000;"> r)
{
    </span><span style="color: #0000ff;">if</span> (l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r) <span style="color: #0000ff;">return</span><span style="color: #000000;"> tr[u].sum;

    pushdown(u);
    </span><span style="color: #0000ff;">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span style="color: #800080;">1</span><span style="color: #000000;">;
    LL v </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">if</span> (l &lt;= mid) v = query(u &lt;&lt; <span style="color: #800080;">1</span><span style="color: #000000;">, l, r);
    </span><span style="color: #0000ff;">if</span> (r &gt; mid) v += query(u &lt;&lt; <span style="color: #800080;">1</span> | <span style="color: #800080;">1</span><span style="color: #000000;">, l, r);
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> v;
}
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
{
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d%d</span><span style="color: #800000;">"</span>, &amp;n, &amp;<span style="color: #000000;">m);
    </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt;= n; ++i) scanf(<span style="color: #800000;">"</span><span style="color: #800000;">%d</span><span style="color: #800000;">"</span>, &amp;<span style="color: #000000;">w[i]);
    build(</span><span style="color: #800080;">1</span>, <span style="color: #800080;">1</span><span style="color: #000000;">, n);

    </span><span style="color: #0000ff;">char</span> op[<span style="color: #800080;">2</span><span style="color: #000000;">];
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> l, r, t;
    </span><span style="color: #0000ff;">while</span> (m --<span style="color: #000000;"> )
    {
        scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%s%d%d</span><span style="color: #800000;">"</span>, op, &amp;l, &amp;<span style="color: #000000;">r);
        </span><span style="color: #0000ff;">if</span> (*op == <span style="color: #800000;">'</span><span style="color: #800000;">Q</span><span style="color: #800000;">'</span>) printf(<span style="color: #800000;">"</span><span style="color: #800000;">%lld\n</span><span style="color: #800000;">"</span>, query(<span style="color: #800080;">1</span><span style="color: #000000;">, l, r));
        </span><span style="color: #0000ff;">else</span><span style="color: #000000;">
        {
            scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d</span><span style="color: #800000;">"</span>, &amp;<span style="color: #000000;">t);
            modify(</span><span style="color: #800080;">1</span><span style="color: #000000;">, l, r, t);
        }
    }
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<p>&nbsp;</p>


<span data-cke-copybin-start="1">
<span data-cke-copybin-end="1">​</span></span>