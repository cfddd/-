## **代理模式（Proxy Pattern）**
- **定义**：为其他对象提供一种代理以控制对这个对象的访问。
- **适用场景**：在网络访问中，当访问一些外部网站时，可能会使用代理服务器。代理服务器代替用户访问目标网站，并且可以对访问进行控制，如缓存数据、过滤内容等。
- **实现方式**：以简单的图像加载代理为例，有一个图像接口、真实图像类和图像代理类。
```
interface Image {
    void display();
}
class RealImage implements Image {
    private String fileName;
    public RealImage(String fileName) {
        this.fileName = fileName;
        loadFromDisk(fileName);
    }
    private void loadFromDisk(String fileName) {
        System.out.println("Loading " + fileName);
    }
    @Override
    public void display() {
        System.out.println("Displaying " + fileName);
    }
}
class ProxyImage implements Image {
    private RealImage realImage;
    private String fileName;
    public ProxyImage(String fileName) {
        this.fileName = fileName;
    }
    @Override
    public void display() {
        if (realImage == null) {
            realImage = new RealImage(fileName);
        }
        realImage.display();
    }
}
```
## **装饰器模式（Decorator Pattern）**
装饰器模式是一种**结构型设计模式**，它允许向一个现有的对象添加新的功能，同时又不改变其结构。这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。

通过组合而非继承来扩展对象功能，使扩展更加灵活，符合开闭原则（对扩展开放，对修改关闭）。

**装饰器模式包含四个核心角色**：

1. **抽象组件（Component）**：定义对象的接口，可以给这些对象动态添加职责
2. **具体组件（ConcreteComponent）**：实现抽象组件接口，是被装饰的原始对象
3. **抽象装饰器（Decorator）**：持有一个抽象组件的引用，并实现与抽象组件一致的接口
4. **具体装饰器（ConcreteDecorator）**：负责向组件添加新的职责

```java
// 1. 抽象组件
interface Coffee {
    String getDescription();
    double cost();
}

// 2. 具体组件
class SimpleCoffee implements Coffee {
    @Override
    public String getDescription() {
        return "简单咖啡";
    }

    @Override
    public double cost() {
        return 5.0;
    }
}

// 3. 抽象装饰器
abstract class CoffeeDecorator implements Coffee {
    protected Coffee decoratedCoffee;

    public CoffeeDecorator(Coffee decoratedCoffee) {
        this.decoratedCoffee = decoratedCoffee;
    }

    @Override
    public String getDescription() {
        return decoratedCoffee.getDescription();
    }

    @Override
    public double cost() {
        return decoratedCoffee.cost();
    }
}

// 4. 具体装饰器
class MilkDecorator extends CoffeeDecorator {
    public MilkDecorator(Coffee decoratedCoffee) {
        super(decoratedCoffee);
    }

    @Override
    public String getDescription() {
        return decoratedCoffee.getDescription() + ", 加牛奶";
    }

    @Override
    public double cost() {
        return decoratedCoffee.cost() + 2.0;
    }
}

class SugarDecorator extends CoffeeDecorator {
    public SugarDecorator(Coffee decoratedCoffee) {
        super(decoratedCoffee);
    }

    @Override
    public String getDescription() {
        return decoratedCoffee.getDescription() + ", 加糖";
    }

    @Override
    public double cost() {
        return decoratedCoffee.cost() + 1.0;
    }
}

// 客户端使用
public class DecoratorPatternDemo {
    public static void main(String[] args) {
        // 简单咖啡
        Coffee coffee = new SimpleCoffee();
        System.out.println(coffee.getDescription() + " 价格: " + coffee.cost());

        // 加牛奶的咖啡
        Coffee coffeeWithMilk = new MilkDecorator(coffee);
        System.out.println(coffeeWithMilk.getDescription() + " 价格: " + coffeeWithMilk.cost());

        // 加牛奶和糖的咖啡
        Coffee coffeeWithMilkAndSugar = new SugarDecorator(coffeeWithMilk);
        System.out.println(coffeeWithMilkAndSugar.getDescription() + " 价格: " + coffeeWithMilkAndSugar.cost());
    }
}
```

## **适配器模式（Adapter Pattern）**
- **定义**：将一个类的接口转换成客户希望的另一个接口。使得原本由于接口不兼容而不能一起工作的类可以一起工作。
- **适用场景**：例如，在旧系统和新系统之间进行数据交互。旧系统的接口格式和新系统不兼容，通过适配器可以将旧系统的数据格式转换为新系统能够接受的格式。
- **实现方式**：假设有一个旧的打印机接口和一个新的电脑接口，通过适配器来连接它们。

```
class OldPrinter {
    public void printOldFormat(String data) {
        System.out.println("Printing in old format: " + data);
    }
}
interface NewComputer {
    void printNewFormat(String data);
}
class PrinterAdapter implements NewComputer {
    private OldPrinter oldPrinter;
    public PrinterAdapter(OldPrinter oldPrinter) {
        this.oldPrinter = oldPrinter;
    }
    @Override
    public void printNewFormat(String data) {
        String convertedData = convertData(data);
        oldPrinter.printOldFormat(convertedData);
    }
    private String convertData(String data) {
        // 简单的数据转换示例
        return "Converted: " + data;
    }
}
```
## **桥接模式（Bridge Pattern）**
- **定义**：将抽象部分与它的实现部分分离，使它们都可以独立地变化。
- **适用场景**：在图形绘制软件中，形状（如圆形、方形）是抽象部分，颜色（如红色、蓝色）是实现部分。通过桥接模式可以将形状和颜色的实现分开，这样可以方便地组合不同的形状和颜色，而不会相互影响。
- **实现方式**：以形状和颜色为例，有一个形状接口、不同形状的实现类和颜色接口、不同颜色的实现类。

```
interface Shape {
    void draw();
}
class Circle implements Shape {
    private Color color;
    public Circle(Color color) {
        this.color = color;
    }
    @Override
    public void draw() {
        System.out.print("Drawing a circle with ");
        color.fill();
    }
}
class Square implements Shape {
    private Color color;
    public Square(Color color) {
        this.color = color;
    }
    @Override
    public void draw() {
        System.out.print("Drawing a square with ");
        color.fill();
    }
}
interface Color {
    void fill();
}
class RedColor implements Color {
    @Override
    public void fill() {
        System.out.println("red color.");
    }
}
class BlueColor implements Color {
    @Override
    public void fill() {
        System.out.println("blue color.");
    }
}
```

  

## **组合模式（Composite Pattern）**
- **定义**：将对象组合成树形结构以表示 “部分 - 整体” 的关系。使得用户对单个对象和组合对象的使用具有一致性。
- **适用场景**：在文件系统中，文件和文件夹就构成了组合模式。文件夹可以包含文件和其他文件夹，用户可以像操作单个文件一样操作文件夹（如复制、删除等操作）。
- **实现方式**：以简单的文件和文件夹为例，有一个抽象的文件系统组件接口、文件类和文件夹类。

```
interface FileSystemComponent {
    void display();
}
class File implements FileSystemComponent {
    private String name;
    public File(String name) {
        this.name = name;
    }
    @Override
    public void display() {
        System.out.println("File: " + name);
    }
}
class Folder implements FileSystemComponent {
    private String name;
    private List<FileSystemComponent> components = new ArrayList<>();
    public Folder(String name) {
        this.name = name;
    }
    public void addComponent(FileSystemComponent component) {
        components.add(component);
    }
    @Override
    public void display() {
        System.out.println("Folder: " + name);
        for (FileSystemComponent component : components) {
            component.display();
        }
    }
}
```