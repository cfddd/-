
## new
`new`函数用于**创建指针**。**它返回一个指向新分配的零值的指针**。`new`函数的语法是：`new(T)`，其中T表示要创建指针的类型。例如，`new(int)`会返回一个指向int类型零值的指针。
## make
`make`函数用于**创建切片、映射(map)和通道(channel)**。**它返回一个已初始化且可用的数据结构。**`make`函数的语法是：`make(T, args...)`，其中T表示要创建的类型，args表示类型对应的参数。例如，`make([]int, 5)`会创建一个包含5个整数的切片，并初始化每个元素为其类型的零值。

## 总结

**new和make都在堆上分配内存**，但是它们的行为不同，适用于不同的类型。

new(T) 为每个新的类型T分配一片内存，初始化为 0 并且返回类型为*T的内存地址：这种方法 **返回一个指向类型为 T，值为 0 的地址的指针**，它适用于值类型如数组和结构体；它相当于 &T{}。

make(T) **返回一个类型为 T 的初始值**，是三个引用类型本身，它只适用于3种内建的引用类型：slice、map 和 channel。

换言之，new 函数分配内存，make 函数初始化；

#### 其实new不常用

所以有new这个内置函数，可以给我们分配一块内存让我们使用，但是现实的编码中，它是不常用的。我们通常都是采用短语句声明以及结构体的字面量达到我们的目的，比如：

```go
i:=0
u:=user{}
```

这样更简洁方便，而且不会涉及到指针这种比麻烦的操作。

make函数是无可替代的，我们在使用slice、map以及channel的时候，还是要使用make进行初始化，然后才可以对他们进行操作。
```go
package main
 
import (
    "fmt"
)
 
func main() {
    p := new([]int) //p == nil; with len and cap 0
    fmt.Println(p)
 
    v := make([]int, 10, 50) // v is initialed with len 10, cap 50
    fmt.Println(v)
 
    /*********Output****************
        &[]
        [0 0 0 0 0 0 0 0 0 0]
    *********************************/
 
    (*p)[0] = 18        // panic: runtime error: index out of range
                        // because p is a nil pointer, with len and cap 0
    v[1] = 18           // ok
     
}
```

## 如果new 切片会怎么样?
如果使用`new`来创建切片，会返回一个指向切片类型的零值的指针。这意味着切片指针本身是已分配的，但切片的底层数组还未分配。因此，你需要使用`make`函数来分配底层数组并初始化切片。

下面是一个示例，展示了如何使用`new`和`make`创建切片：

```go
// 使用new创建切片
var s *[]int
s = new([]int) // 返回一个指向nil的切片指针
fmt.Println(s) // 输出: &[]

// 使用make创建切片
s = make([]int, 5, 5) // 返回一个长度和容量都为5的切片
fmt.Println(s)       // 输出: [0 0 0 0 0]
```

需要注意的是，使用`new`创建的切片需要手动使用`make`函数来分配底层数组，否则切片将无法正常使用。