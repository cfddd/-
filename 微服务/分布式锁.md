> https://www.cnblogs.com/liuqingzheng/p/11080501.html
> 
> [Redis分布式锁-这一篇全了解(Redission实现分布式锁完美方案)-CSDN博客](https://blog.csdn.net/asd051377305/article/details/108384490)
## 为什么用分布式锁
在多机环境下，由于每个服务运行的环境是独立的，所以本地可以使用的锁不能保护共享资源被别的线程访问，必须通过一个公共能够使用锁
## 分布式锁实现
当谈到分布式锁的多种实现方式时，我可以用一些常见的实现方式来举例说明：

1. **基于数据库的实现：**

   - **示例：** 在关系型数据库中，可以使用行级锁或者乐观锁来实现分布式锁。例如，可以创建一个名为“locks”的表，其中包含资源名称和一个表示锁定状态的字段。通过在数据库中插入或更新锁定状态的行来获得或释放锁。
   
   - **优点：** 数据库锁的实现相对简单，易于理解和维护。可以利用数据库事务的特性来确保原子性。
   
   - **缺点：**
	   - 性能可能不够高，特别是在高并发的情况下，数据库的负载可能会成为瓶颈。
	   - 没有自动过期功能，需要手动增加时间列并做出业务判断

2. **基于缓存的实现（如Redis）：**

   - **示例：** 在Redis中，可以使用SETNX（SET if Not eXists）命令来实现分布式锁。当一个客户端成功地获取到锁时，它会设置一个键值对作为锁标识，并给这个键值对设置一个过期时间，以防止锁被长时间占用。
   
   - **优点：** Redis的性能非常高，而且具有很好的并发控制能力。通过设置适当的过期时间，可以防止死锁。
   
   - **缺点：** 如果Redis节点发生故障或网络分区，可能会导致锁的丢失或者出现一致性问题。

3. **基于ZooKeeper的实现：**

   - **示例：** 在ZooKeeper中，可以使用临时有序节点来实现分布式锁。当一个客户端希望获取锁时，它会在ZooKeeper中创建一个临时有序节点，然后检查自己是否是最小的节点，如果是，则获取到锁，否则等待。
   
   - **优点：** ZooKeeper提供了高可用性和强一致性，能够有效地解决网络分区和节点故障的问题。
   
   - **缺点：** ZooKeeper的配置和管理相对复杂，而且性能可能不如缓存实现方式高。

1. **基于ETCD的实现**

- **示例**：`etcdctl --endpoints=$ENDPOINTS lock mutex1`这个命令将创建一个名为 `mutex1` 的锁，如果有相同名称的锁，那么就会阻塞。
- **优点**：简单好用
- **缺点**：需要配置ETCD；可能对网络依赖较大，网络波动时出现较大问题

这些是分布式锁的一些常见实现方式，每种方式都有其优缺点，需要根据具体的业务需求和系统特性来选择合适的实现方式。

一般来说都是选择速度最快的redis缓存作为分布式锁实现的载体

## Redis分布式锁SETNX存在的问题

设想这样一种情况：一个线程拿到分布式锁，但是长久没有释放，导致锁的过期，结束对临界区资源的保护，别的线程拿到了锁，开始对临界区资源进行访问；最开始的线程运行完毕，释放了第二个线程加的锁

这里存在两个问题：
1. **锁过期，别的线程拿到锁**
2. **当前线程正在操作锁，被别的线程释放**

对于第一个问题，我们的解决方案是：设置一个"看门狗"，额外线程，每隔一段时间检测是否有任务持有锁，但是即将过期，然后给锁续约

对于第二个问题：按照“线程唯一标识（UUID）” + “锁”设置键，解锁时只有线程唯一标识相同时才可以操作

但是上面的方案，需要针对不同场景重新开发，而且复杂度较大，所以Redis就有了redisson框架JAVA
## JAVA redisson框架
1. 线程尝试获取锁
	1. 获取锁成功，UUID+线程ID作为key
	2. 获取失败，自旋尝试获取锁
2. “看门狗”，每隔一段时间检测是否有快要到期的键人在被占用，然后为他续约

> redis 存在主从集群，如果主节点宕机了，怎么处理？

可以使用一个框架，判断当redis信息完全同步到大部分其他节点上才可以提供服务，否则一直阻塞

弊端也很明显，可能会产生非常大的延时