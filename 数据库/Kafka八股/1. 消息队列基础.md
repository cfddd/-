## 消息队列的作用
### 异步处理 
减少请求的等待，还能让服务异步并发处理，提升系统总体性能。

例如，随着系统请求调用路径的逐渐增长，系统响应的时间也就会越来越长，导致严重影响用户体验

为了加快响应的速度，我们可以用消息队列异步处理部分逻辑，将用户实时性影响低的逻辑剥离出去
### 服务解耦
优化系统之间的架构，让系统之间解耦，减轻上下游系统之间改动涉及到的工作量

例如一个系统，他的下游系统可能会有各种各样的需求，不可能为下游系统的所有需求都开发一个接口，所以可以用消息队列，下游系统谁需要这个消息，就去订阅消息队列对应的主题，成功实现了系统之间的解耦

### 流量控制
所谓“削峰填谷”，可以将系统不规则的流量变得尽可能平滑

例如秒杀活动，后端的流量爆发式增长，而消息队列可以作为缓冲，避免过大的流量瞬间打在后端服务器上导致服务宕机。对于一个请求，可以先放入消息队列中，后端服务尽自己最大的能力去消费消息，超时的请求可以直接返回错误

再例如发送邮件通知的服务，这种需求对于用户而言并实时不高，请求量也不高的需求，也可以通过消息队列来控制消费，让系统按照一定的频率来消费

## 消息队列的基本概念
消息队列有两种模型：队列模型 和 发布/订阅模型。
### 队列模型 
生产者往某个队列里面发送消息，一个队列可以存储多个生产者的消息，一个队列也可以有多个消费 
者，但是消费者之间是竞争关系，即每条消息只能被一个消费者消费。
### 发布/订阅模型 
为了解决一条消息能被多个消费者消费的问题，发布/订阅模型就来了。该模型是将消息发往一个
Topic即主题中，所有订阅了这个 Topic 的订阅者都能消费这条消息。

### 小结
队列模型每条消息只能被一个消费者消费，而发布/订阅模型就是为让一条消息可以被多个消费者消费 
而生的，当然队列模型也可以通过消息全量存储至多个队列来解决一条消息被多个消费者消费问题，但 
是会有数据的冗余。

发布/订阅模型兼容队列模型，即只有一个消费者的情况下和队列模型基本一致。

RabbitMQ 采用队列模型，RocketMQ和Kafka 采用发布/订阅模型。
## 常用术语（基于发布/订阅模型）
- Producer：生产者
- Consumer：消费者
- Broker：消息队列服务者

往往发布/订阅模型还会引入队列或者分区的概念。RocketMQ中叫队列，Kafka叫分区，本质一样。

即消息是发往一个主题下的某个队列或者某个分区中。
## 推拉模式
一般而言，在谈论推拉模式的时候指的是 Comsumer 和 Broker 之间的交互。

Producer 生产消息后一般直接推送到 Broker。

> 为什么 Producer 和 Broker 之间不是拉模式？
> 
> 我们假想一下这样如何实现：Producer 需要维护一个消息缓存，Broker轮询这个缓存并放入消息队列中。
> 
> 这会导致一个问题：需要额外维护 Producer 的消息缓存可靠性，相比推模式只用维护Broker的可靠性，增加了系统的复杂性

### 推模式
推模式指的是消息从 Broker 推向 Consumer，即 Consumer 被动的接收消息，由 Broker 来主导消息 
的发送。

- 好处
	- **消息实时发送**：Broker接收Consumer的消息可以直接发送给Consumer
	- **消费者使用简单**：只需等待消息
- 缺点
	- **推送速率难以适应消费速率**：Broker推送过快，导致超出Consumer的消费能力
### 拉模式
拉模式指的是 Consumer 主动向 Broker 请求拉取消息，即 Broker 被动的发送消息给 Consumer。

- 好处
	- **消费者可以根据自身的情况（消费速率）来发起拉取消息的请求**
	- **Broker更加简单**，只需要存储消息等待消费就可以了
	- **拉模式更适合批量消费**：可以根据消费者请求消息的数量，来决定批量发送多少消息
- 缺点
	- **消息延迟**：消费者不知道消息什么时候到达，需要控制一个合理的轮询的频率
	- **消息忙请求**：在一段时间里都没有消息，但是消费者一直在尝试拉取
### 推和拉如何抉择？
业界两种MQ的实现都有，RocketMQ 和 Kafka 都选择了拉模式

一般来说也是拉模式更合理，因为Broker不会成为性能瓶颈，主要复杂度都在生产和消费这两个动作上，而拉模式相比推模式，Broker会更轻量

虽然拉模式存在的缺点：消息延迟等，但是RocketMQ 和 Kafka 使用了长轮询来减轻这个缺点的影响

## 长轮询
简单的说就是消费者去 Broker 拉消息，定义了一个超时时间，也就是说消费者去请求消息，如果有的 
话马上返回消息，如果没有的话消费者等着直到超时，然后再次发起拉消息请求。

并且 Broker 也得配合，如果消费者请求过来，有消息肯定马上返回，没有消息那就建立一个延迟操 
作，等条件满足了再返回。