## 如何保证消息不丢失 
从三个阶段 **生产消息、存储消息和消费消息** 分别入手
### 1.生产消息
- 生产者发送消息至Broker，不论是同步还是异步发送消息，同步和异步回调都需要做好try-catch，需要妥善的处理Broker响应
- 如果Broker返回写入失败等错误消息，需要重试发送
- 当多次发送失败需要作报警，日志记录等
### 2.存储消息
- 存储消息阶段需要在消息刷盘之后，再给生产者响应，同时保存好日志
- 使用集群部署，保持异地多活，让数据再多地有备份来容灾
### 3.消费消息
- 消费者执行完业务逻辑之后，再发送给Broker消费成功
## 如何处理重复消息
对于正常业务而言，消息重复是不可避免的，从生产者到消费者的全过程都有可能因为各种原因导致重复（例如网络问题）

解决问题的一个关键点是保持消息的**幂等性**。既然不能防止重复消息的产生，那么我们只能在业务上处理重复消息所带来的影响。

如果消息的设计必定是**非幂等的**，处理给每条消息加上一个唯一ID作为标识，在消息队列外部做验证，丢弃重复ID的消息，保证每一条消息都能消费完

- 前置条件判断，使用数据库对消息进行版本号控制，对比消息中的版本号和数据库中的版本号。
- 数据库的约束例如唯一键，`insert into update on duplicate key`
- 记录关键的key，例如全局唯一ID
## 如何保证消息的有序性
有序性分：**全局有序和部分有序**。
- **全局有序：** 一个Topic下的所有消息都需要按照生产顺序消费。
- **局部有序：** 一个Topic下的消息，只需要满足同一业务字段的要按照生产顺序消费。例如：Topic消息是订单的流水表，包含订单orderId，业务要求同一个orderId的消息需要按照生产顺序进行消费。
### 全局有序
- **生产端控制消息有序**：只能由一个生产者往Topic发送消息
- **kafka**：将kafka的Topic下的分片数量设置为1，利用队列自身的FIFO特性，保证消费消息的有序性
- **消费端控制消息有序**：一个队列对应一个消费者，**使用单线程或者保证消费顺序的线程模型**，可以保证消息消费是有序的
### 部分有序
- **Kafka**：Topic内部划分成我们需要的队列数
- **生产端**：把消息通过特定的策略发往固定的队列中，同一类的的消息使用同一个内存队列进行存储
- **消费端**：每个队列对应一个单线程处理的消费者，消费同一类的消息

## 如何处理消息堆积
主要原因如下
- **生产者的生产速度与消费者的消费速度不匹配**
- **消费者消费能力弱** ，频繁消息消费失败，重试过多造成的

> **定位原因**

1. 查看是否存在bug，导致消费失败
2. 优化下消费逻辑，提高消费能力

> 消费者优化到极致，无法再优化

考虑水平扩容了，增加Topic的队列数和消费者数量

注意队列数一定要增加，不然新增加的消费者是没东西消费的。一个Topic中，一个队列只会分配给一 
个消费者。