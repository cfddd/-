## 概念理解
> [什么是缓存雪崩、缓存击穿、缓存穿透？ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/346651831)
### 缓存雪崩

当某一个时刻出现**大规模的缓存失效**的情况，那么就会导致大量的请求直接打在数据库上面，导致数据库压力巨大，如果在高并发的情况下，可能瞬间就会导致数据库宕机。

**分析：**

造成缓存雪崩的关键在于在同一时间大规模的key失效。为什么会出现这个问题呢，有几种可能，第一种可能是**Redis宕机**，第二种可能是采用了**相同的过期时间**。搞清楚原因之后，那么有什么解决方案呢？

**解决方案：**

1、在原有的**失效时间上加上一个随机值**，比如1-5分钟随机。这样就避免了因为采用相同的过期时间导致的缓存雪崩。

如果真的发生了缓存雪崩，有没有什么兜底的措施？

2、使用**熔断机制**。当流量到达一定的阈值时，就直接返回“系统拥挤”之类的提示，防止过多的请求打在数据库上。至少能保证一部分用户是可以正常使用，其他用户多刷新几次也能得到结果。

3、提高数据库的**容灾能力**，可以使用分库分表，读写分离的策略。

4、为了防止Redis宕机导致缓存雪崩的问题，可以**搭建Redis集群，提高Redis的容灾性。**

### 缓存击穿

跟缓存雪崩有点类似，缓存雪崩是大规模的key失效，而缓存击穿是**一个热点的Key，有大并发集中对其进行访问**，突然间这个Key失效了，导致大并发全部打在数据库上，导致数据库压力剧增。这种现象就叫做缓存击穿。

**分析：**

关键在于某个热点的key失效了，导致大并发集中打在数据库上。所以要从两个方面解决，第一是否可以**考虑热点key不设置过期时间**，第二是否可以**考虑降低打在数据库上的请求数量。**

**解决方案：**

1、上面说过了，如果业务允许的话，对于热点的key可以设置**永不过期的key**。

2、**使用互斥锁。** 如果缓存失效的情况，只有拿到锁才可以查询数据库，降低了在同一时刻打在数据库上的请求，防止数据库打死。当然这样会导致系统的性能变差。
### 缓存穿透

**什么是缓存穿透？**

我们使用Redis大部分情况都是通过Key查询对应的值，假如**发送的请求传进来的key是不存在Redis中的，那么就查不到缓存，查不到缓存就会去数据库查询**。假如有大量这样的请求，这些请求像“穿透”了缓存一样直接打在数据库上，这种现象就叫做缓存穿透。

**分析：**

关键在于在Redis查不到key值，这和缓存击穿有根本的区别，区别在于**缓存穿透的情况是传进来的key在Redis中是不存在的**。

**解决方案：**

1、**把无效的Key存进Redis中**。如果Redis查不到数据，数据库也查不到，我们把这个Key值保存进Redis，设置value="null"，当下次再通过这个Key查询时就不需要再查询数据库。这种处理方式肯定是有问题的，假如传进来的这个不存在的Key值每次都是随机的，那存进Redis也没有意义。

2、**使用布隆过滤器，增加一层中间层**。布隆过滤器的作用是某个 key 不存在，那么就一定不存在，它说某个 key 存在，那么很大可能是存在(存在一定的误判率)。于是我们可以在缓存之前再加一层布隆过滤器，在查询的时候先去布隆过滤器查询 key 是否存在，如果不存在就直接返回。

## golang防缓存击穿神器【singleflight】
> [golang防缓存击穿神器【singleflight】 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/382965636)
## 布隆过滤器
布隆过滤器底层使用bit数组存储数据，该数组中的元素默认值是0。

布隆过滤器第一次初始化的时候，会把数据库中所有已存在的key，经过一些列的hash算法（比如：三次hash算法）计算，每个key都会计算出多个位置，然后把这些位置上的元素值设置成1。

使用布隆过滤器确实可以解决缓存穿透问题，但同时也带来了两个问题：

1. 误判：hash冲突是一种概率事件，随着数据量的增加，产生冲突的概率也会增加
2. 数据更新：修改或者删除数据

第一个问题，可以通过增加hash空间，增加hash层级 和 更换更复杂的hash算法

第二个问题，当有相同hash值时，我们就存计数值，不在存 bit位了，每次判断计数值是否非零就可以，但是这样就会带来存储空间的消耗。

## 设置空值

当我们请求数据中没有数据或者因为代码bug带来的异常造成的数据为空，这个时候我们就可以回写一个空值null到缓存中。同时，我们还要给这个null值设置过期时间，因为这个空值不具有实际业务性，而且还占用空间。

可见设置空值是可以阻挡大量穿透请求的，但是如果有大量的获取并不存在数据的穿透请求的话例如恶意攻击，则会浪费缓存空间，如果这种null值过量的话，还会淘汰掉本身缓存存在的数据，这就会使我们的缓存命中率下降。