## 什么情况下适合用redis
1. 缓存场景
2. 限速场景
3. 分布式锁
4. 消息队列
5. 排行榜
## redis为什么快
从内存存储、高效的数据结构、单线程模型、非阻塞 I/O和高效的内存管理来看
1. **内存存储**：内存的访问速度远远快于磁盘
2. **高效的数据结构**：如字符串、哈希表、列表、集合、有序集合
3. **单线程模型**：避免线程切换开销；无锁设计，避免了锁竞争和死锁等问题
4. **非阻塞 I/O**：多路复用技术
5. **内存管理**：内存回收策略：定期删除过期数据、惰性删除、内存淘汰等
## redis如何实现MQ
> [浅谈三种使用Redis实现MQ的方式_redis mq-CSDN博客](https://blog.csdn.net/qq_44377709/article/details/123411590)
> 
> 【动画学Redis消息队列，List，发布订阅，Stream实现及如何保证可靠性，消息确认机制】 https://www.bilibili.com/video/BV14t421j7Mb/?share_source=copy_web&vd_source=02e1fcde003194e9ed62527f120b831f

- **使用列表（List）实现简单队列**
- **使用发布 / 订阅（Pub/Sub）模式**
- **使用Stream**
### 使用列表（List）实现简单队列
LPUSH 结合 RPOP、或者 RPUSH 结合 LPOP来实现，使用**BRPOP**或者**BLOPO**来实现阻塞效果。

**优点：**
- 简单
- 消息延迟低
- 数据全局有序

**缺点：**
- 没有消息确认，需要再手动维护
- 不能重复消费，拿出后立刻删除
- 不支持分组，消息只能有一个消费者拿到
### 使用发布 / 订阅（Pub/Sub）模式
消费者可以订阅（SUBSCRIBE）一个或多个channel，生产者向对应channel发送（PUBLISH）消息后，所有订阅者都能收到相关消息。

**优点：**
- 可以一对多，一个消息可以发布到多个消费者

**缺点：**
- 没有消息确认，消息丢失，不能寻回
- 不能重复消费，拿出后立刻删除
- **不能持久化消息**
## 使用Stream
支持消息的持久化、支持自动生成全局唯一 ID、支持 ack 确认消息的模式、支持消费组模式等，让消息队列更加的稳定和可靠。

消费者加入消费组，同一个消息会发给所有消费者组，每个消费者组只有一个消费者能接受到消息

一条消息给一个消费者消费时，会将ID（时间戳-序列号）加入消费者组中的 **pending list**

消费者消费完成后，需要确认消息，然后移除组中的 **pending list**的对应数据，消费成功；如果一直没有确认，就会把消息给组中其他消费者，直到确认为止。

> 如果宕机消费者突然苏醒，重复发送了一个确认会怎么样？

因为已经被别的确认了，且移除了pending list中的对应数据，所以不会有什么影响。

又因为操作是 **幂等的**，所以业务角度也不会有问题

**优点：**
- 基本上已经有了一个消息中间件的雏形（消息可回溯、消息确认机制、阻塞读取、持久化、消费者组等等）
- 在简单的业务场景下推荐使用，减少维护消息队列的成本

**缺点：**
- 不够应对专业的，大规模的情况
