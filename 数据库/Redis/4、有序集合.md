## 内部实现
Zset 类型的底层数据结构是由**压缩列表或跳表**实现的：

- 如果有序集合的元素个数小于 128 个，并且每个元素的值小于 64 字节时，Redis 会使用**压缩列表**作为 Zset 类型的底层数据结构；
- 如果有序集合的元素不满足上面的条件，Redis 会使用**跳表**作为 Zset 类型的底层数据结构；
## 常用命令

|命令|介绍|
|---|---|
|ZADD key score1 member1 score2 member2 ...|向指定有序集合添加一个或多个元素|
|ZCARD KEY|获取指定有序集合的元素数量|
|ZSCORE key member|获取指定有序集合中指定元素的 score 值|
|ZINTERSTORE destination numkeys key1 key2 ...|将给定所有有序集合的交集存储在 destination 中，对相同元素对应的 score 值进行 SUM 聚合操作，numkeys 为集合数量|
|ZUNIONSTORE destination numkeys key1 key2 ...|求并集，其它和 ZINTERSTORE 类似|
|ZDIFF destination numkeys key1 key2 ...|求差集，其它和 ZINTERSTORE 类似|
|ZRANGE key start end|获取指定有序集合 start 和 end 之间的元素（score 从低到高）|
|ZREVRANGE key start end|获取指定有序集合 start 和 end 之间的元素（score 从高到底）|
|ZREVRANK key member|获取指定有序集合中指定元素的排名(score 从大到小排序)|
## 用法
```
redis-cli --raw
127.0.0.1:6379> ZADD result 680 清华 660 北大 650 复旦 640 浙大
127.0.0.1:6379> ZRANGE result 0 -1
浙大
复旦
北大
清华
127.0.0.1:6379> ZRANGE result 0 -1 WITHSCORES
浙大
640
复旦
650
北大
660
清华
680
127.0.0.1:6379> ZSCORE result 清华
680
127.0.0.1:6379> ZRANK result 清华
3
127.0.0.1:6379> REVRANK 清华
0
```
## 跳表的数据结构
**跳表是在链表基础上改进过来的，实现了一种「多层」的有序链表**

跳表的结构体如下

- **头尾指针**：分别指向了不同层级的首个节点
- 长度
- 总层级数

具体节点的结构：
- 值
- 权重
- 后向指针
- 层级数组（保存每层的**前向指针和跨度**）

通过这样的结构，让相邻每层在逻辑上实现节点数从上往下比例为 1：2 或者 1：3，实现 log N 的快速查找和修改

### 跳表节点层数设置
因为跳表的相邻两层的节点数量的比例会影响跳表的查询性能，所以需要一个比较严谨的算法让节点分布符合 1：2 ，才能实现快速修改和查询

Redis 则采用一种巧妙的方法是，**跳表在创建节点的时候，随机生成每个节点的层数**，并没有严格维持相邻两层的节点数量比例为 2 : 1 的情况。

具体的做法是，**跳表在创建节点时候，会生成范围为[0-1]的一个随机数，如果这个随机数小于 0.25（相当于概率 25%），那么层数就增加 1 层，然后继续生成下一个随机数，直到随机数的结果大于 0.25 结束，最终确定该节点的层数**。

这样的做法，相当于每增加一层的概率不超过 25%，层数越高，概率越低，层高最大限制是 64。

虽然我前面讲解跳表的时候，图中的跳表的「头节点」都是 3 层高，但是其实**如果层高最大限制是 64，那么在创建跳表「头节点」的时候，就会直接创建 64 层高的头节点**。