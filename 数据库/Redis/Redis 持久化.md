Redis 共有三种数据持久化的方式：

- **AOF 日志**：每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里；
- **RDB 快照**：将某一时刻的内存数据，以二进制的方式写入磁盘；
- **混合持久化方式**：Redis 4.0 新增的方式，集成了 AOF 和 RBD 的优点
## AOF 日志
Redis 在执行完一条写操作命令**后**，就会把该命令以追加的方式写入到一个文件里，然后 Redis 重启时，会读取该文件记录的命令，然后逐一执行命令的方式来进行数据恢复。

**Reids 先执行写操作命令后，才将该命令记录到 AOF 日志里的原因：**

- **避免额外的语法检查开销**
- **不会阻塞当前写操作命令的执行**：因为当写操作命令执行成功后，才会将命令记录到 AOF 日志。

当然，这样做也会带来风险：

- **数据可能会丢失：** 执行写操作命令和记录日志是两个过程，那当 Redis 在还没来得及将命令写入到硬盘时，服务器发生宕机了，这个数据就会有丢失的风险。
- **可能阻塞其他操作：** 由于写操作命令执行成功后才记录到 AOF 日志，所以不会阻塞当前命令的执行，但因为 AOF 日志也是在主线程中执行，所以当 Redis 把日志文件写入磁盘的时候，还是会阻塞后续的操作无法执行。
### 写回策略
1. Redis 执行完写操作命令后，会将命令追加到 server.aof_buf 缓冲区；
2. 然后通过 write() 系统调用，将 aof_buf 缓冲区的数据写入到 AOF 文件，此时数据并没有写入到硬盘，而是拷贝到了内核缓冲区 page cache，等待内核将数据写入硬盘；
3. 具体内核缓冲区的数据什么时候写入到硬盘，由内核决定。
![](https://cdn.xiaolincoding.com//mysql/other/98987d9417b2bab43087f45fc959d32a-20230309232253633.png)
### AOF 重写机制
如果当 AOF 日志文件过大就会带来性能问题，比如重启 Redis 后，需要读 AOF 文件的内容以恢复数据，**如果文件过大，整个恢复的过程就会很慢**；再比如操作系统对于文件的大小是有限制的，不可能无限制的让文件增长；

AOF 重写机制是在重写时，读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到「新的 AOF 文件」，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件。**相当于压缩了 AOF 文件，使得 AOF 文件体积变小了。**

虽然 AOF 重写后，日志文件会缩小，但是，要把整个数据库的最新数据的操作日志都写回磁盘，仍然是一个非常耗时的过程。这时，我们就要继续关注另一个问题了：重写会不会阻塞主线程？
### AOF 重写机制会阻塞主线程吗
和 AOF 日志由主线程写回不同，重写过程是由后台子进程 bgrewriteaof 来完成的，这也是为了避免阻塞主线程，导致数据库性能下降。
![](../../addition/Pasted%20image%2020250508110846.png)
#### 一个拷贝
每次执行重写时，主线程 fork 出后台的 bgrewriteaof 子进程。此时，fork 会把主线程的内存拷贝一份给 bgrewriteaof 子进程，这里面就包含了数据库的最新数据。然后，bgrewriteaof 子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。
#### 两个日志
**主进程日志缓冲区**：

因为主进程未阻塞，仍然可以处理新来的操作。此时，如果有写操作，主线程 Redis 会把这个操作需要记录的AOF日志写到它的缓冲区。这样一来，即使宕机了，这个 AOF 日志的操作仍然是齐全的，可以用于恢复。

**拷贝的子进程**

这个操作也会被写到重写日志的缓冲区。这样，重写日志也不会丢失最新的操作。等到拷贝数据的所有操作记录重写完成后，重写日志记录的这些最新操作也会写入新的 AOF 文件，以保证数据库最新状态的记录。此时，我们就可以用新的 AOF 文件替代旧文件了。
## RDB 快照
RDB 快照就是记录某一个瞬间的内存数据，记录的是实际数据，而 AOF 文件记录的是命令操作的日志，而不是实际的数据。

因此在 Redis 恢复数据时， RDB 恢复数据的效率会比 AOF 高些，因为直接将 RDB 文件读入内存就可以，不需要像 AOF 那样还需要额外执行操作命令的步骤才能恢复数据。
### 给哪些内存数据做快照？
当你给一个人拍照时，只用协调一个人就够了，但是，拍 100 人的大合影，却需要协调 100 个人的位置、状态，等等，这当然会更费时费力。

Redis 的快照是**全量快照**，也就是说每次执行快照，都是把内存中的「所有数据」都记录到磁盘中。所以执行快照是一个比较重的操作，如果频率太频繁，可能会对 Redis 性能产生影响。如果频率太低，服务器故障时，丢失的数据会更多。

对于 Redis 而言，它的单线程模型就决定了，**我们要尽量避免所有会阻塞主线程的操作**，所以，针对任何操作，我们都会提一个灵魂之问：“它会阻塞主线程吗?”RDB 文件的生成是否会阻塞主线程，这就关系到是否会降低 Redis 的性能。 Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave。
- save：在主线程中执行，会导致阻塞； 
- bgsave：创建一个子进程，专门用于写入 RDB 文件，避免了主线程的阻塞，这也是 Redis RDB 文件生成的默认配置。
### 快照时数据能修改吗?
为了快照而暂停写操作，肯定是不能接受的。所以这个时候，Redis 就会借助操作系统提供的写时复制技术（Copy-On-Write, COW），在执行快照的同时，正常处理写操作。

### 写时复制技术
因为创建子进程的时候，会复制父进程的页表，但是页表指向的物理内存还是一个，**所以如果主线程执行读操作，则主线程和 bgsave 子进程互相不影响**。
![](../../addition/Pasted%20image%2020250508112556.png)
如果主线程执行写操作，则被修改的数据会复制一份副本，然后在这个副本上进行修改，在这个过程中，**主线程仍然可以直接修改原来的数据，子进程可以不阻塞主进程继续执行快照**。

**发生了写时复制后，RDB 快照保存的是原本的内存数据**，而主线程刚修改的数据，是没办法在这一时间写入 RDB 文件的，只能交由下一次的 bgsave 快照。

### 多久执行一次快照


> **复制时的极端情况**：写操作，会导致当前被修改的数据的物理内存就会被复制一份 **，则此时的内存占用是原先的 2 倍**
> 
> 针对写操作多的场景，我们要留意下快照过程中内存的变化，防止内存被占满了。

可以做增量快照，所谓增量快照，就是指，做了一次全量快照后，后续的快照只对修改的数据进行快照记录，这样可以避免每次全量快照的开销。

内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。

这样一来，快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，AOF 日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。
## 混合持久化
RDB 优点是数据恢复速度快，但是快照的频率不好把握。频率太低，丢失的数据就会比较多，频率太高，就会影响性能。

AOF 优点是丢失数据少，但是数据恢复不快。

**优点**：

    混合持久化结合了 RDB 和 AOF 持久化的优点，开头为 RDB 的格式，使得 Redis 可以更快的启动，同时结合 AOF 的优点，有减低了大量数据丢失的风险。

**缺点**：

    AOF 文件中添加了 RDB 格式的内容，使得 AOF 文件的可读性变得很差；
    兼容性差，如果开启混合持久化，那么此混合持久化 AOF 文件，就不能用在 Redis 4.0 之前版本了。

## 故障恢复过程
### AOF 重放
当 Redis 服务器启动时，如果开启了 AOF 持久化功能并且 AOF 文件存在，Redis 会首先读取 AOF 文件。

 **AOF 日志恢复数据的方式是顺序执行日志里的每一条命令**

因为 Redis 执行命令由单线程负责的，所以如果 AOF 日志很大，这个【重放】的过程就会很慢了

> 如果在 AOF 文件恢复数据过程中有新的读取命令到来会怎么处理？

**加载阶段的阻塞式处理（初始恢复阶段）**：当 Redis 服务器启动并开始通过 AOF 文件恢复数据时，在这个阶段 Redis 是处于加载数据的过程中，它**通常会阻塞其他客户端的读取请求**。这是因为在数据尚未完全恢复之前，内存中的数据状态是不完整的，如果此时响应读取请求，可能会返回错误或不一致的数据。只有当 AOF 文件中的所有命令都成功重新执行后，Redis 才会开始正常接收和处理读取请求。

### RDB 重放
首先会打开 RDB 文件进行读取与解析，对于每个键值对，Redis 会根据其类型（如字符串、列表、集合、哈希等）进行恢复操作。以字符串类型键值对为例，Redis 会读取键和值的二进制表示，然后在内存中重新创建对应的字符串对象，并将键值对存储到相应的数据库空间中。

> 在恢复过程中，新来到的命令怎么处理

**阻塞式加载情况（默认情况）**：在 Redis 使用 RDB 文件恢复数据的默认过程中，Redis 是处于阻塞状态的。这意味着它在完成整个 RDB 文件的重放（数据恢复）之前，不会处理新的命令。所以如果有新的命令到来，这些命令会被阻塞等待，直到 RDB 文件中的数据全部恢复到内存中。

### 混合持久化重放
Redis 的混合持久化文件是一个二进制文件，它的开头部分是 RDB 格式的数据快照，记录了某个时刻数据库的完整状态，就像普通 RDB 文件一样。在 RDB 部分之后，是 AOF 格式的增量数据，记录了从 RDB 快照时刻之后的所有写命令。

- **RDB 部分重放**：
    - 首先，和单独的 RDB 文件重放过程类似，Redis 会读取混合持久化文件中的 RDB 部分。它会按照 RDB 文件的解析规则，读取文件头、数据库数量、键值对等信息。
- **AOF 部分重放**：
    - 在 RDB 部分重放完成后，Redis 会接着处理混合持久化文件中的 AOF 部分。AOF 部分的格式是 Redis 的文本协议格式，每个写命令都按照协议格式存储。
    - Redis 会逐行读取 AOF 部分的写命令，按照协议格式进行解析。
- **过期键处理**：
    - 在整个重放过程中，无论是 RDB 部分还是 AOF 部分涉及到的过期键，Redis 都会按照过期键的处理规则来操作。在 RDB 部分恢复时设置的过期时间，以及 AOF 部分可能包含的对过期键的操作（如删除过期键的命令），Redis 都会正确处理。
- **完成重放后的操作**：
    - 当混合持久化文件中的 RDB 和 AOF 部分全部重放完成后，Redis 的内存数据状态就恢复到了混合持久化文件记录的最新状态。此时，Redis 就可以正常接收和处理客户端的请求，包括读请求和写请求，并且可以根据内存中的数据状态和相关规则（如过期键规则）进行正常的操作。