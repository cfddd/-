> [MySQL 有哪些锁？ | 小林coding (xiaolincoding.com)](https://xiaolincoding.com/mysql/lock/mysql_lock.html)
> 
> [MySQL 是怎么加锁的？ | 小林coding (xiaolincoding.com)](https://xiaolincoding.com/mysql/lock/how_to_lock.html#%E4%BB%80%E4%B9%88-sql-%E8%AF%AD%E5%8F%A5%E4%BC%9A%E5%8A%A0%E8%A1%8C%E7%BA%A7%E9%94%81)
## 全局锁
MySQL全局锁是针对整个数据库的锁。最常用的全局锁是读锁和写锁。
- **读锁**(**共享锁**)：它阻止其他用户更新数据，但允许他们读取数据。这在你需要在一段时间内保持数据一致性时很有用。
- **写锁**(**排他锁**)：它阻止其他用户读取和更新数据。这在你需要修改一些大量的数据，并且不希望其他用户在这段时间内干扰时很有用。

> 全局锁是怎么用的？

```SQL
flush tables with read lock -- 全局读锁
```
### 使用场景
MVSQL全局锁的典型使用场景是，进行一些需要确保整个数据库一致性的操作，例如**全库备份、全库导出**等。

## 表级锁
### 表锁
如果我们想对学生表（t_student）加表锁，可以使用下面的命令：

```SQL
//表级别的共享锁，也就是读锁；
lock tables t_student read;

//表级别的独占锁，也就是写锁；
lock tables t_stuent write;
```
要释放表锁，可以使用下面这条命令，会释放当前会话的所有表锁：

```
unlock tables
```
#### 1.意向锁
**概念：** 意向锁是表锁，为了**协调行锁和表锁的关系**，支持多粒度(表锁与行锁)的锁并存

**作用**：当有事务A有行锁时，MVSQL会自动为该表添加意向锁，事务B如果想申请整个表的写锁，那
么不需要遍历每一行判断是否存在行锁，而直接判断是否存在意向锁，**增强性能**。

- 在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；
- 在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」；

**意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（_lock tables ... read_）和独占表锁（_lock tables ... write_）发生冲突。**

所以，**意向锁的目的是为了快速判断表里是否有记录被加锁**。

|            | 意向共享锁（IS） | 意向排他锁（IX） |
| ---------- | --------- | --------- |
| **共享锁（S）** | 共享        | 互斥        |
| **排他锁（X）** | 互斥        | 互斥        |
#### 2.AUTO-INC 锁
之后可以在插入数据时，可以不指定主键的值，**数据库会自动给主键赋值递增的值**

这主要是通过 **AUTO-INC 锁**实现的。
### 表级锁使用场景
1. **读密集型**、**写操作不频繁的场景**
2. **数据量不大的简单应用**
3. **全表更新或者删除**
### 表级锁风险点
- **性能下降**、**并发性能差**
- **锁阻塞，超时**
- **写操作影响大（写锁）**
- **死锁**
## 行级锁
InnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁

**行锁必须在开启事务中运行才有效**

如果要在查询时对记录加行级锁，可以使用下面这两个方式，这两种查询会加锁的语句称为**锁定读**。
```SQL
//对读取的记录加共享锁(S型锁)
select ... lock in share mode;

//对读取的记录加独占锁(X型锁)
select ... for update;
```
上面这两条语句必须在事务中，**因为当事务提交后，锁才会被释放**

除了上面这两条锁定读语句会加行级锁之外，**update 、 delete 和 insert 操作都会加行级锁，且锁的类型都是独占锁(X型锁)**。

```SQL
//对操作的记录加独占锁(X型锁)
update table .... where id = 1;

//对操作的记录加独占锁(X型锁)
delete from table where id = 1;
```
共享锁（S锁）满足读读共享，读写互斥。独占锁（X锁）满足写写互斥、读写互斥。
### 使用场景
- **高并发读写场景下，提供较好的并发控制**
- **单行操作**
- **处理复杂的事务**

### 行级锁风险
- **死锁**
- **锁升级**：InnoDB引擎下，如果一个事务锁定的行过多，锁可能会从行级锁升级为表级锁，可能会导致更多的锁冲突
- **资源损耗**：因为数据库行级锁的粒度更小，也就需要更多的资源和CPU时间来维护锁请求和存储，然后带来显著的资源消耗

### 行级锁有哪些种类？
在读已提交隔离级别下，行级锁的种类只有记录锁，也就是仅仅把一条记录锁上。

在可重复读隔离级别下，行级锁的种类除了有记录锁，还有间隙锁（目的是为了避免幻读），所以行级锁的种类主要有三类：

- Record Lock，**记录锁**，也就是仅仅把一条记录锁上；
- Gap Lock，**间隙锁**，锁定一个范围，但是不包含记录本身；
- Next-Key Lock：**Record Lock + Gap Lock 的组合**，锁定一个范围，并且锁定记录本身。

#### 记录锁
锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分的：

共享锁（S锁）满足读读共享，读写互斥。独占锁（X锁）满足写写互斥、读写互斥。

当事务执行 commit 后，事务过程中生成的锁都会被释放。

例如`for update`就是这种类型的锁
#### 间隙锁
只存在于可重复读隔离级别，目的是为了解决**可重复读隔离级别下幻读**的现象。

例如，范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id = 4 这条记录了，这样就有效的防止幻读现象的发生。

**间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的**。

> **间隙锁是如何解决幻读问题的**？【非常重要】

间隙锁的存在，主要是为了解决幻读问题。

所谓幻读，是指在**一个事务内读取某个范围的记录时，另外一个事务在该范围内插入了新的记录，当第一个事务再次读取该范围的记录时，会发现有些原本不存在的记录，这就是幻读。**

举例来说，假设我们有一个存储学生信息的表，有一个事务A要查询年龄在10-20之间的学生，它在查询前会对这个区间加锁。此时如果有另一个事务B想要插入一个年龄为15的学生由于这个年龄的范围已经被事务A锁定，所以事务B必须等待，直到事务A完成，释放锁。这样就避免了幻读的产生

> 间隙锁的**缺点**

- **性能问题**
- **死锁风险**
- **复杂性**
- **锁定范围可能过大**：间隙锁锁定的是索引之间的间隙，这可能会比实际需要锁定的行要多如果一个事务需要锁定的只是表中的一小部分行，但由于间隙锁的存在，可能会锁定更大范围的数据，导致不必要的锁定冲突。

#### 临键锁
##### 什么是临键锁

Record Lock + Gap Lock 的组合，锁定一个范围（**左开右闭**），并且锁定记录本身

例如，范围 id 为（3，5] 的 next-key lock，那么其他事务即不能插入 id = 4 记录，也不能修改和删除 id = 5 这条记录。

| id  | age | name |
| --- | --- | ---- |
| 1   | 10  | 张三   |
| 3   | 24  | 李四   |
| 5   | 32  | 王五   |
| 7   | 45  | 赵六   |
该表中 age 列潜在的临键锁有:
(-∞, 10],
(10,24]
(24, 32],
(32,45]

Next-Key 可以理解为一种特殊的间隙锁，也可以理解为一种特殊的算法。通过**临建锁可以解决幻读的问题**。每个数据行上的非唯一索引列上都会存在一把临键锁，当某个事务持有该数据行的临键锁时，**会锁住一段左开右闭区间的数据**。

**next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的**。

#### 插入意向锁
一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）。

如果有的话，插入操作就会发生**阻塞**，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个**插入意向锁**，表明有事务想在某个区间插入新记录，但是现在处于等待状态。

插入意向锁名字虽然有意向锁，但是它并**不是意向锁，它是一种特殊的间隙锁，属于行级别锁**。

## 乐观锁
数据库没有实现，一种思想

**使用场景**
1. 读多写少
	1. 冲突少
	2. 短事务场景

**乐观锁缺点**
1. 冲突开销
2. 版本管理较难：版本号
3. 编程复杂性

## 悲观锁

**使用场景**
1. 读少写多
2. 冲突多
3. 需要强一致性

**悲观锁缺点**
1. 性能开销
2. 并发度降低
3. 死锁
4. 锁超时
