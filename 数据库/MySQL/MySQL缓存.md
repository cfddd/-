> [揭开 Buffer Pool 的面纱 | 小林coding](https://xiaolincoding.com/mysql/buffer_pool/buffer_pool.html#buffer-pool-%E7%BC%93%E5%AD%98%E4%BB%80%E4%B9%88)
## Buffer Pool 是什么
Innodb 存储引擎设计了一个**缓冲池（_Buffer Pool_）**，来提高数据库的读写性能。

- 当读取数据时，如果数据存在于 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取。
- 当修改数据时，首先是修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页，最后由后台线程将脏页写入到磁盘。

## 缓存结构

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/innodb/bufferpool%E5%86%85%E5%AE%B9.drawio.png)

### **Buffer Pool 空间大小**

默认配置下 Buffer Pool 只有 `128MB`；可以通过调整 `innodb_buffer_pool_size` 参数来设置 Buffer Pool 的大小，一般建议设置成可用物理内存的 60%~80%。

## **缓存内容**

**InnoDB 会为 Buffer Pool 申请一片连续的内存空间**，把空间分为若干个「页」，以页作为磁盘和内存交互的基本单位，一个页的默认大小为 16KB。因此，Buffer Pool 同样需要按「页」来划分。

MySQL 刚启动的时候，你会观察到使用的虚拟内存空间很大，而使用到的物理内存空间却很小，这是因为只有这些虚拟内存被访问后，操作系统才会触发缺页中断，接着将虚拟地址和物理地址建立映射关系。

此时这些缓存页都是空闲的，之后随着程序的运行，才会有磁盘上的页被缓存到 Buffer Pool 中。

### **控制块**
为了更好的管理这些在 Buffer Pool 中的缓存页，InnoDB 为每一个缓存页都创建了一个**控制块**，控制块信息包括「缓存页的表空间、页号、缓存页地址、链表节点」等等。

控制块也是占有内存空间的，它是放在 Buffer Pool 的最前面，接着才是缓存页

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/innodb/%E7%BC%93%E5%AD%98%E9%A1%B5.drawio.png)
> **可能出现碎片问题**：内存会按页大小（16KB）划分和分配，如果给缓存空间设置的大小，**不是控制块和缓存页空间大小之和的整数倍**，就有可能产生碎片
## 缓存工作原理

当我们查询一条记录时，**InnoDB 是会把整个页的数据加载到 Buffer Pool 中**

因为，通过索引只能定位到磁盘中的页，而不能定位到页中的一条记录。将页加载到 Buffer Pool 后，再通过页里的页目录去定位到某条具体的记录。

### 找到空闲内存
Buffer Pool 使用链表结构，将空闲缓存页的「控制块」作为链表的节点，这个链表称为 **Free 链表**（空闲链表） 

**空闲链表**：
- **头节点**：包含链表的头节点地址，尾节点地址，以及当前链表中节点的数量
- **链表节点**：控制块的指针（控制块上有缓存页的地址），对应一个空闲的缓存页

有了 Free 链表后，**每当需要从磁盘中加载一个页到 Buffer Pool 中时，就从 Free 链表中取一个空闲的缓存页，并且把该缓存页对应的控制块的信息填上，然后把该缓存页对应的控制块从 Free 链表中移除**。

### 修改脏页内存

设计 Buffer Pool 除了能提高读性能，还能提高写性能，也就是更新数据的时候，不需要每次都要写入磁盘，而是将 Buffer Pool 对应的缓存页标记为**脏页**，然后再由后台线程将脏页写入到磁盘。

那为了能**快速知道哪些缓存页是脏的**，于是就设计出 **Flush 链表**，它跟 Free 链表类似的，链表的节点也是控制块，区别在于 **Flush 链表的元素都是脏页**。

有了 Flush 链表后，后台线程就可以遍历 Flush 链表，将脏页写入到磁盘。

### 内存淘汰策略
**基础算法**：LRU

Buffer Pool 里有三种页和链表来管理数据：
- **Free Page（空闲页）**：表示此页未被使用，位于 Free 链表；
- **Clean Page（干净页）**：表示此页已被使用，但是页面未发生修改，位于LRU 链表。
- **Dirty Page（脏页）**：表示此页「已被使用」且「已经被修改」，其数据和磁盘上的数据已经不一致。当脏页上的数据写入磁盘后，内存数据和磁盘数据一致，那么该页就变成了干净页。脏页同时存在于 LRU 链表和 Flush 链表。

### 简单LRU算法在MySQL缓存中存在的问题
简单的 LRU 算法并没有被 MySQL 使用，因为简单的 LRU 算法无法避免下面这两个问题：

- 预读失效
- Buffer Pool 污染
#### 预读失效
首先介绍什么是 **【预读机制】**：
- 程序是有空间局部性的，靠近当前被访问数据的数据，在未来很大概率会被访问到。
- 所以，MySQL 在加载数据页时，**会提前把它相邻的数据页一并加载进来**，目的是为了减少磁盘 IO。

但是，当**被提前加载进来的数据页，并没有被访问**，会产生一定的资源浪费，这被称为**预读失效**

在LRU中，让不会被访问的数据存在链表靠前的位置，显然不太合理

#### 【重点】预读失效的解决方案
要避免，或者减小预读失效带来影响，最好就是**让预读的页停留在 Buffer Pool 里的时间要尽可能的短，让真正被访问的页才移动到 LRU 链表的头部，从而保证真正被读取的热数据留在 Buffer Pool 里的时间尽可能长**。

MySQL改进了 LRU 算法，将 LRU 划分了 2 个区域：
- **old 区域**
	- 在 LRU 链表的**后半部分**，放【**预读的页**】，提高被移除的效率，同时在真正被访问到的时候才会放到 **young 区域** 最前面
-  **young 区域**
	- 在 LRU 链表的**前半部分**，

整个 LRU 链表长度的比例可以通过 `innodb_old_blocks_pct` 参数来设置，默认是 37，代表整个 LRU 链表中 young 区域与 old 区域比例是 63:37
#### Buffer Pool 污染
当某一个 SQL 语句**扫描了大量的数据**时，在 Buffer Pool 空间比较有限的情况下，可能会将 **Buffer Pool 里的所有页都替换出去，导致大量热数据被淘汰了**，等这些热数据又被再次访问的时候，由于缓存未命中，就会产生大量的磁盘 IO，MySQL 性能就会急剧下降，这个过程被称为 **Buffer Pool 污染**。

> **并不只有读取全部数据才会加载到 Buffer Pool 中**
> 
> 当索引失效时，造成全表扫描的数据，也会被加载到缓存中，**产生污染问题**

#### 【重点】Buffer Pool 污染的解决方案
问题可以抽象为：**LRU中young区热点数据被频繁替换**

于是，MySQL**提高进入到 young 区域的门槛**，就能有效地保证 young 区域里的热点数据不会被替换掉，在数据进入到 young 区域条件增加了一个**停留在 old 区域的时间判断**。

在对某个处在 old 区域的缓存页进行第一次访问时，就在它对应的控制块中记录下来这个**访问时间**：
- 如果后续的访问时间与第一次访问的时间**在某个时间间隔内**，那么**该缓存页就不会被从 old 区域移动到 young 区域的头部**；
- 如果后续的访问时间与第一次访问的时间**不在某个时间间隔内**，那么**该缓存页移动到 young 区域的头部**；

这个间隔时间是由 `innodb_old_blocks_time` 控制的，默认是 1000 ms。

也就说，**只有同时满足「被访问」与「在 old 区域停留时间超过 1 秒」两个条件，才会被插入到 young 区域头部**，这样就解决了 Buffer Pool 污染的问题 。

另外，MySQL 针对 young 区域其实做了一个优化，为了防止 young 区域节点频繁移动到头部。young 区域前面 1/4 被访问不会移动到链表头部，只有后面的 3/4被访问了才会。

### 脏页写入硬盘时机
脏页需要被刷入磁盘，保证缓存和磁盘数据一致，但是若每次修改数据都刷入磁盘，则性能会很差，因此一般都会在一定时机进行批量刷盘。

InnoDB 的更新操作采用的是 Write Ahead Log 策略，即先写日志，再写入磁盘，通过 redo log 日志让 MySQL 拥有了崩溃恢复能力。

下面几种情况会触发脏页的刷新：

- 当 redo log 日志满了的情况下，会主动触发脏页刷新到磁盘；
- Buffer Pool 空间不足时，需要将一部分数据页淘汰掉，如果淘汰的是脏页，需要先将脏页同步到磁盘；
- MySQL 认为空闲时，后台线程会定期将适量的脏页刷入到磁盘；
- MySQL 正常关闭之前，会把所有的脏页刷入到磁盘；

在我们开启了慢 SQL 监控后，如果你发现 **「偶尔」会出现一些用时稍长的 SQL**，这可能是因为脏页在刷新到磁盘时可能会给数据库带来性能开销，导致数据库操作抖动。

如果间断出现这种现象，就需要调大 Buffer Pool 空间或 redo log 日志的大小。