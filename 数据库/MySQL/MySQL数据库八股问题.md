## 数据库的索引类型有哪些
> [MySQL（三）：索引的种类 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/643607125)

### 小结
| 从逻辑功能划分             | 从物理实现划分    | 从作用字段划分   |
| ------------------- | ---------- | --------- |
| 普通索引、唯一索引、主键索引、全文索引 | 聚簇索引、非聚簇索引 | 单列索引、联合索引 |
## 数据库索引的回表
> [在Mysql中，什么是回表，什么是覆盖索引，索引下推？ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/401198674)

## 索引失效的场景

> [MySQL索引失效的7种情况及使用建议 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/361172794)
> 
> [15个必知的Mysql索引失效场景，别再踩坑了-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1992920)


1. where中索引列有or;
2. 复合索引未用左列字段;
3. 使用了 `*`;
4. like以%开头;
5. 需要类型转换（例如varchar和int不加区分，需要转换）;
6. where中索引列有运算;
7. where中索引列使用了函数;
8. 两列做比较（例如id，age有索引，但是查询id < age）
9. 不等于比较`<>`，结果集占比较大时索引会失效
10. is not null（is null时正常走索引）
11. not in和not exists
12. order by（容易全表扫描）
13. 
14. 如果mysql觉得全表扫描更快时（数据少）;
## 不推荐使用索引的场景
1. 唯一性差;
2. 频繁更新的字段不用（更新索引消耗）;
3. where中不用的字段;
## MySQL一张表最多能存多少数据
MySQL InnoDB的表使用[聚簇索引](https://zhida.zhihu.com/search?q=%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95&zhida_source=entity&is_preview=1)，索引每页（Page）16K，假设主键是long，占用8字节。在使用额外6字节内存指向数据的位置。一个主键在索引中占用14字节。每个页存索引条目数： 16*1024/(8+6)=1170.28571 （大致计算，忽略索引页中可能还要存其它数据）

MySQL的B+树叶子节点存数据，假设一条记录是1K，那么叶子结点可以存16条数据。

然后3层高度的[B+树](https://zhida.zhihu.com/search?q=B%2B%E6%A0%91&zhida_source=entity&is_preview=1)的记录条数为：1170*1170 *16=21902400 大约两千万条记录。

然后依据这个，得到MySQL单表两千万的结论。

## 出现慢sql怎么排查优化
[字节面试官：一条sql执行慢的原因？如何优化？ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/409390845)

[慢查询 MySQL 定位优化技巧，从10s优化到300ms - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/569075677)

## 秒杀接口【使用Redis+MQ设计】
- 用户发起秒杀请求，首先查询 Redis 中的库存数量。如果库存充足，扣减 Redis 中的库存，并将订单信息发送到 MQ 中。如果库存不足，返回秒杀失败的信息。
- 后台消费者从 MQ 中读取订单消息，进行订单的处理，包括写入数据库、更新库存等操作。如果在处理订单过程中发现库存不足（可能由于并发问题导致 Redis 中的库存扣减不准确），可以进行回滚操作，或者向用户发送库存不足的通知。

## 数据库单表数据只能有2kw？
> [为什么说mysql数据库单表最大两千万？依据是啥？_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV13s4y1N724/?spm_id_from=333.337.search-card.all.click&vd_source=2d885cb62bb9393fa8a5379c72eabd82)

- 叶子节点和非叶子节点的大小是相同的
- 只有叶子节点存放数据，非叶子节点是不存放数据的
- 每个节点的大小是16KB，每个叶子结点在磁盘上的存储是独立的，所以每次索引都有可能要进行磁盘IO，将数据加载进内存

B+树数据计算公式：**$X^{Y - 1}*Z$**
- 其中$X$ = 非叶子节点索引个数
- $Y$ = B+树层级
- $Z$ = 叶子节点存储数据行数

2kw的数据是当每个行数据大小是1kb时计算得出的结果，$Y = 4$，B+树有三层索引，当超过这个数据后可能会导致索引层级增加，随之IO的次数也会增加，导致耗时显著增加，特别是在数据量很大的情况下

但是这不代表每每张表都会固定给一行1kb存储空间

如果一张表很 **窄** ，即数据列很少，每行数据大小也很少，那么 $X$ 和 $Z$ 就会增大，如果继续保持$Y = 4$，三层索引，可能数据是会超过1亿条甚至更多

所以具体应该通过理论上的大致计算，和实际对数据库进行压测来决定单表的行数

再加上数据库其实自带有缓存，很多情况下并不是数据库算法达到了上限，而是机器内存不够导致频繁地换出，导致CPU飚高

## 如何通过数据库实现乐观锁和悲观锁
虽然数据库没有直接可以使用的乐观锁和悲观锁，但是我们可以自己实现，甚至对于其他的来说也是一样的
### 乐观锁
类似CAS机制，给需要保护的资源表，加上一个版本号列，递增且唯一

每次先查询待修改记录的版本号 version，在修改时，当且仅当版本号相同才可以修改

判断是否拿到锁可以通过，修改语句条数来确定（版本号被别的锁修改了，那没有拿到锁的修改语句就修改 0 条）

```sql
select 
	version
from goods
where id = 1;
-- 假设查询出来是 x 
update 
	goods_name = 'cfd0',
	version = version + 1
from goods
where id = 1 and version = x;
-- 会有一个查询结果，affected rows = ?，非0就可以表示拿到锁，反之没拿到
```

最后一步，没拿到锁进行重试，需要设置一个比较合理的等待时间

但是这样存在一些比较严重的问题：
- 频繁的数据库IO，操作过慢，而且可能产生大量无意义的查询操作
- 编写代码繁琐，不易用
### 悲观锁
#### 排它锁

开启事务，要么全部成功提交，要么全部回滚。

在进行关键数据的操作前，尝试获取排它锁。**排它锁也称为写锁，它会阻止其他事务同时对同一数据进行读取或写入操作。**

在 MySQL 的 InnoDB 存储引擎中，可以使用`SELECT... FOR UPDATE`语句来获取排它锁

最后执行完所有操作之后，就可以提交了

```sql
START TRANSACTION; -- 开启事务

SELECT * FROM goods WHERE id = 1 FOR UPDATE; -- 这个语句会选择`id`为 1 的行，并对其加排它锁。

UPDATE goods SET name = 'cfd' WHERE id = 1; -- 锁内操作

COMMIT; -- 结束事务
```
#### 共享锁

同样的，需要先开启事务

在进行只读操作前，尝试获取共享锁。**共享锁也称为读锁，它允许多个事务同时对同一数据进行读取操作，但阻止其他事务对该数据进行写入操作。**

后续操作和前面基本是一样的

```sql
START TRANSACTION; -- 开启事务

SELECT * FROM goods WHERE id = 1 lock in share mode; -- 这个语句会选择`id`为 1 的行，并对其加共享锁。

UPDATE goods SET name = 'cfd' WHERE id = 1; -- 锁内操作

COMMIT; -- 结束事务
```

操作完成后，根据情况提交或回滚事务。如果提交事务，共享锁会被释放；如果回滚事务，所有的操作都会被撤销，共享锁也会被释放。

## 如何解决/降低主从数据库同步延迟问题
> [主从不一致解决方案 && 如何降低主从延迟-阿里云开发者社区 (aliyun.com)](https://developer.aliyun.com/article/1169490)
> 
> [(2 封私信 / 16 条消息) 如何解决主从数据库同步延迟问题？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/20025096)

**一、优化主库写入性能**
1. 合理设计索引：避免过多或不必要的索引，因为索引会增加写入操作的开销。只在必要的列上创建索引，并根据查询需求选择合适的索引类型。
2. 批量写入：将多个写入操作合并为一个批量操作，减少单个写入操作的次数。例如，可以使用事务将多个插入、更新或删除操作打包在一起执行。
3. 避免大事务：大事务会占用较长时间的锁，导致从库同步延迟。尽量将事务拆分为较小的事务，以减少对数据库的锁定时间。

**二、调整从库参数**
1. 提高从库的 I/O 和 SQL 线程性能：可以通过增加从库的硬件资源（如 CPU、内存、磁盘 I/O）来提高从库的处理能力。同时，可以调整从库的参数，如`innodb_flush_log_at_trx_commit`、`sync_binlog`等，以优化从库的写入性能。
2. 调整从库的复制模式：根据实际情况选择合适的复制模式。例如，可以使用基于行的复制（row-based replication）或基于语句的复制（statement-based replication）。基于行的复制在某些情况下可以减少同步延迟，但会消耗更多的磁盘空间和网络带宽。
3. 增加从库数量：如果主库的写入压力较大，可以考虑增加从库的数量，以分担读取负载，减少单个从库的同步压力。

**三、网络优化**
1. 确保主从库之间的网络连接稳定：使用高速、低延迟的网络连接，避免网络拥塞和丢包。可以使用专用网络或优化网络配置，以提高网络性能。
2. 调整网络参数：根据网络环境和数据库的需求，调整网络参数，如 TCP/IP 缓冲区大小、网络超时时间等。

**四、监控和诊断**
1. 实时监控主从库的同步状态：使用数据库监控工具或自定义脚本，实时监控主从库之间的同步延迟、I/O 和 SQL 线程的状态、网络流量等指标。及时发现同步延迟问题，并采取相应的措施。
2. 分析慢查询和错误日志：定期分析主从库的慢查询日志和错误日志，查找可能导致同步延迟的问题。例如，慢查询可能会占用从库的大量资源，导致同步延迟。

**五、数据库架构优化**
1. 读写分离：将读取操作分发到从库，写入操作只在主库上进行。这样可以减轻主库的读取压力，提高从库的同步性能。可以使用数据库中间件或代理来实现读写分离。
2. 数据分区：如果数据库中的数据量较大，可以考虑对数据进行分区。将数据分散到不同的物理存储设备上，减少单个数据库服务器的负载，提高同步性能。