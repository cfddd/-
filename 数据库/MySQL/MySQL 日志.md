> [MySQL 日志：undo log、redo log、binlog 有什么用？ | 小林coding (xiaolincoding.com)](https://www.xiaolincoding.com/mysql/log/how_update.html)
> 
> 【动画讲解：MySQL两大内存BufferPool、RedoLogBuffer和三大日志binlog、redolog和undolog】 https://www.bilibili.com/video/BV1Dr4y197ai/?share_source=copy_web&vd_source=02e1fcde003194e9ed62527f120b831f
> 
> [一文搞懂MySQL各种日志-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/2339983)
> 
> [MySQL中都有哪些日志文件？_数据库日志文件中包含哪些内容-CSDN博客](https://blog.csdn.net/lveex/article/details/118873638)


## MySQL 三大日志 undo log、redo log、binlog 有什么用
- **undo log（回滚日志）**：是 Innodb 存储引擎层生成的日志，实现了事务中的**原子性**，主要**用于事务回滚和 MVCC**。
- **redo log（重做日志）**：是 Innodb 存储引擎层生成的日志，实现了事务中的**持久性和一致性**，主要**用于掉电等故障恢复**；
- **binlog （归档日志）**：是 Server 层生成的日志，主要**用于数据备份和主从复制**；
### MySQL 系统日志架构设计
![](http://douyin.cfddfc.online/myPicture/20240131223701.png)
_图片来自[动画讲解：MySQL两大内存BufferPool、RedoLogBuffer和三大日志binlog、redolog和undolog_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Dr4y197ai/?spm_id_from=pageDriver&vd_source=2d885cb62bb9393fa8a5379c72eabd82)_
### undo log
**undo log（回滚日志），它保证了事务的 ACID 特性中的原子性（Atomicity）**。

undo log 是一种用于撤销回退的日志。在事务没提交之前，MySQL 会先**记录更新前的数据**到 undo log 日志文件里面，当事务回滚时，可以利用 undo log 来进行回滚。

在发生回滚时，读取 undo log 里的数据，然后做**原先相反操作**，**将数据恢复到事务开始之前的状态**。

> **MVCC**：事务未提交之前，Undo Log保存了未提交之前的版本数据，Undo Log中的数据可作为数据旧版本快照供其他并发事务进行**快照读**。事务A手动开启事务，执行更新操作，首先会把更新命中的数据备份到 Undo Buffer 中。事务B手动开启事务，执行查询操作，会读取 Undo 日志数据返回，进行快照读。
> ![](https://img-blog.csdnimg.cn/20210718104951377.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hzZjE1NzY4NjE1Mjg0,size_16,color_FFFFFF,t_70)
### redo Log
#### 概念
用于恢复数据库在发生故障时的**持久性和一致性**状态，可以在崩溃修复期间纠正不完整事务写入的数据。

**当事务提交时，它的修改会首先写入redo log，然后再写入数据库文件。**

在数据库崩溃后，通过重放redo log中的操作，可以将数据库还原到最后一次提交的状态，确保数据的**持久性和一致性**。
#### 原理
**Undo Log是在事务开启的时候产生，而Redo Log是在事务执行的过程产生。**

在事务提交时会将产生Redo Log写入Log Buffer，但并不是随着事务的提交就立刻写入磁盘，而是等到事务操作的脏页写入到磁盘之后，Redo Log占用的空间就可以重用（被覆盖写入）。

Redo Log文件内容是以顺序循环的方式写入文件，写满时则回溯到第一个文件，进行覆盖写。
![](https://img-blog.csdnimg.cn/20210718111840875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hzZjE1NzY4NjE1Mjg0,size_16,color_FFFFFF,t_70#pic_center)
如上图所示，**Redo Log采用双指针进行维护。** Write Pos是当前记录的位置，一边写一边后移，写到最后一个文件末尾后就回到0号文件开头；CheckPoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件；

Write Pos和CheckPoint之间还空着的部分，可以用来记录新的操作。

如果Write Pos追上CheckPoint，表示写满，这时候不能再执行新的更新，会停下来先擦掉一些记录。如图：W区则是可以写入的区域，R区则是需要刷盘的内容。

**这时 MySQL 不能再执行新的更新操作，也就是说 MySQL 会被阻塞**（因此所以针对并发量大的系统，适当设置 redo log 的文件大小非常重要），此时会停下来将 Buffer Pool 中的脏页刷新到磁盘中，然后标记 redo log 哪些记录可以被擦除，接着对旧的 redo log 记录进行擦除，等擦除完旧记录腾出了空间，checkpoint 就会往后移动（图中顺时针），然后 MySQL 恢复正常运行，继续执行新的更新操作。

#### 什么时候刷入磁盘
redo log 也有自己的缓存—— redo log buffer，每当产生一条 redo log 时，会先写入到 redo log buffer，后续在持久化到磁盘

主要有下面几个时机：  
1. MySQL 正常关闭时； 
2. 当 redo log buffer 中记录的写入量大于 redo log buffer 内存空间的一半时，会触发落盘； 
3. InnoDB 的后台线程每隔 1 秒，将 redo log buffer 持久化到磁盘。 
4. 每次事务提交时都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘（这个策略可由 **innodb_flush_log_at_trx_commit** 参数控制，下面会说）。

这三个参数的数据安全性和写入性能的比较如下：  
- **数据安全性**：参数 1 > 参数 2 > 参数 0 
- **写入性能**：参数 0 > 参数 2> 参数 1 

所以，数据安全性和写入性能是熊掌不可得兼的，要不追求数据安全性，牺牲性能；要不追求性能，牺牲数据安全性。
### binlog
记录数据库的**所有 修改 操作**，包括对数据的**增删改操作**，以及对**表结构的修改**。

Binlog主要用于实现数据库的**复制**、**恢复**和增量备份。

通过分析Binlog，可以重放数据库的修改操作，实现主从复制和其他数据复制方案。

> **复制：** 目前我们常说的高可用/高并发，那数据库的高可用/高并发就可以通过各个数据库实例之间复制binlog以达到数据的同步。**如mysql的主从复制**
> 
> **恢复：** 某些数据可以通过执行binlog来恢复。

#### 主从复制的主要步骤
1. **写入Binlog：** MySQL 主库在收到客户端提交事务的请求之后，会先写入 binlog，再提交事务，更新存储引擎中的数据，事务提交完成后，返回给客户端“操作成功”的响应。 
2. **同步Binlog**： 从库会创建一个专门的 I/O 线程，连接主库的 log dump 线程，来接收主库的 binlog 日志，再把 binlog 信息写入 relay log 的中继日志里，再返回给主库“复制成功”的响应。 
3. **回放Binlog**： 从库会创建一个用于回放 binlog 的线程，去读 relay log 中继日志，然后回放 binlog 更新存储引擎中的数据，最终实现主从的数据一致性。
#### MySQL 主从复制主要模型

主要有三种：  
- **同步复制**：MySQL 主库提交事务的线程要等待所有从库的复制成功响应，才返回客户端结果。这种方式在实际项目中，基本上没法用，原因有两个：一是性能很差，因为要复制到所有节点才返回响应；二是可用性也很差，主库和所有从库任何一个数据库出问题，都会影响业务。 
- **异步复制（默认模型**）：MySQL 主库提交事务的线程并不会等待 binlog 同步到各从库，就返回客户端结果。这种模式一旦主库宕机，数据就会发生丢失。 
- **半同步复制**：MySQL 5.7 版本之后增加的一种复制方式，介于两者之间，事务线程不用等待所有的从库复制成功响应，只要一部分复制成功响应回来就行，比如一主二从的集群，只要数据成功复制到任意一个从库上，主库的事务线程就可以返回给客户端。这种**半同步复制的方式，兼顾了异步复制和同步复制的优点，即使出现主库宕机，至少还有一个从库有最新的数据，不存在数据丢失的风险。**
#### 什么时候刷盘
事务执行过程中，先把日志写到 binlog cache（Server 层的 cache），事务提交的时候，再把 binlog cache 写到 binlog 文件中。

MySQL提供一个 sync_binlog 参数来控制数据库的 binlog 刷到磁盘上的频率：  
- **sync_binlog = 0 （默认）** 的时候，表示每次提交事务都只 write，不 fsync，后续交由操作系统决定何时将数据持久化到磁盘； 
- **sync_binlog = 1** 的时候，表示每次提交事务都会 write，然后马上执行 fsync； 
- **sync_binlog =N(N>1)** 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。
## 一条 Update 语句更新后发生了什么？
当优化器分析出成本最小的执行计划后，执行器就按照执行计划开始进行更新操作。  

具体更新一条记录 UPDATE t_user SET name = 'xiaolin' WHERE id = 1; 

的流程如下:  
1. 执行器负责具体执行，会调用存储引擎的接口，通过主键索引树搜索获取 id = 1 这一行记录： 
	- 如果 id=1 这一行所在的数据页本来就在 buffer pool 中，就直接返回给执行器更新；
	- 如果记录不在 buffer pool，将数据页从磁盘读入到 buffer pool，返回记录给执行器。
2. 执行器得到聚簇索引记录后，会看一下更新前的记录和更新后的记录是否一样： 
	- 如果一样的话就不进行后续更新流程； 
	- 如果不一样的话就把更新前的记录和更新后的记录都当作参数传给 InnoDB 层，让 InnoDB 真正的执行更新记录的操作；
3. 开启事务， InnoDB 层更新记录前，**首先要记录相应的 undo log**，因为这是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面，**不过在内存修改该 Undo 页面后，需要记录对应的 redo log。** 
4. **InnoDB 层开始更新记录，会先更新内存（同时标记为脏页），然后将记录写到 redo log 里面，这个时候更新就算完成了。** 为了减少磁盘I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。这就是 WAL 技术，MySQL 的写操作并不是立刻写到磁盘上，而是先写 redo 日志，然后在合适的时间再将修改的行数据写到磁盘上。 
5. 至此，一条记录更新完了。 
6. 在一条更新语句执行完成后，**然后开始记录该语句对应的 binlog**，此时记录的 binlog 会被保存到 binlog cache，并没有刷新到硬盘上的 binlog 文件，**在事务提交时才会统一将该事务运行过程中的所有 binlog 刷新到硬盘。** 
7. 事务提交，剩下的就是「两阶段提交」的事情了。

## 两阶段提交
为什么需要两阶段提交？

事务提交后，redo log 和 binlog 都要持久化到磁盘，但是这两个是独立的逻辑，可能出现**半成功**的状态，这样就造成两份日志之间的逻辑不一致。

【**半成功状态**】：redo log 和 binlog 其中之一刷写磁盘成功，另一个失败，产生的不一致现象

**MySQL 为了避免出现两份日志之间的逻辑不一致的问题**，使用了「两阶段提交」来解决，两阶段提交其实是分布式事务一致性协议，它可以保证多个逻辑操作要不全部成功，要不全部失败，不会出现半成功的状态。

两阶段提交把单个事务的提交拆分成了 2 个阶段，分别是「准备（Prepare）阶段」和「提交（Commit）阶段」，每个阶段都由协调者（Coordinator）和参与者（Participant）共同完成。注意，不要把提交（Commit）阶段和 commit 语句混淆了，commit 语句执行的时候，会包含提交（Commit）阶段。 

举个拳击比赛的例子，两位拳击手（参与者）开始比赛之前，裁判（协调者）会在中间确认两位拳击手的状态，类似于问你准备好了吗？  
- **准备阶段**：裁判（协调者）会依次询问两位拳击手（参与者）是否准备好了，然后拳击手听到后做出应答，如果觉得自己准备好了，就会跟裁判说准备好了；如果没有自己还没有准备好（比如拳套还没有带好），就会跟裁判说还没准备好。
- **提交阶段**：如果两位拳击手（参与者）都回答准备好了，裁判（协调者）宣布比赛正式开始，两位拳击手就可以直接开打；如果任何一位拳击手（参与者）回答没有准备好，裁判（协调者）会宣布比赛暂停，对应事务中的回滚操作。

> [MySQL 日志：undo log、redo log、binlog 有什么用？ | 小林coding](https://xiaolincoding.com/mysql/log/how_update.html#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E7%9A%84%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84)
## 其他日志
### 错误日志（error log）
记录MySQL 运行过程中较为严重的警告和错误信息，以及MySQL每次启动和关闭的详细信息，默认是开启的。

通过`show variables like '%log_error%'`查看。
### 中继日志（relay log）
中继日志主要是MySQL**主从同步**的时候会用到，在从库中担当类似中转的作用。

主从同步主要分成三步：
1：主库将数据库的变更操作记录到Binlog日志文件中
2：从库读取主库中的Binlog日志文件信息写入到从库的Relay Log中继日志中
3：从库读取中继日志信息在从库中进行Replay，更新从库数据信息

> 更具体的主从复制可以看这个[这次终于把MySQL主从复制总结全面了！！！-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1822790)
> 1. master 服务器会将 SQL 记录通过多 dump 线程写入到 binary log 中。
> 2. slave 服务器开启一个 io thread 线程向服务器发送请求，向 master 服务器请求 binary log。master 服务器在接收到请求之后，根据偏移量将新的 binary log 发送给 slave 服务器。
> 3. slave 服务器收到新的 binary log 之后，写入到自身的 relay log 中，这就是所谓的中继日志。
> 4. slave 服务器，单独开启一个 sql thread 读取 relay log 之后，写入到自身数据中。

#### **为什么从库读取主库中的Binlog日志为什么不直接执行，而是先写入到Relay Log后面由读出来？**

1. **异步复制：** 主从复制通常是异步进行的，即从库的更新不需要等待主库执行完毕。直接执行主库的Binlog日志可能导致从库执行速度不如主库，从而导致复制延迟。通过先将主库的Binlog日志写入Relay Log，可以在从库自行决定何时以何种速度执行这些日志，使得从库的执行速度不受主库的限制。
    
2. **执行的灵活性：** 将主库的Binlog日志写入Relay Log后，从库可以在执行之前进行一些额外的处理，例如过滤不需要的操作、改变执行顺序等。这为从库提供了更大的灵活性，可以根据实际需求对复制的行为进行定制。
    
3. **缓冲和存储：** 将主库的Binlog日志写入Relay Log可以起到缓冲的作用，即使从库暂时失去与主库的连接，也能够在重新连接后继续执行。此外，Relay Log的使用也允许从库存储其自己的二进制日志，这样就可以再次被其他从库用作主库进行级联复制。
    
4. **安全性考虑：** 将主库的Binlog日志写入Relay Log提供了一种更为安全的方式，从库可以在写入Relay Log之前对Binlog进行一些检查和验证，确保复制的数据的完整性和正确性。
    

总的来说，通过引入Relay Log，MySQL的主从复制系统更具有灵活性、可定制性和容错性，从而适应不同的应用场景和需求。

### 慢查询日志
慢查询日志用于记录执行时间超过一定阈值的查询语句。**通过分析慢查询日志，可以识别执行时间较长的查询。**
1. **启用和配置：**
   - 默认情况下，慢查询日志是禁用的。要启用慢查询日志，需要在MySQL的配置文件中进行相应的配置。
   - 通过设置慢查询的时间阈值（`long_query_time`），可以定义哪些查询被认为是慢查询。
   - 可以通过`show variables like '%slow_query%'`查看是否开启和日志的位置

3. **分析工具：**
   - MySQL提供了一些工具用于分析慢查询日志，如`mysqldumpslow`和`pt-query-digest`。这些工具可以帮助用户汇总和分析慢查询日志，找出执行时间最长的查询。

4. **用途和优势：**
   - **性能优化：** 通过检查慢查询日志，可以识别哪些查询语句执行时间过长，从而进行性能优化，优化的方式可能包括索引的添加、查询语句的调整等。
   - **故障排查：** 慢查询日志也可用于故障排查，例如查找某些查询语句导致的**锁等待或死锁**情况。
   - **合理设置阈值：** 设置适当的慢查询时间阈值对于平衡性能分析和减少日志量至关重要。如果设置得太低，可能会记录过多的查询，占用过多磁盘空间。

5. **安全性：**
   - 由于慢查询日志可能包含敏感信息，如密码等，因此在生产环境中需要谨慎处理日志文件的访问权限和存储位置。
