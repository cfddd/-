> [面试必杀技，讲一讲Spring中的循环依赖 - 明智说 - 博客园 (cnblogs.com)](https://www.cnblogs.com/daimzh/p/13256413.html)
> 
> [一看就懂，图解 Spring 循环依赖，写得老好了！ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/143536005)


## 什么是循环依赖
1. 两个对象之间相互依赖
2. 多个对象之间相互依赖
3. 单个对象依赖自己

最简单的单例 Bean 可以假想是有一个一级缓存，存放着所有的 Bean 单例，这显然没办法解决循环依赖问题
## 三级缓存
| 缓存级别                            | 作用                                 |
| ------------------------------- | ---------------------------------- |
| **三级缓存**（singletonFactories）    | 提前暴露的一个单例工厂，二级缓存中存储的就是从这个工厂中获取到的对象 |
| **二级缓存**（earlySingletonObjects） | 完成实例化且可以被引用，但是还未进行属性注入及初始化的对象      |
| **一级缓存**（singletonObjects）      | 创建好了的单例Bean                        |

| bean 创建过程     | 详细内容            |
| ------------- | --------------- |
| getSignleton  | 获取对象            |
| doCreateBean  | 创建对象            |
| populateBean  | 填充对象属性          |
| addSignaleton | 将对象添加到单例对象一级缓存中 |
## 循环依赖工作流程

假设存在两个 Bean，`A`和`B`，`A`依赖于`B`，`B`依赖于`A`。

再开始介绍之前，务必需要学会**Bean的生命周期**、**工厂模式**和**抽象工厂**

- 当 Spring 开始创建`A`时，首先会在【**一级缓存**】中查找是否已经存在`A`，由于是首次创建，所以找不到。然后会创建`A`的实例，并将一个创建`A`的工厂对象放入【**三级缓存**】中。这个工厂对象可以用于获取早期的`A`引用。
- 接着，在填充`A`的依赖时，发现`A`依赖于`B`，于是 Spring 开始创建`B`。同样，在【**一级缓存**】中找不到`B`，创建`B`的实例，并将`B`的工厂对象放入【**三级缓存**】中。
- 当填充`B`的依赖时，发现`B`依赖于`A`。此时，Spring 会先在【**一级缓存**】中找`A`，找不到；再去【**二级缓存**】中找`A`，还是找不到；最后会在【**三级缓存**】中找到`A`的工厂对象，通过这个工厂对象获取一个早期的`A`引用（这个引用还不是完全初始化的`A`）放入【**二级缓存**】，并将这个早期引用注入到`B`中。最后移除【**三级缓存**】中A的工厂
- 然后，`B`完成剩下的初始化步骤，放入【**一级缓存**】中。
- 此时，再将早期注入到`B`中的`A`引用替换为完全初始化好的`A`（从【**一级缓存**】中获取），`A`也完成剩下的初始化步骤，放入【**一级缓存**】中。
## 为什么不是两级缓存，而是三级缓存？
首先我们需要明确一个现实情况：按照上面的设计思路，**循环依赖完全可以跳过第二级缓存，即，只需要两级就可以完成**

在没有 AOP 的情况下，确实可以只使用一级和三级缓存来解决循环依赖问题。但是，当涉及到 AOP 时，二级缓存就显得非常重要了，因为它确保了即使在 Bean 的创建过程中有多次对早期引用的请求，也始终只返回同一个代理对象，从而避免了同一个 Bean 有多个代理对象的问题。

## 思考
循环依赖本身就是一种设计缺陷，我们不应该过度依赖 Spring 而忽视了编码的规范和质量，说不定未来某个 SpringBoot 版本就彻底禁止循环依赖的代码了。