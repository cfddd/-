> gpt 生成该部分内容，该部分比较简单

## 一、筛选、切片（Filtering & Slicing）

1. `filter(Predicate)`
2. `distinct()` 去重
3. `limit(n)` 截断出前n个元素
4. `skip(n)` 跳过前n个元素
## 二、匹配和查找（Matching & Finding）

1. `anyMatch(Predicate)`是否有任意一个元素匹配
2. `allMatch(Predicate)`是否所有元素都匹配
3. `noneMatch(Predicate)`是否所有元素都不匹配
4. `findAny()`返回任意一个元素（适用于并行流）
5. `findFirst()`返回第一个元素（更确定性）

## 三、归约（Reduction）

使用 `reduce` 聚合流中元素为一个值。

### 1. 累加求和：

```java
int sum = numbers.stream().reduce(0, Integer::sum);
// 等价于：.reduce(0, (a, b) -> a + b)
```

### 2. 最大值/最小值：

```java
Optional<Integer> max = numbers.stream().reduce(Integer::max);
Optional<Integer> min = numbers.stream().reduce(Integer::min);
```

### 3. 自定义归约：

```java
int product = numbers.stream().reduce(1, (a, b) -> a * b);
```

> 流操作：**无状态和有状态**
> 
> 诸如map或filter等操作会从输入流中获取每一个元素，并在输出流中得到0或1个结果。这些操作一般都是无状态的：它们**没有内部状态**（假设用户提供的Lambda或方法引用没有内部可变状态）。
> 
> 但诸如reduce、sum、max等操作**需要内部状态来累积结果**，内部状态都是必须要有界的。
> 
> sort或distinct等操作一开始都和filter和map差不多——都是接受一个流，再生成一个流（中间操作），但从流中排序和删除重复项时都需要知道先前的历史。例如，排序要求所有元素都放入缓冲区后才能给输出流加入一个项目，这一操作的要求是无界的。这些操作叫作**有状态操作**

作的存储要求是无界的。

![](../../../ad/Pasted%20image%2020250722230115.png)

## 四、使用数值范围的数值流（Primitive Streams）

Java 8引入了三个原始类型特化流接口来解决这个问题：IntStream、DoubleStream和LongStream，分别将流中的元素特化为int、long和double，从而避免了暗含的装箱成本。

### 1. 映射为数值流（避免装箱开销）
将流转换为特化版本的常用方法是mapToInt、 mapToDouble和mapToLong。这些方法和前面说的map方法的工作方式一样，只是它们返回的是一个特化流，而不是`Stream<T>`。

```java
int totalCalories = menu.stream()
    .mapToInt(Dish::getCalories)
    .sum();
```
如果流是空的，sum默认返回0。IntStream还支持其他的方便方法，如max、min、average等。

### 2. 转回对象流：
同样，一旦有了数值流，你可能会想把它转换回非特化流。把原始流转换成一般流（每个int都会装箱成一个Integer），可以使用boxed方法

```java
IntStream intStream = menu.stream().mapToInt(Dish::getCalories);
Stream<Integer> boxed = intStream.boxed();
```

### 3.默认值**OptionalInt**
求和有一个一个默认值：0，但是如何区分没有元素的流和最大值真的是0的流呢？

Optional可以用Integer、String等参考类型来参数化。对于三种原始流特化，也分别有一个Optional原始类型特化版本：OptionalInt、OptionalDouble和OptionalLong。
```java
OptionalInt maxCalories = menu.stream()
							.mapToInt(Dish::getCalories)
							.max();
// 显式定义一个最大值
int max = maxCalories.orElse(1);
```

### 4.range和rangeClosed
这两个方法都是第一个参数接受起始值，第二个参数接受结束值。但range是不包含结束值的，而rangeClosed则包含结束值。
```java
IntStream.range(1, 5).forEach(System.out::print);      // 1 2 3 4
IntStream.rangeClosed(1, 5).forEach(System.out::print); // 1 2 3 4 5
```

## 五、从多个源构建流（Creating Streams from Multiple Sources）

### 1. 集合：

```java
Stream<String> stream = list.stream();
```

### 2. 数组：

```java
Stream<String> stream = Arrays.stream(array);

int[] numbers = {2, 3, 5, 7, 11, 13};
int sum = Arrays.stream(numbers).sum();// IntStream
```

### 3. 值：

```java
Stream<String> stream = Stream.of("a", "b", "c");
Stream<String> emptyStream = Stream.empty();
```

### 4. 空流：

```java
Stream<String> emptyStream = Stream.empty();
```

### 5. 文件（按行读取）：

```java
Stream<String> lines = Files.lines(Paths.get("data.txt"));
```

---

## 六、无限流（Infinite Streams）

通过 `Stream.iterate()` 和 `Stream.generate()` 创建无限流。

不像从固定集合创建的流那样有固定大小的流。由iterate和generate产生的流会用给定的函数按需创建值，因此可以无穷无尽地计算下去！一般来说，应该使用limit(n)来对这种流加以限制

这个流是无界的。正如我们前面所讨论的，这是流和集合之间的一个关键区别。
### 1. `Stream.iterate(seed, UnaryOperator)`

```java
Stream.iterate(0, n -> n + 2)
      .limit(5)
      .forEach(System.out::println); // 0 2 4 6 8
```

#### 示例：生成斐波那契数列（使用 `iterate`）：

```java
Stream.iterate(new int[]{0, 1}, t -> new int[]{t[1], t[0] + t[1]})
      .limit(10)
      .map(t -> t[0])
      .forEach(System.out::println);
```

### 2. `Stream.generate(Supplier)`
接受一个`Supplier<T>`类型的Lambda提供新的值

```java
Stream.generate(Math::random)
      .limit(3)
      .forEach(System.out::println);
```
通过实现`IntSupplier`接口中定义的`getAsInt`方法显式传递一个对象

下面的代码就是如何创建一个在调用时返回下一个斐波纳契项的`IntSupplier`
```java
IntSupplier fib = new IntSupplier(){  
    private int previous = 0;  
    private int current = 1;  
    public int getAsInt(){  
        int oldPrevious = this.previous;  
        int nextValue = this.previous + this.current;  
        this.previous = this.current;  
        this.current = nextValue;  
        return oldPrevious;  
    }  
};
```
此对象有可变的状态，getAsInt在调用时会改变对象的状态，由此在每次调用时产生新的值。

但是**使用`iterate`的方法则是纯粹不变的**：它没有修改现有状态，但在每次迭代时会创建新的元组。

> **不能对无限流做排序或归约，因为所有元素都需要处理，而这永远也完不成！**

```java

```