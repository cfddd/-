> **Java 8 实战 学习笔记**


行为参数化是一个很有用的模式，它能够轻松地适应不断变化的需求。这种模式可以把一个行为（一段代码）封装起来，并通过传递和使用创建的行为将方法的**行为参数化**。

这种做法类似于策略设计模式。你可能已经在实践中用过这个模式了。

JavaAPI中的很多方法都可以用不同的行为来参数化。这些方法往往与匿名类一起使用。我们会展示两个例子，这应该能帮助你巩固传递代码的思想了：用一个Comparator排序，用Runnable执行一个代码块。

### Comparator排序
在 Java 中，`Comparator`接口是行为参数化的经典示例，它允许我们将 "比较逻辑" 作为参数传递给排序方法：

```java
// 传统排序（固定按字符串长度排序）
List<String> words = Arrays.asList("apple", "banana", "cherry", "date");
words.sort((a, b) -> a.length() - b.length());
System.out.println(words); // 输出：[date, apple, cherry, banana]

// 行为参数化应用：通过不同Comparator实现灵活排序
// 按字母逆序排序
words.sort(Comparator.reverseOrder());
System.out.println(words); // 输出：[date, cherry, banana, apple]

// 按首字母大写排序
words.sort((a, b) -> a.charAt(0) - b.charAt(0));
System.out.println(words); // 输出：[apple, banana, cherry, date]
```
在 Java 8 之前，行为参数化主要通过匿名内部类实现，代码较为繁琐：

```java
// Java 7及以前：使用匿名内部类传递Comparator
Collections.sort(words, new Comparator<String>() {
    @Override
    public int compare(String a, String b) {
        return a.length() - b.length();
    }
});

// Java 8及以后：使用lambda表达式简化行为传递
words.sort((a, b) -> a.length() - b.length());
```
### 使用 Runnable 封装可执行代码块
`Runnable`接口是 Java 多线程编程中行为参数化的典型应用，它允许将 "线程执行逻辑" 作为参数传递给线程构造器：
```java
// 传统方式：继承Thread类（耦合度高）
class TaskThread extends Thread {
    @Override
    public void run() {
        System.out.println("执行任务：计算1+2+3=" + (1+2+3));
    }
}

// 行为参数化方式：通过Runnable传递任务逻辑
Runnable task = () -> {
    int sum = 0;
    for (int i = 1; i <= 10; i++) {
        sum += i;
    }
    System.out.println("执行任务：1到10的和为" + sum);
};

// 创建线程并传递行为参数
new Thread(task).start();

// Java 8简化写法：直接传递lambda表达式
new Thread(() -> System.out.println("简单任务：打印当前时间")).start();
```

**核心原理**：  
`Thread`类的构造器接收`Runnable`接口实现（行为参数），该接口仅包含一个`run()`抽象方法，实现了 "线程生命周期管理" 与 "任务逻辑" 的分离。