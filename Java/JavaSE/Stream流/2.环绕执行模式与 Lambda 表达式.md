## 什么是环绕执行模式（Around Execution Pattern）

环绕执行模式是一种常见的编程模式，其核心思想是：**在执行核心业务逻辑的前后，执行一些固定的 "模板" 代码**。典型场景包括：

- 文件操作（打开文件→读写文件→关闭文件）
- 数据库操作（获取连接→执行 SQL→释放连接）
- 事务管理（开启事务→执行业务→提交 / 回滚事务）
- 资源锁定（获取锁→执行操作→释放锁）

这种模式的传统实现方式往往存在大量重复代码，而 Lambda 表达式的出现为其提供了更优雅的解决方案。
### 传统环绕执行模式的痛点

以文件操作为例，传统写法存在明显缺陷：

```java
// 传统文件操作：代码冗余，错误处理繁琐
public String readFile(String path) throws IOException {
    BufferedReader reader = null;
    try {
        reader = new BufferedReader(new FileReader(path));
        String line;
        StringBuilder content = new StringBuilder();
        while ((line = reader.readLine()) != null) {
            content.append(line).append("\n");
        }
        return content.toString();
    } catch (IOException e) {
        // 异常处理逻辑
        e.printStackTrace();
        throw e;
    } finally {
        // 资源释放逻辑
        if (reader != null) {
            try {
                reader.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

### 使用 Lambda 实现环绕执行模式的重构
通过 Lambda 表达式，我们可以将 "核心业务逻辑" 抽象为参数，从而分离 "模板代码" 与 "业务逻辑"：

```java
// 1. 定义函数式接口：抽象核心业务逻辑
@FunctionalInterface
public interface FileProcessor {
    String process(BufferedReader reader) throws IOException;
}

// 2. 实现环绕执行模板方法
public String processFile(String path, FileProcessor processor) throws IOException {
    try (BufferedReader reader = new BufferedReader(new FileReader(path))) {
        // 环绕执行：核心业务逻辑由Lambda表达式提供
        return processor.process(reader);
    }
}

// 3. 使用Lambda表达式调用模板方法
public void demo() throws IOException {
    // 示例1：读取第一行
    String firstLine = processFile("data.txt", reader -> reader.readLine());
    
    // 示例2：读取前两行
    String firstTwoLines = processFile("data.txt", reader -> 
        reader.readLine() + "\n" + reader.readLine()
    );
    
    // 示例3：统计行数
    long lineCount = processFile("data.txt", reader -> 
        String.valueOf(reader.lines().count())
    );
}
```

## Lambda 表达式
**常见的函数式接口**：

|接口名|参数|返回值|示例用途|
|---|---|---|---|
|`Runnable`|无|void|线程任务|
|`Supplier<T>`|无|T|提供数据|
|`Consumer<T>`|T|void|消费数据（如打印）|
|`Function<T, R>`|T|R|数据转换|
|`Predicate<T>`|T|boolean|条件判断|
## 方法引用
方法引用是 Java 8 引入的一种简化语法，它允许我们直接引用已有的方法或构造函数，从而进一步简化 Lambda 表达式。方法引用通过特定的符号 `::` 将类名或对象名与方法名连接起来。

**核心思想**：  
当 Lambda 表达式的实现恰好是调用一个已存在的方法时，使用方法引用可以让代码更简洁、更易读。

```java
// 静态方法引用
ClassName::staticMethod

// 实例方法引用
objectInstance::instanceMethod

// 对象方法引用（特殊形式）
ClassName::instanceMethod

// 构造方法引用
ClassName::new
```
## 复合lambda表达式
复合 Lambda 表达式是指**将多个简单的 Lambda 表达式组合成一个更复杂的表达式**的技术。通过函数式接口提供的默认方法（如 `and`、`or`、`compose`、`andThen` 等），我们可以将多个 Lambda 表达式串联起来，形成强大的逻辑链。
### Predicate 复合：组合条件判断
`Predicate<T>` 接口提供了 and、or 和 negate 三个默认方法，用于组合条件判断：
1. `and` 方法等价于逻辑与（&&）
2. `or` 方法等价于逻辑或（||）
3. `negate` 方法等价于逻辑非（!）
4. 多个条件按顺序执行，遵循短路原则

```java
import java.util.function.Predicate;

public class PredicateComposition {
    public static void main(String[] args) {
        // 基础条件：长度大于5
        Predicate<String> longString = s -> s.length() > 5;
        
        // 基础条件：包含字母"a"
        Predicate<String> containsA = s -> s.contains("a");
        
        // 复合条件1：长度大于5 并且 包含字母"a"
        Predicate<String> complex1 = longString.and(containsA);
        
        // 复合条件2：长度大于5 或者 包含字母"a"
        Predicate<String> complex2 = longString.or(containsA);
        
        // 复合条件3：长度不大于5
        Predicate<String> complex3 = longString.negate();
        
        // 测试
        System.out.println(complex1.test("banana")); // true
        System.out.println(complex2.test("apple"));  // true
        System.out.println(complex3.test("pear"));   // true
    }
}
```
### Function 复合：组合数据转换

`Function<T, R>` 接口提供了 `compose` 和 `andThen` 两个默认方法，用于组合函数转换：

```java
import java.util.function.Function;

public class FunctionComposition {
    public static void main(String[] args) {
        // 函数1：将字符串转换为整数
        Function<String, Integer> parseInt = s -> Integer.parseInt(s);
        
        // 函数2：计算平方
        Function<Integer, Integer> square = x -> x * x;
        
        // 复合函数1：先解析字符串，再计算平方（f.compose(g) = f(g(x))）
        Function<String, Integer> parseAndSquare = square.compose(parseInt);
        
        // 复合函数2：先计算平方，再转换为字符串（f.andThen(g) = g(f(x))）
        Function<Integer, String> squareAndToString = square.andThen(String::valueOf);
        
        // 测试
        System.out.println(parseAndSquare.apply("5"));       // 25
        System.out.println(squareAndToString.apply(3));     // "9"
    }
}
```


**执行顺序**：

- `compose`：从右到左执行（先应用参数中的函数，再应用当前函数）
- `andThen`：从左到右执行（先应用当前函数，再应用参数中的函数）

### Consumer 复合：组合副作用操作

`Consumer<T>` 接口提供了 `andThen` 方法，用于组合多个消费操作：

```java
import java.util.Arrays;
import java.util.List;
import java.util.function.Consumer;

public class ConsumerComposition {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
        
        // 操作1：打印大写形式
        Consumer<String> printUpperCase = s -> System.out.println(s.toUpperCase());
        
        // 操作2：打印长度
        Consumer<String> printLength = s -> System.out.println("Length: " + s.length());
        
        // 复合操作：先打印大写，再打印长度
        Consumer<String> combined = printUpperCase.andThen(printLength);
        
        // 对每个元素执行复合操作
        names.forEach(combined);
    }
}
```
### Comparator 复合：组合排序规则
`Comparator` 接口提供了 `thenComparing` 方法，用于组合多个排序条件：

```java
		// 主排序规则：按姓名升序
        Comparator<Person> byName = Comparator.comparing(Person::getName);
        
        // 次要排序规则：按年龄升序
        Comparator<Person> byAge = Comparator.comparing(Person::getAge);
        
        // 复合排序：先按姓名，再按年龄
        Comparator<Person> composite = byName.thenComparing(byAge);
```
## 环绕执行模式实战：分页批操作抽象
> **请注意**：分页批操作不是类似数据库的分页查询，分页操作需要的是把全量数据，通过”滑动窗口“控制吞吐量，以良好执行批操作；分页查询类似数据库查询的分页，一次只会得到一页的操作，而且已经有良好实现的框架，也不在这里的考虑范围

相信大家一定有写过分页的逻辑：会得到待操作总数total，每批大小，页号计算出来的offest指针和limit，然后通过移动指针将所有的操作都过一遍。

笔者遇到一个麻烦，就是对接其他服务方的接口，都有分页操作，而我有需要把这些数据都全量取出来，也就意味着，我需要对**每一个查询操作都写一个分页然后执行**，于是我萌生了通过前面的**环绕执行模式**来抽象【分页批处理】这个逻辑

具体逻辑见如下代码：

```java
  
@Slf4j  
@Component  
public class PaginationUtil {  
  
    /**  
     * 分页查询 函数式编程  
     *  
     * @param queryFunction          执行查询的函数  
     * @param getTotal               获取查询结果总数的函数，用于计算分页次数  
     * @param getItems               获取查询结果列表中元素的函数  
     * @param toItemDTO              获取返回结果列表内元素的参数  
     * @param resultList             返回结果列表的集合  
     * @param pageSize               每页大小  
     * @param <T>                    响应结果类型 一般来说是一个object包含 total List<item>  
     * @param <R1>                   响应结果列表内元素的参数类型 代表 item 的类型  
     * @param <R2>                   返回结果列表内元素的参数类型 代表 resultList<item> 中的item 的类型  
     */  
    public <T, R1, R2> void executePagedQuery(IntFunction<T> queryFunction,  
                                              ToIntFunction<T> getTotal,  
                                              Function<T, List<R1>> getItems,  
                                              Function<R1, R2> toItemDTO,  
                                              List<R2> resultList,  
                                              Integer pageSize) {  
  
        int currentPage = 1;  
  
        // 第一页  
        T response = queryFunction.apply(currentPage);  
        if (response == null) {  
            log.warn("首次查询结果为空");  
            return;  
        }  
  
        Integer total = getTotal.applyAsInt(response);  
        if (total == null || total <= 0) {  
            return;  
        }  
  
        // 获取查询结果列表  
        List<R1> items = getItems.apply(response);  
        if (CollectionUtils.isEmpty(items)) {  
            log.warn("首次查询无结果");  
            return;  
        }  
        items.stream().map(toItemDTO).forEach(resultList::add);  
  
        int totalPages = (total + pageSize - 1) / pageSize;  
        currentPage = 2;  
        // 后续页  
        while (currentPage <= totalPages) {  
            response = queryFunction.apply(currentPage++);  
            if (response == null) {  
                log.warn("分页查询结果为空，页码：{}", currentPage - 1);  
                continue;  
            }  
            items = getItems.apply(response);  
            if (CollectionUtils.isEmpty(items)) {  
                log.warn("分页查询结果为空，页码：{}", currentPage - 1);  
                continue;  
            }  
  
            items.stream().map(toItemDTO).forEach(resultList::add);  
        }  
    }
}
```

使用例子如下：

```java
  
private void queryCompanyShareholders(List<AssociatedEntityBO> collect, KeywordPageReqDTO keywordPageReqDTO) {  
    log.info("开始查询企业股东");  
    
    paginationUtil.executePagedQuery(  
            pageNum -> {  
                keywordPageReqDTO.setPageNum(pageNum);  
                return businessInfo.queryCompanyShareholders(keywordPageReqDTO); 
            },  
            CompanyShareholdersRespDTO::getTotal,  
            CompanyShareholdersRespDTO::getItems,  
            item -> new AssociatedEntityBO(null, 0, item.getName(), null, null),
            collect,  
            MAX_PAGE_SIZE  
    );  
  
    log.info("查询企业股东结束，collect累计找到 {} 条", collect.size());  
}
```

经过抽象思考发现，可以将分页公用逻辑、私用逻辑分开，**工用逻辑**中可以填入**私用逻辑**的lambda表达式，下面介绍那些是私用逻辑：
1. 最重要的：单次批操作
2. 获取单次批操作中，返回的操作总数
3. 获取单次批操作中，待处理数据集合
4. 待处理数据类型 转换为 目标数据类型 的lambda表达式
5. 结果集合（类型=目标数据类型）
6. 单次批操作size

分析出来后，编写公用逻辑就比较容易了，最终的效果也是很不错，可以按需修改私用逻辑，极大减少了重复代码的编写。