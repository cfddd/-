## 什么是环绕执行模式（Around Execution Pattern）

环绕执行模式是一种常见的编程模式，其核心思想是：**在执行核心业务逻辑的前后，执行一些固定的 "模板" 代码**。典型场景包括：

- 文件操作（打开文件→读写文件→关闭文件）
- 数据库操作（获取连接→执行 SQL→释放连接）
- 事务管理（开启事务→执行业务→提交 / 回滚事务）
- 资源锁定（获取锁→执行操作→释放锁）

这种模式的传统实现方式往往存在大量重复代码，而 Lambda 表达式的出现为其提供了更优雅的解决方案。
### 传统环绕执行模式的痛点

以文件操作为例，传统写法存在明显缺陷：

```java
// 传统文件操作：代码冗余，错误处理繁琐
public String readFile(String path) throws IOException {
    BufferedReader reader = null;
    try {
        reader = new BufferedReader(new FileReader(path));
        String line;
        StringBuilder content = new StringBuilder();
        while ((line = reader.readLine()) != null) {
            content.append(line).append("\n");
        }
        return content.toString();
    } catch (IOException e) {
        // 异常处理逻辑
        e.printStackTrace();
        throw e;
    } finally {
        // 资源释放逻辑
        if (reader != null) {
            try {
                reader.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

### 使用 Lambda 实现环绕执行模式的重构
通过 Lambda 表达式，我们可以将 "核心业务逻辑" 抽象为参数，从而分离 "模板代码" 与 "业务逻辑"：

```java
// 1. 定义函数式接口：抽象核心业务逻辑
@FunctionalInterface
public interface FileProcessor {
    String process(BufferedReader reader) throws IOException;
}

// 2. 实现环绕执行模板方法
public String processFile(String path, FileProcessor processor) throws IOException {
    try (BufferedReader reader = new BufferedReader(new FileReader(path))) {
        // 环绕执行：核心业务逻辑由Lambda表达式提供
        return processor.process(reader);
    }
}

// 3. 使用Lambda表达式调用模板方法
public void demo() throws IOException {
    // 示例1：读取第一行
    String firstLine = processFile("data.txt", reader -> reader.readLine());
    
    // 示例2：读取前两行
    String firstTwoLines = processFile("data.txt", reader -> 
        reader.readLine() + "\n" + reader.readLine()
    );
    
    // 示例3：统计行数
    long lineCount = processFile("data.txt", reader -> 
        String.valueOf(reader.lines().count())
    );
}
```

## Lambda 表达式
**常见的函数式接口**：

|接口名|参数|返回值|示例用途|
|---|---|---|---|
|`Runnable`|无|void|线程任务|
|`Supplier<T>`|无|T|提供数据|
|`Consumer<T>`|T|void|消费数据（如打印）|
|`Function<T, R>`|T|R|数据转换|
|`Predicate<T>`|T|boolean|条件判断|
## 方法引用
方法引用是 Java 8 引入的一种简化语法，它允许我们直接引用已有的方法或构造函数，从而进一步简化 Lambda 表达式。方法引用通过特定的符号 `::` 将类名或对象名与方法名连接起来。

**核心思想**：  
当 Lambda 表达式的实现恰好是调用一个已存在的方法时，使用方法引用可以让代码更简洁、更易读。

```java
// 静态方法引用
ClassName::staticMethod

// 实例方法引用
objectInstance::instanceMethod

// 对象方法引用（特殊形式）
ClassName::instanceMethod

// 构造方法引用
ClassName::new
```
## 复合lambda表达式
复合 Lambda 表达式是指**将多个简单的 Lambda 表达式组合成一个更复杂的表达式**的技术。通过函数式接口提供的默认方法（如 `and`、`or`、`compose`、`andThen` 等），我们可以将多个 Lambda 表达式串联起来，形成强大的逻辑链。
### Predicate 复合：组合条件判断
`Predicate<T>` 接口提供了 and、or 和 negate 三个默认方法，用于组合条件判断：
1. `and` 方法等价于逻辑与（&&）
2. `or` 方法等价于逻辑或（||）
3. `negate` 方法等价于逻辑非（!）
4. 多个条件按顺序执行，遵循短路原则

```java
import java.util.function.Predicate;

public class PredicateComposition {
    public static void main(String[] args) {
        // 基础条件：长度大于5
        Predicate<String> longString = s -> s.length() > 5;
        
        // 基础条件：包含字母"a"
        Predicate<String> containsA = s -> s.contains("a");
        
        // 复合条件1：长度大于5 并且 包含字母"a"
        Predicate<String> complex1 = longString.and(containsA);
        
        // 复合条件2：长度大于5 或者 包含字母"a"
        Predicate<String> complex2 = longString.or(containsA);
        
        // 复合条件3：长度不大于5
        Predicate<String> complex3 = longString.negate();
        
        // 测试
        System.out.println(complex1.test("banana")); // true
        System.out.println(complex2.test("apple"));  // true
        System.out.println(complex3.test("pear"));   // true
    }
}
```
### Function 复合：组合数据转换

`Function<T, R>` 接口提供了 `compose` 和 `andThen` 两个默认方法，用于组合函数转换：

```java
import java.util.function.Function;

public class FunctionComposition {
    public static void main(String[] args) {
        // 函数1：将字符串转换为整数
        Function<String, Integer> parseInt = s -> Integer.parseInt(s);
        
        // 函数2：计算平方
        Function<Integer, Integer> square = x -> x * x;
        
        // 复合函数1：先解析字符串，再计算平方（f.compose(g) = f(g(x))）
        Function<String, Integer> parseAndSquare = square.compose(parseInt);
        
        // 复合函数2：先计算平方，再转换为字符串（f.andThen(g) = g(f(x))）
        Function<Integer, String> squareAndToString = square.andThen(String::valueOf);
        
        // 测试
        System.out.println(parseAndSquare.apply("5"));       // 25
        System.out.println(squareAndToString.apply(3));     // "9"
    }
}
```


**执行顺序**：

- `compose`：从右到左执行（先应用参数中的函数，再应用当前函数）
- `andThen`：从左到右执行（先应用当前函数，再应用参数中的函数）

### Consumer 复合：组合副作用操作

`Consumer<T>` 接口提供了 `andThen` 方法，用于组合多个消费操作：

```java
import java.util.Arrays;
import java.util.List;
import java.util.function.Consumer;

public class ConsumerComposition {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
        
        // 操作1：打印大写形式
        Consumer<String> printUpperCase = s -> System.out.println(s.toUpperCase());
        
        // 操作2：打印长度
        Consumer<String> printLength = s -> System.out.println("Length: " + s.length());
        
        // 复合操作：先打印大写，再打印长度
        Consumer<String> combined = printUpperCase.andThen(printLength);
        
        // 对每个元素执行复合操作
        names.forEach(combined);
    }
}
```
### Comparator 复合：组合排序规则
`Comparator` 接口提供了 `thenComparing` 方法，用于组合多个排序条件：

```java
		// 主排序规则：按姓名升序
        Comparator<Person> byName = Comparator.comparing(Person::getName);
        
        // 次要排序规则：按年龄升序
        Comparator<Person> byAge = Comparator.comparing(Person::getAge);
        
        // 复合排序：先按姓名，再按年龄
        Comparator<Person> composite = byName.thenComparing(byAge);
```