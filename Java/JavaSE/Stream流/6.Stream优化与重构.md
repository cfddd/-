Lambda表达式为程序员的工具箱又新添了一件利器。它们为解决传统设计模式所面对的问题提供了新的解决方案，不但如此，采用这些方案往往更高效、更简单。使用Lambda表达式后，很多现存的略显臃肿的面向对象设计模式能够用更精简的方式实现了。
## 使用 Lambda 重构面向对象的设计模式
### 策略模式
策略模式包含三部分内容。

- 一个代表某个算法的接口（它是策略模式的接口）。
- 一个或多个该接口的具体实现，它们代表了算法的多种实现（比如，实体类Concrete-StrategyA或者ConcreteStrategyB）。
- 一个或多个使用策略对象的客户。

下面用一个示例来演示他对设计模式的简化：

策略模式的公用部分
```java
interface ValidationStrategy {  
    boolean execute(String s);  
}  
class Validator {  
    private final ValidationStrategy strategy;  
    public Validator(ValidationStrategy v) {  
        this.strategy = v;  
    }  
    public boolean validate(String s) {  
        return strategy.execute(s);  
    }  
}

```

传统设计模式，需要定义该接口的一个或多个具体实现
```java
class IsAllLowerCase implements ValidationStrategy {  
    public boolean execute(String s) {  
        return s.matches("[a-z]+");  
    }  
}  
class IsNumeric implements ValidationStrategy {  
    public boolean execute(String s) {  
        return s.matches("\\d+");  
    }  
}  
public class Strategy {  
    public static void main(String[] args) {  
        Validator numericValidator = new Validator(new IsNumeric());  
        boolean b1 = numericValidator.validate("aaaa");  
        Validator lowerCaseValidator = new Validator(new IsAllLowerCase());  
        boolean b2 = lowerCaseValidator.validate("bbbb");  
    }  
}  
```
**使用lambda表达式之后**：
观察发现，策略模式ValidationStrategy是一个**函数接口**了（除此之外，它还与`Predicate<String>`具有同样的函数描述）。

**这意味着我们不需要声明新的类来实现不同的策略**，通过直接传递Lambda表达式就能达到同样的目的，并且还更简洁：

```java  
public class Strategy {  
    public static void main(String[] args) {
        Validator numericValidator = new Validator((String s) -> s.matches("[a-z]+"));  
        boolean b1 = numericValidator.validate("aaaa");  
        Validator lowerCaseValidator = new Validator((String s) -> s.matches("\\d+"));  
        boolean b2 = lowerCaseValidator.validate("bbbb");  
    }  
}
```
Lambda表达式避免了采用策略设计模式时僵化的模板代码。如果你仔细分析一下个中缘由，可能会发现，**Lambda表达式实际已经对部分代码（或策略）进行了封装**，而这就是创建策略设计模式的初衷。因此，我们强烈建议对类似的问题，你应该尽量使用Lambda表达式来解决。
### 模版模式
如果你需要采用某个算法的框架，同时又希望有一定的灵活度，能对它的某些部分进行改进，那么采用模板方法设计模式是比较通用的方案。
```java
abstract class OnlineBanking {  
    public void processCustomer(int id) {  
        Customer c = Database.getCustomerWithId(id);  
        makeCustomerHappy(c);  
    }
    abstract void makeCustomerHappy(Customer c);  
}
class OnlineBankingA extends OnlineBanking {  
    @Override  
    void makeCustomerHappy(Customer c) {  
        System.out.println("OnlineBankingLambda.makeCustomerHappy");  
    }  
}
```

`processCustomer`方法搭建了在线银行算法的框架：获取客户提供的ID，然后提供服务让用户满意。不同的支行可以通过继承`OnlineBanking`类，对该方法提供差异化的实现。

```java
class OnlineBanking {
    public void processCustomer(int id, Consumer<Customer> makeCustomerHappy){  
        Customer c = Database.getCustomerWithId(id);  
        makeCustomerHappy.accept(c);  
    }
}
```
现在可以很方便地通过传递Lambda表达式，直接插入不同的行为，不再需要继承OnlineBanking类了
```java
new OnlineBanking().processCustomer(1337, (Customer c) -> System.out.println("Hello " + c.getClass()));
```

### 观察者模式
些事件发生时（比如状态转变），如果一个对象（通常我们称之为主题）需要自动地通知其他多个对象（称为观察者）。观察者设计模式也适用于股票交易的情形，多个券商可能都希望对某一支股票价格（主题）的变动做出响应。

观察者模式有如下成员：
- 一个观察者接口，它将不同的观察者聚合在一起。在这里就是Obsever接口
- 不同的观察者。这里就是各种实现类

```java
// 观察者接口
interface Observer {  
    void notify(String tweet);  
}  
class NYTimes implements Observer{  
    public void notify(String tweet) {  
        if(tweet != null && tweet.contains("money")){  
            System.out.println("Breaking news in NY! " + tweet);  
        }  
    }  
}  
class Guardian implements Observer{  
    public void notify(String tweet) {  
        if(tweet != null && tweet.contains("queen")){  
            System.out.println("Yet another news in London... " + tweet);  
        }  
    }  
}  
class LeMonde implements Observer{  
    public void notify(String tweet) {  
        if(tweet != null && tweet.contains("wine")){  
            System.out.println("Today cheese, wine and news! " + tweet);  
        }  
    }  
}
// Feed 类内维护了观察者列表
class Feed{  
    private final List<Observer> observers = new ArrayList<>();  
    public void registerObserver(Observer o) {  
        this.observers.add(o);  
    }  
    public void notifyObservers(String tweet) {  
        observers.forEach(o -> o.notify(tweet));  
    }  
}
```
创建Feed类实例，然后注册观察者，发布消息后观察者发现是自己需要的新闻才会执行逻辑
```java
public static void main(String[] args) {  
    Feed f = new Feed();  
    f.registerObserver(new NYTimes());  
    f.registerObserver(new Guardian());  
    f.registerObserver(new LeMonde());  
    f.notifyObservers("The queen said her favourite book is Java 8 in Action!");
}
```

Observer接口的所有实现类都提供了一个方法：notify。新闻到达时，它们都只是对同一段代码封装执行。

> **注意**：Observer 必须**只有一个抽象方法**，才能被当做是函数式接口，用Lambda表达式来**替代匿名内部类**。在 Observer 中找到**多个非重写 abstract 方法**，无法使用

Lambda表达式的设计初衷就是要消除这样的僵化代码。使用Lambda表达式后，你无需显式地实例化三个观察者对象，直接传递Lambda表达式表示需要执行的行为即可：

```java
Observer money = (String tweet) -> {  
    if (tweet != null && tweet.contains("money")) {  
        System.out.println("Breaking news in NY! " + tweet);  
    }  
};
f.registerObserver(money);   
f.registerObserver((String tweet) -> {  
    if(tweet != null && tweet.contains("queen")){  
        System.out.println("Yet another news in London... " + tweet);  
    }  
});
```

> **警告⚠️**：不建议随时随地用Lambda表达式实现观察者模式。Lambda在这里适配得很好，那是因为需要执行的动作都很简单，因此才能很方便地消除僵化代码。但是，观察者的逻辑有可能十分复杂，它们可能还持有状态，抑或定义了多个方法，诸如此类。在这些情形下，你还是应该继续使用类的方式。
### 责任链模式

责任链模式是一种创建**处理对象序列（比如操作序列）的通用方案**。一个处理对象可能需要在完成一些工作之后，将结果传递给另一个对象，这个对象接着做一些工作，再转交给下一个处理对象，以此类推。

责任链模式组成：
- 一个代表处理对象的抽象类
- 抽象类中会定义一个字段来记录后续对象，一旦对象完成它的工作，处理对象就会将它的工作转交给它的后继。 
![](../../../addition/Pasted%20image%2020250730202958.png)
 代码中，这段逻辑看起来是下面这样：
 ```java
 abstract class ProcessingObject<T> {  
    protected ProcessingObject<T> successor;  
    public void setSuccessor(ProcessingObject<T> successor){  
        this.successor = successor;  
    }  
    public T handle(T input){  
        T r = handleWork(input);  
        if(successor != null){  
            return successor.handle(r);  
        }  
        return r;  
    }  
    abstract protected T handleWork(T input);  
}
```

创建两个处理对象，**链式执行**文本操作
```java
class HeaderTextProcessing extends ProcessingObject<String> {  
    public String handleWork(String text){  
        return "From Raoul, Mario and Alan: " + text;  
    }  
}  
class SpellCheckerProcessing extends ProcessingObject<String> {  
    public String handleWork(String text){  
        return text.replaceAll("labda", "lambda");  
    }  
}
public static void main(String[] args) {  
    ProcessingObject<String> p1 = new HeaderTextProcessing();  
    ProcessingObject<String> p2 = new SpellCheckerProcessing();  
    p1.setSuccessor(p2);  
    String result = p1.handle("Aren't labdas really sexy?!!");  
    System.out.println(result); // From Raoul, Mario and Alan: Aren't lambdas really sexy?!!  
}
```
**使用lambda表达式**：你可以将处理对象作为函数的一个实例，或者更确切地说作为`UnaryOperator-<String>`的一个实例。为了链接这些函数，你需要使用andThen方法对其进行构造。

```java
UnaryOperator<String> headerProcessing = (String text) -> "From Raoul, Mario and Alan: " + text;  
UnaryOperator<String> spellCheckerProcessing = (String text) -> text.replaceAll("labda", "lambda");  
Function<String, String> pipeline = headerProcessing.andThen(spellCheckerProcessing);  
result = pipeline.apply("Aren't labdas really sexy?!!");
```
### 工厂模式
使用工厂模式，你无需向客户暴露实例化的逻辑就能完成对象的创建。

这里贷款（Loan） 、股票（Stock）和债券（Bond）都是产品（Product）的子类。createProduct方法可以通过附加的逻辑来设置每个创建的产品。但是带来的好处也显而易见，你在创建对象时不用再担心会将构造函数或者配置暴露给客户，这使得客户创建产品时更加简单：
```java
public class Facotry {
    public static void main(String[] args) {
        Product p = ProductFactory.createProduct("loan");
    }
}
class ProductFactory {  
    public static Product createProduct(String name){  
        switch(name){  
            case "loan": return new Loan(); // 贷款  
            case "stock": return new Stock(); // 股票  
            case "bond": return new Bond(); // 债券  
            default: throw new RuntimeException("No such product " + name);  
        }  
    }  
}
```

**使用lambda**：

```java
public class Facotry {  
    final static Map<String, Supplier<Product>> map = new HashMap<>();  
    static {  
        map.put("loan", Loan::new);  
        map.put("stock", Stock::new);  
        map.put("bond", Bond::new);  
    }  
    public static Product createProduct(String name){  
        Supplier<Product> p = map.get(name);  
        if(p != null) return p.get();  
        throw new IllegalArgumentException("No such product " + name);  
    }  
    public static void main(String[] args) {
        Product q = createProduct("loan");  
    }  
}
```

这是个全新的尝试，它使用Java 8中的新特性达到了传统工厂模式同样的效果。

> **但是**，如果工厂方法createProduct需要接收**多个传递给产品构造方法的参数**，这种方式的扩展性不是很好。
```java
public interface TriFunction<T, U, V, R>{
	R apply(T t, U u, V v);
}
Map<String, TriFunction<Integer, Integer, String, Product>> map = new HashMap<>();
// 为了完成这个任务，你需要创建一个特殊的函数接口TriFunction。最终的结果是Map变得更加复杂。
```
## 调试的tips
### 查看栈跟踪
不幸的是，由于Lambda表达式没有名字，它的栈跟踪可能很难分析。在下面这段简单的代码中，我们刻意地引入了一些错误。

```java
public class Debugging{  
    public static void main(String[] args) {  
        List<Point> points = Arrays.asList(new Point(12, 2), null);  
        points.stream().map(p -> p.getX()).forEach(System.out::println);  
    }  
}
```

由于Stream流水线发生了错误，构成Stream流水线的整个方法调用序列都暴露出来
```sh
at Debugging.lambda$main$0(Debugging.java:6)
	at Debugging$$Lambda$5/284720968.apply(Unknown Source)
```
这些表示错误发生在Lambda表达式内部。由于Lambda表达式没有名字，所以编译器只能为它们指定一个名字。这个例子中，它的名字是lambda$main$0，看起来非常不直观。果你使用了大量的类，其中又包含多个Lambda表达式，这就成了一个非常头痛的问题。

> 注意，如果方法引用指向的是**同一个类中声明的方法**，那么它的名称是可以在栈跟踪中显示的。

```java
public class Debugging{
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3);
        numbers.stream().map(Debugging::divideByZero).forEach(System.out::println);
        public static int divideByZero(int n){
            return n / 0;
        }
    }
}
```

方法divideByZero在栈跟踪中就正确地显示了：
```java
Exception in thread "main" java.lang.ArithmeticException: / by zero
at Debugging.divideByZero(Debugging.java:10)
at Debugging$$Lambda$1/999966131.apply(Unknown Source)
at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193)
```
### 使用日志调试
```java
List<Integer> numbers = Arrays.asList(2, 3, 4, 5);
numbers.stream()
	.map(x -> x + 17)
	.filter(x -> x % 2 == 0)
	.limit(3)
	.forEach(System.out::println);
```
一旦调用forEach，整个流就会恢复运行，导致我们没办法看到流中每一条处具体的执行变化，推荐使用peek来打印日志：

peek的设计初衷就是在流的每个元素恢复运行之前，插入执行一个动作。但是它不像forEach那样恢复整个流的运行，而是在一个元素上完成操作之后，它只会将操作顺承到流水线中的下一个操作。

**通过peek操作我们能清楚地了解流水线操作中每一步的输出结果**
```java
List<Integer> result = numbers.stream()  
                .peek(x -> System.out.println("from stream: " + x))  
                .map(x -> x + 17)  
                .peek(x -> System.out.println("after map: " + x))  
                .filter(x -> x % 2 == 0)  
                .peek(x -> System.out.println("after filter: " + x))  
                .limit(3)  
                .peek(x -> System.out.println("after limit: " + x))  
                .collect(toList());
```