## 流简介
Java 8中的集合支持一个新的 stream方法，它会返回一个流（接口定义在java.util.stream.Stream里）。

流简短的定义就是“从支持数据处理操作的源生成的元素序列” 。

例如 `filter,map,limit,collect`
## 流与集合

Java现有的集合概念和新的流概念都提供了接口，来配合代表元素型有序值的数据接口。所谓有序，就是说我们一般是按顺序取用值，而不是随机取用的。

| 项目 | 集合（Collection） | 流（Stream） |
|------|------------------|--------------|
| **存储方式** | 存储在内存中 | 不实际存储数据 |
| **计算时机** | **急切计算**（所有元素必须提前准备好） | **按需计算 / 延迟计算**（用到时才生成） |
| **可变性** | 可增删元素 | 固定不变（只能读取，不能修改） |
| **处理方式** | 所有数据一次性加载 | 数据逐个处理，无需全部加载 |
| **适用场景** | 小规模、静态数据集合 | 大数据、无限流、实时数据处理 |
| **类比** | DVD 视频（整部电影都下载好） | 在线视频流（边下边播） |

- **集合**：所有数据都在内存里，随时可用。与此相反，集合则是急切创建的（供应商驱动：先把仓库装满，再开始卖，就像那些昙花一现的圣诞新玩意儿一样）。
- **流**：**按需**计算，**按需**生成。是一种生产者－消费者的关系。从另一个角度来说，流就像是一个延迟创建的集合：只有在消费者要求的时候才会计算值（用管理学的话说这就是需求驱动，甚至是实时制造)。

> **关键区别一**：请注意，和迭代器类似，**流只能遍历一次**！遍历完之后，我们就说这个流已经被消费掉了。你可以从原始数据源那里再获得一个新的流来重新遍历一遍，就像迭代器一样（这里假设它是集合之类的可重复的源，如果是I/O通道就没戏了）。
> 
> **关键区别二**：使用Collection接口需要用户去做迭代（比如用for-each） ，这称为**外部迭代**。 相反，Streams库使用**内部迭代**——它帮你把迭代做了，还把得到的流值存在了某个地方，你只要给出一个函数说要干什么就可以了。

 ![](attachments/Pasted%20image%2020250721094821.png)
### 举例说明

| 场景            | 类比说明                      |
| ------------- | ------------------------- |
| **集合**        | 下载完一部电影再播放，等待时间长但整个文件都在本地 |
| **流**         | 边看边下，不用等全部加载完，用户体验更好      |
| **无限流（如质数流）** | 集合无法表示无限数据，但流可以按需生成       |
| **搜索结果展示**    | 显示前10条匹配项（流），点击“下一页”再加载更多 |
