## 收集器用作高级归约
一般来说， Collector会对元素应用一个转换函数（很多时候是不体现任何效果的恒等转换，例如toList），并将结果累积在一个数据结构中，从而产生这一过程的最终输出。

> 收集器是对终端操作的一种**参数化抽象**，把流元素“汇聚”成某种结构或结果。

收集器是一种**策略接口**（Collector<T, A, R>）：

- T：输入元素的类型
- A：中间累积类型（通常是容器）
- R：最终返回结果类型

```java
public interface Collector<T, A, R> {
    Supplier<A> supplier();                  // 创建累加器
    BiConsumer<A, T> accumulator();          // 将元素添加到结果容器
    BinaryOperator<A> combiner();            // 并行时合并两个容器
    Function<A, R> finisher();               // 将中间容器转为最终结果
    Set<Characteristics> characteristics();  // 特征，如是否并行安全、是否是身份转换等
}
```

> `Collectors.toList()` 就是一个 Collector 的工厂方法返回值，它封装了 `ArrayList::new`, `List::add`, 等函数。

## 归约汇总

```java
double avg = personList.stream().collect(averagingInt(Person::getAge));  
System.out.println(avg);  // 30.0

DoubleSummaryStatistics collect = personList.stream().collect(summarizingDouble(Person::getAge));  
System.out.println(collect);  // DoubleSummaryStatistics{count=5, sum=150.000000, min=10.000000, average=30.000000, max=50.000000}
  
String names = personList.stream().map(Person::getName).collect(joining(","));  
System.out.println(names);  // p1,p2,p3,p4,p5
```
### 广义的归约汇总
们已经讨论的所有收集器，都是一个可以用**reducing工厂方法**定义的归约过程的特殊情况而已。**Collectors.reducing工厂方法是所有这些特殊情况的一般化。**

如下示例：
```java
int totalCalories = menu.stream().collect(reducing(0, Dish::getCalories, (i, j) -> i + j));
```

它需要三个参数：
1. 归约操作的起始值，也是流中没有元素时的返回值，所以很显然对于数值和而言，0是一个合适的值。
2. 何从元素提取聚合值函数，将菜肴转换成一个表示其所含热量的int。
3. 如何将两个中间结果合并 **BinaryOperator**，将两个项目累积成一个同类型的值。这里它就是对两个int求和。
## 分组
一、**简单分组**：
```java
Map<Dish.Type, List<Dish>> dishesByType =
    menu.stream().collect(Collectors.groupingBy(Dish::getType));
```
>普通的单参数`groupingBy(f)`（其中f是分类函数）实际上是`groupingBy(f,toList())`的简便写法。

二、**带下游收集器**：
```java
Map<Dish.Type, Long> countByType =
    menu.stream().collect(Collectors.groupingBy(Dish::getType, counting()));
```

```java
Map<Dish.Type, Optional<Dish>> mostCaloricByType = menu.stream()  
.collect(groupingBy(Dish::getType, maxBy(comparingInt(Dish::getCalories))));
```
> 结果显然是一个map，以Dish的类型作为键，以包装了该类型中热量最高的Dish的`Optional<Dish>`作为值。
> 
> **注意**：`Optional<Dish>`作为值并不合适，从逻辑上看，如果没有这一种类的Dish，就不可能有之一种类的最大值，除非是空元素等意外情况。所以我们要过滤这种情况

**把收集器返回的结果转换为另一种类型，你可以使用Collectors.collectingAndThen工厂方法返回的收集器**

```java
Map<Dish.Type, Dish> mostCaloricByType =  
        menu.stream()  
                .collect(groupingBy(Dish::getType,  
                        collectingAndThen(  
                                maxBy(comparingInt(Dish::getCalories)),  
                                Optional::get)));
```
> 这个工厂方法接受两个参数——要转换的收集器以及转换函数，并返回另一个收集器。



三、**多级分组**：
```java
Map<Dish.Type, Map<CaloricLevel, List<Dish>>> dishesByTypeCaloricLevel =
    menu.stream().collect(Collectors.groupingBy(Dish::getType,
        groupingBy(d -> {
            if (d.getCalories() <= 400) return CaloricLevel.DIET;
            else if (d.getCalories() <= 700) return CaloricLevel.NORMAL;
            else return CaloricLevel.FAT;
        })));
```
> 分组可以无限嵌套，但**代码结构和函数式命名表达能力至关重要**。


通过使用toCollection，你就可以有更多的控制。例如，你可以给它传递一个构造函数引用来要求HashSet：
```java
Map<Dish.Type, Set<CaloricLevel>> caloricLevelsByType =  
        menu.stream().collect(  
                groupingBy(Dish::getType, mapping(  
                        dish -> { if (dish.getCalories() <= 400) return CaloricLevel.DIET;  
                        else if (dish.getCalories() <= 700) return CaloricLevel.NORMAL;  
                        else return CaloricLevel.FAT; },  
                        toCollection(HashSet::new) )));
```

## 分区
分区是分组的特殊情况，返回一个布尔值，这意味着得到的分组Map的键类型是Boolean，于是它最多可以分为两组——true是一组， false是一组。
```java
Map<Boolean, Map<Dish.Type, List<Dish>>> vegetarianDishesByType =
menu.stream().collect(partitioningBy(Dish::isVegetarian,
groupingBy(Dish::getType)));
```

## 收集器接口

看看Collector接口的定义，它列出了接口的签名以及声明的五个方法：
```java
public interface Collector<T, A, R> {
	Supplier<A> supplier();
	BiConsumer<A, T> accumulator();
	Function<A, R> finisher();
	BinaryOperator<A> combiner();
	Set<Characteristics> characteristics();
}
```
- T是流中要收集的项目的泛型。
- A是累加器的类型，累加器是在收集过程中用于累积部分结果的对象。
- R是收集操作得到的对象（通常但并不一定是集合）的类型。

例如，你可以实现一个`ToListCollector<T>`类，将`Stream<T>`中的所有元素收集到一个`List<T>`里，它的签名如下：

`public class ToListCollector<T> implements Collector<T, List<T>, List<T>>`

1.建立新的结果容器：**supplier**方法
```java
public Supplier<List<T>> supplier() {
	return ArrayList::new;
}
```
2.将元素添加到结果容器：**accumulator**方法
```java
public BiConsumer<List<T>, T> accumulator() {
	return List::add;
}
```
3.对结果容器应用最终转换：**finisher**方法
```java
public Function<List<T>, List<T>> finisher() {
	return Function.identity();
}
```
![](../../../addition/Pasted%20image%2020250728102336.png)
4.合并两个结果容器：**combiner**方法
```java
public BinaryOperator<List<T>> combiner() {
	return (list1, list2) -> {
		list1.addAll(list2);
		return list1; 
	}
}
```
有了这第四个方法，就可以对流进行**并行**归约了，他会使用分支/合并框架和Spliterator抽象，大致流程是：每次把流拆成两个子部分，直到子流 足够小 ，处理完成后合并每个结果，即combiner方法。

5.**characteristics**方法

characteristics会返回一个不可变的Characteristics集合，它定义了收集器的行为——尤其是关于流是否可以并行归约，以及可以使用哪些优化的提示。

Characteristics是一个包含三个项目的枚举：
- **UNORDERED**——归约结果不受流中项目的遍历和累积顺序的影响。
- **CONCURRENT**——accumulator函数可以从多个线程同时调用，且该收集器可以并行归约流。如果收集器没有标为UNORDERED，那它仅在用于无序数据源时才可以并行归约。
- **IDENTITY_FINISH**——这表明完成器方法返回的函数是一个恒等函数，可以跳过。这种情况下，累加器对象将会直接用作归约过程的最终结果。这也意味着，将累加器A不加检查地转换为结果R是安全的。

我们迄今开发的ToListCollector是IDENTITY_FINISH的，因为用来累积流中元素的List已经是我们要的最终结果，用不着进一步转换了；但它并不是UNORDERED，因为用在有序流上的时候，我们还是希望顺序能够保留在得到的List中；最后，它是CONCURRENT的，但我们刚才说过了，仅仅在背后的数据源无序时才会并行处理。

### 使用我们自己写的”toList“
```java
List<Dish> dishes = menuStream.collect(new ToListCollector<Dish>());

List<Dish> dishes = menuStream.collect(toList());
```

构造之间的其他差异在于**toList是一个工厂**，而ToListCollector必须用new来实例化。

### 进行自定义收集而不去实现**Collector**
对于`IDENTITY_FINISH`的收集操作，还有一种方法可以得到同样的结果而无需从头实现新的`Collectors`接口。 `Stream`有一个重载的`collect`方法可以接受另外三个函数——`supplier`、`accumulator`和`combiner`，其语义和Collector接口的相应方法返回的函数完全相同。

```java
List<Dish> dishes = menuStream.collect(
								ArrayList::new,
								List::add,
								List::addAll);
```

> **注意**：注意的是，这个`collect`方法不能传递任何`Characteristics`，所以它永远都是一个`IDENTITY_FINISH`和`CONCURRENT`但并非`UNORDERED`的收集器。

### 质数流自定义`Collector`
```java
  
public class PrimeNumbersCollector implements Collector<
	Integer, 
	Map<Boolean, List<Integer>>, 
	Map<Boolean, List<Integer>>> {  
    @Override  
    public Supplier<Map<Boolean, List<Integer>>> supplier() {  
        return () -> new HashMap<Boolean, List<Integer>>() {{  
            put(true, new ArrayList<Integer>());  
            put(false, new ArrayList<Integer>());  
        }};  
    }  
  
    @Override  
    public BiConsumer<Map<Boolean, List<Integer>>, Integer> accumulator() {  
        return (Map<Boolean, List<Integer>> acc, Integer candidate) -> {  
            acc.get(isPrime(acc.get(true),  
                            candidate))  
                    .add(candidate);  
        };  
    }  
  
    @Override  
    public BinaryOperator<Map<Boolean, List<Integer>>> combiner() {  
        return (Map<Boolean, List<Integer>> map1,  
                Map<Boolean, List<Integer>> map2) -> {  
            map1.get(true).addAll(map2.get(true));  
            map1.get(false).addAll(map2.get(false));  
            return map1;  
        };  
    }  
  
    @Override  
    public Function<Map<Boolean, List<Integer>>,  
            Map<Boolean, List<Integer>>> finisher() {  
        return Function.identity();  
    }  
  
    @Override  
    public Set<Characteristics> characteristics() {  
        return Collections.unmodifiableSet(EnumSet.of(IDENTITY_FINISH));  
    }  
	// 和isPrime结合使用，返回小于开根整数的前缀质数集合，用于快速计算后面的数是否质数
	public static <A> List<A> takeWhile(List<A> list, Predicate<A> p) {  
	    int i = 0;  
	    for (A item : list) {
	        if (!p.test(item)) {
	            return list.subList(0, i);
	        }
	        i++;
	        return list;
	    }  
	}

	public static boolean isPrime(List<Integer> primes, int candidate){  
	    int candidateRoot = (int) Math.sqrt((double) candidate);  
	    return takeWhile(primes, i -> i <= candidateRoot)  
	            .stream()  
	            .noneMatch(p -> candidate % p == 0);  
	}
}
// 自定义分区收集器
public Map<Boolean, List<Integer>> partitionPrimesWithCustomCollector(int n) {
	return IntStream.rangeClosed(2, n).boxed().collect(new PrimeNumbersCollector());
}
```
