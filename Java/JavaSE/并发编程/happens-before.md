## 产生并发问题的根源
**可见性**

单核CPU执行的多线程程序，其中一个线程修改了某个变量 A 的值，对自己，对其他线程来说是可见的

因为单核CPU内存缓存是由执行的多个线程共享的，实时的，这种 一个线程的修改对另一个线程实时可见的就叫 **可见性**

但是，在多核CPU执行的程序就有问题，因为每个内核都有各自独立的内存缓存，所以一个线程的修改可能不及时的被另一个线程发现

**原子性**

一个操作在是不可分割的最小单元

**有序性**

程序在编译的过程中会进行优化，可能会调整部分代码的执行顺序，因此并不能认为程序一定就是可靠的从上往下执行

为了保证执行顺序不变，或者禁用某些代码的优化，直接从内存里读取数据，可以使用volatile来修饰

例如在这样并发程序中，线程A执行完，给instance初始化，线程B必须判断instance已经初始化后再运行

用volatile修饰instance，既可以让线程B去读内存里面的信息，也可以保证对B可见