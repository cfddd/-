> [AQS 详解 | JavaGuide](https://javaguide.cn/java/concurrent/aqs.html#aqs-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3)


## AQS是什么
AQS 就是一个抽象类，主要用来构建锁和同步器。

```java
public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer implements java.io.Serializable {
}
```

AQS 为构建锁和同步器提供了一些通用功能的实现，因此，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 `ReentrantLock`，`Semaphore`，其他的诸如 `ReentrantReadWriteLock`，`SynchronousQueue`等等皆是基于 AQS 的。
## AQS 核心思想
如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。

如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制

这个机制 AQS 是基于 **CLH 锁** （Craig, Landin, and Hagersten locks） 实现的。
### CLH锁
CLH 锁是对自旋锁的一种改进，是一个虚拟的双向队列，暂时获取不到锁的线程将被加入到该队列中。

AQS 将每条请求共享资源的线程封装成一个 CLH 队列锁的一个结点（Node）来实现锁的分配。

在 CLH 队列锁中，一个节点表示一个线程，它保存着这些东西：
- 线程的引用（thread）
- 当前节点在队列中的状态（waitStatus）
- 前驱节点（prev）
- 后继节点（next）

如果线程请求的共享资源空闲，则将线程设置为有效的工作线程，并且将共享资源设置为锁定状态。

如果线程尝试获取同步状态失败时，它会被封装成一个节点并添加到等待队列的尾部。然后，线程会在节点上等待，直到它被前驱节点唤醒或者被中断。
### AQS 的工作流程
AQS 使用 **int 成员变量 `state` 表示同步状态**，通过内置的 **FIFO 线程等待/等待队列**，也就是 **CLH队列** 来完成获取资源线程的排队工作。

`state` 这个变量可以被不同的同步器根据自己的需求进行解释。

例如，在 ReentrantLock 中，这个变量可以用来表示锁被持有了多少次，来实现**可重入性**，state代表线程重入的次数，每次加锁或者冲入都是+1，相应的就要有相同次数的解锁，即-1

在 CountDownLatch 中，这个变量可以表示还需要等待多少个事件发生。state每次减一，代表一个任务的完成；主线程被放在CLH队列中，需要等待state变为0，才会被唤醒并执行

## AQS 的优势与应用场景
**优势**：
- AQS 提供了一种高度可复用的同步框架，避免了每个并发工具都从头开始实现复杂的同步机制。
- 它将同步状态的管理、等待队列的维护以及线程的阻塞和唤醒等通用操作封装起来，使得开发者可以专注于实现具体的同步语义。


 **应用场景**：
 - 在需要实现自定义的锁或者同步器时，AQS 是一个非常好的选择。例如，当需要设计一个具有特定公平性策略的锁，或者一个能够实现读写分离语义的同步器时，都可以通过继承 AQS 并根据具体需求重写相关方法来实现。