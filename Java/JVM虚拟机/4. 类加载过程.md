## 类的生命周期
生命周期可以简单概括为 7 个阶段：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）。其中，验证、准备和解析这三个阶段可以统称为连接（Linking）。
![](http://file.cfd.hhblog.top/myPicture/20240818172131.png)
## 类加载的触发时机
**有且只有**六种会触发类型进行初始化的场景：
1. new变量 或者 访问静态变量和方法，类型没有进行过初始化
2. 反射
3. 加载类的父类未被初始化
4. main主类
5. 动态代理
6. 接口的实现类发生了初始化，且接口有 default 方法
## 类的加载过程
系统加载 Class 类型的文件主要三步：加载->连接->初始化。连接过程又可分为三步：验证->准备->解析。

### 1.加载
类加载过程的第一步，主要完成下面 3 件事情：
1. 通过**全类名**获取定义此类的二进制字节流。
2. 将字节流所代表的**静态存储结构**转换为方法区的**运行时数据结构**。
3. **在内存中生成一个代表该类的 Class 对象**，作为方法区这些数据的访问入口。

加载阶段结束后，Java 虚拟机外部的**二进制字节流**就按照虚拟机所设定的格式存储在**方法区**之中了，方法区中的数据存储格式完全由虚拟机实现自行定义

加载阶段与连接阶段的部分动作(如一部分字节码文件格式验证动作)是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了。

### 2.验证
验证是连接阶段的第一步，这一阶段的目的是**确保 Class 文件的字节流中包含的信息符合《Java 虚拟机规范》的全部约束要求**，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。

验证阶段大致上会完成下面四个阶段的检验动作：文件格式验证、元数据验证、字节码验证和符号引用验证。 

> 可以跳过验证吗？

验证阶段对于虚拟机的类加载机制来说，是一个非常重要的、但却不是必须要执行的阶段

因为验证阶段只有通过或者不通过的差别，只要通过了验证，其后就对程序运行期没有任何影响了。

所以经过大量验证过的程序，可以跳过验证
### 3.准备

准备阶段是为类变量（**被`static`修饰的变量**）分配内存并设置**初始值**。这里的初始值是指数据类型的**默认零值**，而不是代码中显式赋值的值。

**示例**：如果有一个类`Test`，其中有一个静态变量`public static int value = 123;`，在准备阶段，`value`会被分配内存，并且初始值被设置为 0，而不是 123。123 这个值会在初始化阶段才被赋予。
### 4.解析
解析阶段是虚拟机将**常量池**内的**符号引用**替换为**直接引用**的过程。 
- **符号引用**：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可，**与内存布局无关**。
	- 例如：例如，在`System.out.println("Hello");`中，`System`、`out`和`println`在编译阶段都是以符号的形式存在。对于`System`，它代表一个类的全限定名`java.lang.System`；`out`是`System`类中的一个静态成员变量的名称；`println`是`java.io.PrintStream`类中的一个方法名称和描述符。**这些符号在编译时并不确定具体的内存地址，只是一种逻辑上的引用。**
- **直接引用**：可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。**内存布局直接相关**
	- 和上面相同的例子，`System.out.println`中，`System`、`out`都会被设置为直接引用的指针，可以定位到内存中实际存在的，可执行的java代码
### 5.初始化
初始化阶段是执行初始化方法 `<clinit> ()`方法的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。

执行**静态初始化块**中的代码。例如，静态初始化块`static { System.out.println("Initializing Test class"); }`

> `<clinit>()`方法是什么？
> 
> 1. `<clinit>()`方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的
> 2. `<clinit>()`方法与类的构造函数不同，它不需要显式地调用父类构造器，JVM会自动先执行父类的`<clinit>()`
> 3. 父类中定义的静态语句块要优先于子类的变量赋值操作
> 4. `<clinit>()`方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成`<clinit>()`方法。 
> 5. 一个类的`<clinit>()`方法在多线程环境中被正确地加锁同步，只会有其中一个线程去执行

### 6.类卸载

卸载类即该类的 Class 对象被 GC。卸载类需要满足 3 个要求：
1. 该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。
2. 该类没有在其他任何地方被
3. 引用该类的类加载器的实例已被 GC

在 JVM 生命周期内，由 jvm 自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。
## 小结
1. 生命周期简单概括：加载、链接、初始化。其中链接分为三步：验证、准备、解析
2. 加载类的时机有且仅有6个，简单理解为：类型或者父类型没有进行过初始化，才需要加载