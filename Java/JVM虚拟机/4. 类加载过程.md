## 类的生命周期
生命周期可以简单概括为 7 个阶段：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）。其中，验证、准备和解析这三个阶段可以统称为连接（Linking）。
![](http://douyin.cfddfc.online/myPicture/20240818172131.png)
## 类加载的触发时机
**有且只有**六种会触发类型进行初始化的场景：
1. new变量 或者 访问静态变量和方法，类型没有进行过初始化
2. 反射
3. 加载类的父类未被初始化
4. main主类
5. 动态代理
6. 接口的实现类发生了初始化，且接口有 default 方法
## 类的加载过程
系统加载 Class 类型的文件主要三步：加载->连接->初始化。连接过程又可分为三步：验证->准备->解析。

### 1.加载
类加载过程的第一步，主要完成下面 3 件事情：
1. 通过全类名获取定义此类的二进制字节流。
2. 将字节流所代表的静态存储结构转换为方法区的运行时数据结构。
3. 在内存中生成一个代表该类的 Class 对象，作为方法区这些数据的访问入口。

加载阶段结束后，Java 虚拟机外部的**二进制字节流**就按照虚拟机所设定的格式存储在**方法区**之中了，方法区中的数据存储格式完全由虚拟机实现自行定义

加载阶段与连接阶段的部分动作(如一部分字节码文件格式验证动作)是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了。

### 2.验证
验证是连接阶段的第一步，这一阶段的目的是确保 Class 文件的字节流中包含的信息符合《Java 虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。

验证阶段大致上会完成下面四个阶段的检验动作：文件格式验证、元数据验证、字节码验证和符号引用验证。 

> 可以跳过验证吗？

验证阶段对于虚拟机的类加载机制来说，是一个非常重要的、但却不是必须要执行的阶段

因为验证阶段只有通过或者不通过的差别，只要通过了验证，其后就对程序运行期没有任何影响了。

所以经过大量验证过的程序，可以跳过验证
### 3.准备
准备阶段是正式为类变量分配内存并设置类变量初始值的阶段
### 4.解析
解析阶段是虚拟机将常量池内的**符号引用**替换为**直接引用**的过程。 
- 符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。内存布局无关
- 直接引用：可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。内存布局直接相关
### 5.初始化
初始化阶段是执行初始化方法 `<clinit> ()`方法的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。

> `<clinit>()`方法是什么？
> 
> 1. `<clinit>()`方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的
> 2. `<clinit>()`方法与类的构造函数不同，它不需要显式地调用父类构造器，JVM会自动先执行父类的`<clinit>()`
> 3. 父类中定义的静态语句块要优先于子类的变量赋值操作
> 4. `<clinit>()`方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成`<clinit>()`方法。 
> 5. 一个类的`<clinit>()`方法在多线程环境中被正确地加锁同步，只会有其中一个线程去执行

### 6.类卸载

卸载类即该类的 Class 对象被 GC。卸载类需要满足 3 个要求：
1. 该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。
2. 该类没有在其他任何地方被
3. 引用该类的类加载器的实例已被 GC

在 JVM 生命周期内，由 jvm 自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。
