## 类加载器介绍
类加载器的主要作用就是加载 Java 类的字节码（ .class 文件）到 JVM 中（在内存中生成一个代表该类的 Class 对象）。

## 双亲委派模型
绝大多数 Java 程序都会使用到以下 3 个系统提供的类加载器来进行加载。 
- **启动类加载器**：负责加载存放在 <JAVA_HOME>\lib 目录，或者被-Xbootclasspath 参数所指定的路径中存放的类库
- **扩展类加载器**：加载<JAVA_HOME>\lib\ext 目录中，或者被 java.ext.dirs 系统变量所指定的路径中所有的类库。
- **应用程序类加载器**：加载用户类路径（ClassPath）上所有的类库。一般情况下这个就是程序 中默认的类加载器。 
![](http://file.cfd.hhblog.top/myPicture/20240818181937.png)
还可以加入自定义的类加载器来进行拓展，典型的如增加除了磁盘位置之外的 Class 文件来源，或者通过类加载器实现类的隔离、重载等功能。

图中展示的各种类加载器之间的层次关系被称为类加载器的“**双亲委派模型**（Parents Delegation Model）”

双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。

类加载器之间的父子关系一般不是继承（Inheritance），通常使用组合 （Composition）关系来复用父加载器的代码。 

> **双亲委派模型的工作过程**

如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成

因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。 

> 双亲委派的意义？

比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个 Class 文件，被同一个 Java 虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。 

 Java 中的类随着它的类加载器一起具备了一种带有优先级的层次关系。

双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。

例如类 java.lang.Object，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此 Object 类在程序的各种类加载器环境中都能够保证是同一个类。


> 类加载器加载规则

先检查请求加载的类型是否已经被加载过，若没有则调用父加载器的 loadClass()方法

若父加载器为空则默认使用启动类加载器作为父加载器。假如父类加载器加载失败，抛出 异常的话，才调用自己的 findClass()方法尝试进行加载。 

### 破坏双亲委派模型 
如果我们不想打破双亲委派模型，就重写 `ClassLoader` 类中的 `findClass()` 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。

类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 `loadClass()`方法来加载类）。


所以，如果想打破双亲委派模型则需要**重写 `loadClass()` 方法**。

## 小结

> [老大难的 Java ClassLoader 再不理解就老了 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/51374915)
> 
> [一看就懂，详解Java中的类加载器机制，附热加载示例代码演示_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1ZY4y1n7tg/?spm_id_from=333.337.search-card.all.click&vd_source=7ada4d669a95497ac330fb40c472d239)

1. 类加载器的主要作用就是加载 Java 类的字节码到JVM内存中，并生成一个Class对象
2.  双亲委派模型（**Parents Delegation Model**），并不是指继承关系，而是组合
3. 类加载器主要有三种：**启动类加载器、拓展类加载器 和 应用程序类加载器**，除此之外还有**用户自定义类加载器（继承ClassLoader）**，类加载器之间规则如下：
	1. 在类加载的时候，首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载
	2. 加载器使用组合的的方式，即委托，优先调用委派对象的类加载方法
	3. 如果委派对象加载失败，才会尝试自己去加载
	4. 如果所有类加载器都失败了，抛出异常
4. JVM判断两个对象是否相同，需要先检查 {类加载器，全类名} 这样的二元组是否相同
5. 所有的加载器最终都会走到最顶层的启动类加载器，保证了加载出来的类是唯一的，也保证了 Java 的核心 API 不被篡改。
6. 自定义类加载器，可以重写 `loadClass()` 方法打破双亲委派模型
7. 自定义类加载器还可以实现热部署
