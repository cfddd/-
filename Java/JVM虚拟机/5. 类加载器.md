## 类加载器介绍
类加载器的主要作用就是加载 Java 类的字节码（ .class 文件）到 JVM 中（在内存中生成一个代表该类的 Class 对象）。

## 双亲委派模型
绝大多数 Java 程序都会使用到以下 3 个系统提供的类加载器来进行加载。 
- **启动类加载器**：负责加载存放在 <JAVA_HOME>\lib 目录，或者被-Xbootclasspath 参数所指定的路径中存放的类库
- **扩展类加载器**：加载<JAVA_HOME>\lib\ext 目录中，或者被 java.ext.dirs 系统变量所指定的路径中所有的类库。
- **应用程序类加载器**：加载用户类路径（ClassPath）上所有的类库。一般情况下这个就是程序 中默认的类加载器。 
![](http://douyin.cfddfc.online/myPicture/20240818181937.png)
还可以加入自定义的类加载器来进行拓展，典型的如增加除了磁盘位置之外的 Class 文件来源，或者通过类加载器实现类的隔离、重载等功能。

图中展示的各种类加载器之间的层次关系被称为类加载器的“**双亲委派模型**（Parents Delegation Model）”

双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。

类加载器之间的父子关系一般不是继承（Inheritance），通常使用组合 （Composition）关系来复用父加载器的代码。 

> **双亲委派模型的工作过程**

如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成

因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。 

> 双亲委派的意义？

比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个 Class 文件，被同一个 Java 虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。 

 Java 中的类随着它的类加载器一起具备了一种带有优先级的层次关系。

双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。

例如类 java.lang.Object，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此 Object 类在程序的各种类加载器环境中都能够保证是同一个类。


> 类加载器加载规则

先检查请求加载的类型是否已经被加载过，若没有则调用父加载器的 loadClass()方法

若父加载器为空则默认使用启动类加载器作为父加载器。假如父类加载器加载失败，抛出 异常的话，才调用自己的 findClass()方法尝试进行加载。 

### 破坏双亲委派模型 
如果我们不想打破双亲委派模型，就重写 `ClassLoader` 类中的 `findClass()` 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。

类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 `loadClass()`方法来加载类）。


所以，如果想打破双亲委派模型则需要**重写 `loadClass()` 方法**。
