> [从实际案例聊聊Java应用的GC优化 - 美团技术团队 (meituan.com)](https://tech.meituan.com/2017/12/29/jvm-optimize.html)
> 
>[面试官：如何进行 JVM 调优（附真实案例） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/488615913)
## 什么情况下需要JVM调优
大部分情况下都不需要JVM调优，问题集中出现在代码和架构上

当Java程序性能达不到既定目标，且其他优化手段都已经穷尽时，通常需要调整垃圾回收器来进一步提高性能，称为GC优化。

GC优化不能解决一切性能问题，它是最后的调优手段。
## 知识准备
 GC相关基础知识，包括但不限于： 
 
 1. GC工作原理（常用的垃圾回收器：串行、并行、吞吐量优先、CMS）
 2. 理解新生代、老年代、晋升等术语含义（）
 3. 可以看懂GC日志

> **IDEA2023+版本如何配置查看GC日志?**
> 
> 改版之后没有直接显示VM options，需要在另一个栏目里面重新找到
> 1. Edit Configurations
> 2. Build And Run
> 3. Modify options
> 4. Add MV options
> 5. 现在【Edit Configurations】里面就有了VM options，可以配置了

### GC工作原理
当代主流JVM虚拟机的垃圾回收器都采用“分代回收”的算法。基于这样一个事实：

**对象的生命周期不同，所以针对不同生命周期的对象可以采取不同的回收方式，以便提高回收效率。** 主要分成新生代、老年代和永久代

1. 新生代：
	1. 大多数对象在新生代中被创建，其中很多对象的生命周期很短。
	2. 针对新生代的垃圾回收称为Minor GC
	3. 回收后只要少量对象存活，所以选用标记复制算法，只需要少量的复制成本就可以完成回收
	4. 新生代还有两个 **幸存者区**
2. 老年代：
	1. 在新生代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代，该区域中对象存活率高
	2. 老年代的垃圾回收（又称Major GC）通常使用“标记-清理”或“标记-整理”算法。
	3. 整堆包括新生代和老年代的垃圾回收称为Full GC
3. 永久代：
	1. 主要存放元数据，例如Class、Method的元信息，与垃圾回收要回收的Java对象关系不大
	2. 对于新生代和年老代来说，该区域的划分对垃圾回收影响比较小。
### 常见垃圾回收器
1. 单线程收集器
2. 多线程收集器
3. CMS：一种以获取最短回收停顿时间为目标的回收器，该回收器是基于“标记-清除”算法实现的。
	1. 主要步骤是：**初始标记、并发标记、重新标记，并发清除**
	2. 从整体上来看，gc过程是和工作线程一起并发执行的
	3. 但是也有三个缺点：**产生浮动垃圾、“标记-清除”算法产生大量空间碎片、占用工作线程对CPu敏感**
4. G1：G1 不再坚持固定大小以及固定数量的分代区域划分，而是把连续的 Java 堆划分为多个大小相等的独立区域（Region），每一个 Region 都可以根据需要，扮演新生代的 Eden 空间、 Survivor 空间，或者老年代空间。 虽然 G1 仍然保留新生代和老年代的概念，但新生代和老年代不再是固定的了，它们都是一系列区域（不需要连续）的动态集合。
#### G1的优点，相比于CMS
- **可以指定最大停顿时间**（停）
- **分 Region 的内存布局**（块）
- **按收益动态确定回收集**（动）
- 从整体来看是基于“标记-整理”算法实现的收集器，但从局部（两个 Region 之间）上看又是基于“标记-复制”算法实现，这两种算法都意味着 **G1 运作期间不会产生内存空间碎片，垃圾收集完成之后能提供规整的可用内存。**（整体局部）
- 有利于程序长时间运行，在程序为大对象分配内存时不容易因无法找到连续内存空间而提前触发下一次收集。（长）
#### G1的缺点
- 内存占用要比 CMS 要高。 
- 程序运行时的额外执行负载都要比 CMS 要高。 
	它们都使用到写屏障，CMS 用写后屏障来更新维护卡表；
	而 G1 除了使用写后屏障， 为了实现原始快照搜索（SATB）算法，还需要使用写前屏障来跟踪并发时的指针变化情况。
### GC日志
## 优化步骤
GC优化一般步骤可以概括为：确定目标、优化参数、验收结果。
### 一、确定目标
- 高可用，可用性达到几个9。 
- 低延迟，请求必须多少毫秒内完成响应。
- 高吞吐，每秒完成多少次事务。
